<!DOCTYPE html><html lang=en> <head><meta charset=utf-8><meta name=viewport content="width=device-width, initial-scale=1"><meta name=generator content="pytest-reporter-html1 0.8.2"><title>Test Report</title><style>
        html { line-height: 1.15;  -webkit-text-size-adjust: 100%;  }   body { margin: 0; }  main { display: block; }  h1 { font-size: 2em; margin: 0.67em 0; }   hr { box-sizing: content-box;  height: 0;  overflow: visible;  }  pre { font-family: monospace, monospace;  font-size: 1em;  }   a { background-color: transparent; }  abbr[title] { border-bottom: none;  text-decoration: underline;  text-decoration: underline dotted;  }  b, strong { font-weight: bolder; }  code, kbd, samp { font-family: monospace, monospace;  font-size: 1em;  }  small { font-size: 80%; }  sub, sup { font-size: 75%; line-height: 0; position: relative; vertical-align: baseline; } sub { bottom: -0.25em; } sup { top: -0.5em; }   img { border-style: none; }   button, input, optgroup, select, textarea { font-family: inherit;  font-size: 100%;  line-height: 1.15;  margin: 0;  }  button, input {  overflow: visible; }  button, select {  text-transform: none; }  button, [type="button"], [type="reset"], [type="submit"] { -webkit-appearance: button; }  button::-moz-focus-inner, [type="button"]::-moz-focus-inner, [type="reset"]::-moz-focus-inner, [type="submit"]::-moz-focus-inner { border-style: none; padding: 0; }  button:-moz-focusring, [type="button"]:-moz-focusring, [type="reset"]:-moz-focusring, [type="submit"]:-moz-focusring { outline: 1px dotted ButtonText; }  fieldset { padding: 0.35em 0.75em 0.625em; }  legend { box-sizing: border-box;  color: inherit;  display: table;  max-width: 100%;  padding: 0;  white-space: normal;  }  progress { vertical-align: baseline; }  textarea { overflow: auto; }  [type="checkbox"], [type="radio"] { box-sizing: border-box;  padding: 0;  }  [type="number"]::-webkit-inner-spin-button, [type="number"]::-webkit-outer-spin-button { height: auto; }  [type="search"] { -webkit-appearance: textfield;  outline-offset: -2px;  }  [type="search"]::-webkit-search-decoration { -webkit-appearance: none; }  ::-webkit-file-upload-button { -webkit-appearance: button;  font: inherit;  }   details { display: block; }  summary { display: list-item; }   template { display: none; }  [hidden] { display: none; }  .ansi2html-content { display: inline; white-space: pre-wrap; word-wrap: break-word; }.body_foreground { color: #000000; }.body_background { background-color: #AAAAAA; }.inv_foreground { color: #AAAAAA; }.inv_background { background-color: #000000; }.ansi1 { font-weight: bold; }.ansi2 { font-weight: lighter; }.ansi3 { font-style: italic; }.ansi4 { text-decoration: underline; }.ansi5 { text-decoration: blink; }.ansi6 { text-decoration: blink; }.ansi8 { visibility: hidden; }.ansi9 { text-decoration: line-through; }.ansi30 { color: #000316; }.inv30 { background-color: #000316; }.ansi31 { color: #aa0000; }.inv31 { background-color: #aa0000; }.ansi32 { color: #00aa00; }.inv32 { background-color: #00aa00; }.ansi33 { color: #aa5500; }.inv33 { background-color: #aa5500; }.ansi34 { color: #0000aa; }.inv34 { background-color: #0000aa; }.ansi35 { color: #E850A8; }.inv35 { background-color: #E850A8; }.ansi36 { color: #00aaaa; }.inv36 { background-color: #00aaaa; }.ansi37 { color: #F5F1DE; }.inv37 { background-color: #F5F1DE; }.ansi40 { background-color: #000316; }.inv40 { color: #000316; }.ansi41 { background-color: #aa0000; }.inv41 { color: #aa0000; }.ansi42 { background-color: #00aa00; }.inv42 { color: #00aa00; }.ansi43 { background-color: #aa5500; }.inv43 { color: #aa5500; }.ansi44 { background-color: #0000aa; }.inv44 { color: #0000aa; }.ansi45 { background-color: #E850A8; }.inv45 { color: #E850A8; }.ansi46 { background-color: #00aaaa; }.inv46 { color: #00aaaa; }.ansi47 { background-color: #F5F1DE; }.inv47 { color: #F5F1DE; }.ansi90 { color: #7f7f7f; }.inv90 { background-color: #7f7f7f; }.ansi91 { color: #ff0000; }.inv91 { background-color: #ff0000; }.ansi92 { color: #00ff00; }.inv92 { background-color: #00ff00; }.ansi93 { color: #ffff00; }.inv93 { background-color: #ffff00; }.ansi94 { color: #5c5cff; }.inv94 { background-color: #5c5cff; }.ansi95 { color: #ff00ff; }.inv95 { background-color: #ff00ff; }.ansi96 { color: #00ffff; }.inv96 { background-color: #00ffff; }.ansi97 { color: #ffffff; }.inv97 { background-color: #ffffff; }.ansi100 { background-color: #7f7f7f; }.inv100 { color: #7f7f7f; }.ansi101 { background-color: #ff0000; }.inv101 { color: #ff0000; }.ansi102 { background-color: #00ff00; }.inv102 { color: #00ff00; }.ansi103 { background-color: #ffff00; }.inv103 { color: #ffff00; }.ansi104 { background-color: #5c5cff; }.inv104 { color: #5c5cff; }.ansi105 { background-color: #ff00ff; }.inv105 { color: #ff00ff; }.ansi106 { background-color: #00ffff; }.inv106 { color: #00ffff; }.ansi107 { background-color: #ffffff; }.inv107 { color: #ffffff; }.ansi38-0 { color: #000316; }.inv38-0 { background-color: #000316; }.ansi38-1 { color: #aa0000; }.inv38-1 { background-color: #aa0000; }.ansi38-2 { color: #00aa00; }.inv38-2 { background-color: #00aa00; }.ansi38-3 { color: #aa5500; }.inv38-3 { background-color: #aa5500; }.ansi38-4 { color: #0000aa; }.inv38-4 { background-color: #0000aa; }.ansi38-5 { color: #E850A8; }.inv38-5 { background-color: #E850A8; }.ansi38-6 { color: #00aaaa; }.inv38-6 { background-color: #00aaaa; }.ansi38-7 { color: #F5F1DE; }.inv38-7 { background-color: #F5F1DE; }.ansi38-8 { color: #7f7f7f; }.inv38-8 { background-color: #7f7f7f; }.ansi38-9 { color: #ff0000; }.inv38-9 { background-color: #ff0000; }.ansi38-10 { color: #00ff00; }.inv38-10 { background-color: #00ff00; }.ansi38-11 { color: #ffff00; }.inv38-11 { background-color: #ffff00; }.ansi38-12 { color: #5c5cff; }.inv38-12 { background-color: #5c5cff; }.ansi38-13 { color: #ff00ff; }.inv38-13 { background-color: #ff00ff; }.ansi38-14 { color: #00ffff; }.inv38-14 { background-color: #00ffff; }.ansi38-15 { color: #ffffff; }.inv38-15 { background-color: #ffffff; }.ansi48-0 { background-color: #000316; }.inv48-0 { color: #000316; }.ansi48-1 { background-color: #aa0000; }.inv48-1 { color: #aa0000; }.ansi48-2 { background-color: #00aa00; }.inv48-2 { color: #00aa00; }.ansi48-3 { background-color: #aa5500; }.inv48-3 { color: #aa5500; }.ansi48-4 { background-color: #0000aa; }.inv48-4 { color: #0000aa; }.ansi48-5 { background-color: #E850A8; }.inv48-5 { color: #E850A8; }.ansi48-6 { background-color: #00aaaa; }.inv48-6 { color: #00aaaa; }.ansi48-7 { background-color: #F5F1DE; }.inv48-7 { color: #F5F1DE; }.ansi48-8 { background-color: #7f7f7f; }.inv48-8 { color: #7f7f7f; }.ansi48-9 { background-color: #ff0000; }.inv48-9 { color: #ff0000; }.ansi48-10 { background-color: #00ff00; }.inv48-10 { color: #00ff00; }.ansi48-11 { background-color: #ffff00; }.inv48-11 { color: #ffff00; }.ansi48-12 { background-color: #5c5cff; }.inv48-12 { color: #5c5cff; }.ansi48-13 { background-color: #ff00ff; }.inv48-13 { color: #ff00ff; }.ansi48-14 { background-color: #00ffff; }.inv48-14 { color: #00ffff; }.ansi48-15 { background-color: #ffffff; }.inv48-15 { color: #ffffff; }.ansi38-16 { color: #000000; }.inv38-16 { background: #000000; }.ansi48-16 { background: #000000; }.inv48-16 { color: #000000; }.ansi38-17 { color: #00005f; }.inv38-17 { background: #00005f; }.ansi48-17 { background: #00005f; }.inv48-17 { color: #00005f; }.ansi38-18 { color: #000087; }.inv38-18 { background: #000087; }.ansi48-18 { background: #000087; }.inv48-18 { color: #000087; }.ansi38-19 { color: #0000af; }.inv38-19 { background: #0000af; }.ansi48-19 { background: #0000af; }.inv48-19 { color: #0000af; }.ansi38-20 { color: #0000d7; }.inv38-20 { background: #0000d7; }.ansi48-20 { background: #0000d7; }.inv48-20 { color: #0000d7; }.ansi38-21 { color: #0000ff; }.inv38-21 { background: #0000ff; }.ansi48-21 { background: #0000ff; }.inv48-21 { color: #0000ff; }.ansi38-52 { color: #5f0000; }.inv38-52 { background: #5f0000; }.ansi48-52 { background: #5f0000; }.inv48-52 { color: #5f0000; }.ansi38-53 { color: #5f005f; }.inv38-53 { background: #5f005f; }.ansi48-53 { background: #5f005f; }.inv48-53 { color: #5f005f; }.ansi38-54 { color: #5f0087; }.inv38-54 { background: #5f0087; }.ansi48-54 { background: #5f0087; }.inv48-54 { color: #5f0087; }.ansi38-55 { color: #5f00af; }.inv38-55 { background: #5f00af; }.ansi48-55 { background: #5f00af; }.inv48-55 { color: #5f00af; }.ansi38-56 { color: #5f00d7; }.inv38-56 { background: #5f00d7; }.ansi48-56 { background: #5f00d7; }.inv48-56 { color: #5f00d7; }.ansi38-57 { color: #5f00ff; }.inv38-57 { background: #5f00ff; }.ansi48-57 { background: #5f00ff; }.inv48-57 { color: #5f00ff; }.ansi38-88 { color: #870000; }.inv38-88 { background: #870000; }.ansi48-88 { background: #870000; }.inv48-88 { color: #870000; }.ansi38-89 { color: #87005f; }.inv38-89 { background: #87005f; }.ansi48-89 { background: #87005f; }.inv48-89 { color: #87005f; }.ansi38-90 { color: #870087; }.inv38-90 { background: #870087; }.ansi48-90 { background: #870087; }.inv48-90 { color: #870087; }.ansi38-91 { color: #8700af; }.inv38-91 { background: #8700af; }.ansi48-91 { background: #8700af; }.inv48-91 { color: #8700af; }.ansi38-92 { color: #8700d7; }.inv38-92 { background: #8700d7; }.ansi48-92 { background: #8700d7; }.inv48-92 { color: #8700d7; }.ansi38-93 { color: #8700ff; }.inv38-93 { background: #8700ff; }.ansi48-93 { background: #8700ff; }.inv48-93 { color: #8700ff; }.ansi38-124 { color: #af0000; }.inv38-124 { background: #af0000; }.ansi48-124 { background: #af0000; }.inv48-124 { color: #af0000; }.ansi38-125 { color: #af005f; }.inv38-125 { background: #af005f; }.ansi48-125 { background: #af005f; }.inv48-125 { color: #af005f; }.ansi38-126 { color: #af0087; }.inv38-126 { background: #af0087; }.ansi48-126 { background: #af0087; }.inv48-126 { color: #af0087; }.ansi38-127 { color: #af00af; }.inv38-127 { background: #af00af; }.ansi48-127 { background: #af00af; }.inv48-127 { color: #af00af; }.ansi38-128 { color: #af00d7; }.inv38-128 { background: #af00d7; }.ansi48-128 { background: #af00d7; }.inv48-128 { color: #af00d7; }.ansi38-129 { color: #af00ff; }.inv38-129 { background: #af00ff; }.ansi48-129 { background: #af00ff; }.inv48-129 { color: #af00ff; }.ansi38-160 { color: #d70000; }.inv38-160 { background: #d70000; }.ansi48-160 { background: #d70000; }.inv48-160 { color: #d70000; }.ansi38-161 { color: #d7005f; }.inv38-161 { background: #d7005f; }.ansi48-161 { background: #d7005f; }.inv48-161 { color: #d7005f; }.ansi38-162 { color: #d70087; }.inv38-162 { background: #d70087; }.ansi48-162 { background: #d70087; }.inv48-162 { color: #d70087; }.ansi38-163 { color: #d700af; }.inv38-163 { background: #d700af; }.ansi48-163 { background: #d700af; }.inv48-163 { color: #d700af; }.ansi38-164 { color: #d700d7; }.inv38-164 { background: #d700d7; }.ansi48-164 { background: #d700d7; }.inv48-164 { color: #d700d7; }.ansi38-165 { color: #d700ff; }.inv38-165 { background: #d700ff; }.ansi48-165 { background: #d700ff; }.inv48-165 { color: #d700ff; }.ansi38-196 { color: #ff0000; }.inv38-196 { background: #ff0000; }.ansi48-196 { background: #ff0000; }.inv48-196 { color: #ff0000; }.ansi38-197 { color: #ff005f; }.inv38-197 { background: #ff005f; }.ansi48-197 { background: #ff005f; }.inv48-197 { color: #ff005f; }.ansi38-198 { color: #ff0087; }.inv38-198 { background: #ff0087; }.ansi48-198 { background: #ff0087; }.inv48-198 { color: #ff0087; }.ansi38-199 { color: #ff00af; }.inv38-199 { background: #ff00af; }.ansi48-199 { background: #ff00af; }.inv48-199 { color: #ff00af; }.ansi38-200 { color: #ff00d7; }.inv38-200 { background: #ff00d7; }.ansi48-200 { background: #ff00d7; }.inv48-200 { color: #ff00d7; }.ansi38-201 { color: #ff00ff; }.inv38-201 { background: #ff00ff; }.ansi48-201 { background: #ff00ff; }.inv48-201 { color: #ff00ff; }.ansi38-22 { color: #005f00; }.inv38-22 { background: #005f00; }.ansi48-22 { background: #005f00; }.inv48-22 { color: #005f00; }.ansi38-23 { color: #005f5f; }.inv38-23 { background: #005f5f; }.ansi48-23 { background: #005f5f; }.inv48-23 { color: #005f5f; }.ansi38-24 { color: #005f87; }.inv38-24 { background: #005f87; }.ansi48-24 { background: #005f87; }.inv48-24 { color: #005f87; }.ansi38-25 { color: #005faf; }.inv38-25 { background: #005faf; }.ansi48-25 { background: #005faf; }.inv48-25 { color: #005faf; }.ansi38-26 { color: #005fd7; }.inv38-26 { background: #005fd7; }.ansi48-26 { background: #005fd7; }.inv48-26 { color: #005fd7; }.ansi38-27 { color: #005fff; }.inv38-27 { background: #005fff; }.ansi48-27 { background: #005fff; }.inv48-27 { color: #005fff; }.ansi38-58 { color: #5f5f00; }.inv38-58 { background: #5f5f00; }.ansi48-58 { background: #5f5f00; }.inv48-58 { color: #5f5f00; }.ansi38-59 { color: #5f5f5f; }.inv38-59 { background: #5f5f5f; }.ansi48-59 { background: #5f5f5f; }.inv48-59 { color: #5f5f5f; }.ansi38-60 { color: #5f5f87; }.inv38-60 { background: #5f5f87; }.ansi48-60 { background: #5f5f87; }.inv48-60 { color: #5f5f87; }.ansi38-61 { color: #5f5faf; }.inv38-61 { background: #5f5faf; }.ansi48-61 { background: #5f5faf; }.inv48-61 { color: #5f5faf; }.ansi38-62 { color: #5f5fd7; }.inv38-62 { background: #5f5fd7; }.ansi48-62 { background: #5f5fd7; }.inv48-62 { color: #5f5fd7; }.ansi38-63 { color: #5f5fff; }.inv38-63 { background: #5f5fff; }.ansi48-63 { background: #5f5fff; }.inv48-63 { color: #5f5fff; }.ansi38-94 { color: #875f00; }.inv38-94 { background: #875f00; }.ansi48-94 { background: #875f00; }.inv48-94 { color: #875f00; }.ansi38-95 { color: #875f5f; }.inv38-95 { background: #875f5f; }.ansi48-95 { background: #875f5f; }.inv48-95 { color: #875f5f; }.ansi38-96 { color: #875f87; }.inv38-96 { background: #875f87; }.ansi48-96 { background: #875f87; }.inv48-96 { color: #875f87; }.ansi38-97 { color: #875faf; }.inv38-97 { background: #875faf; }.ansi48-97 { background: #875faf; }.inv48-97 { color: #875faf; }.ansi38-98 { color: #875fd7; }.inv38-98 { background: #875fd7; }.ansi48-98 { background: #875fd7; }.inv48-98 { color: #875fd7; }.ansi38-99 { color: #875fff; }.inv38-99 { background: #875fff; }.ansi48-99 { background: #875fff; }.inv48-99 { color: #875fff; }.ansi38-130 { color: #af5f00; }.inv38-130 { background: #af5f00; }.ansi48-130 { background: #af5f00; }.inv48-130 { color: #af5f00; }.ansi38-131 { color: #af5f5f; }.inv38-131 { background: #af5f5f; }.ansi48-131 { background: #af5f5f; }.inv48-131 { color: #af5f5f; }.ansi38-132 { color: #af5f87; }.inv38-132 { background: #af5f87; }.ansi48-132 { background: #af5f87; }.inv48-132 { color: #af5f87; }.ansi38-133 { color: #af5faf; }.inv38-133 { background: #af5faf; }.ansi48-133 { background: #af5faf; }.inv48-133 { color: #af5faf; }.ansi38-134 { color: #af5fd7; }.inv38-134 { background: #af5fd7; }.ansi48-134 { background: #af5fd7; }.inv48-134 { color: #af5fd7; }.ansi38-135 { color: #af5fff; }.inv38-135 { background: #af5fff; }.ansi48-135 { background: #af5fff; }.inv48-135 { color: #af5fff; }.ansi38-166 { color: #d75f00; }.inv38-166 { background: #d75f00; }.ansi48-166 { background: #d75f00; }.inv48-166 { color: #d75f00; }.ansi38-167 { color: #d75f5f; }.inv38-167 { background: #d75f5f; }.ansi48-167 { background: #d75f5f; }.inv48-167 { color: #d75f5f; }.ansi38-168 { color: #d75f87; }.inv38-168 { background: #d75f87; }.ansi48-168 { background: #d75f87; }.inv48-168 { color: #d75f87; }.ansi38-169 { color: #d75faf; }.inv38-169 { background: #d75faf; }.ansi48-169 { background: #d75faf; }.inv48-169 { color: #d75faf; }.ansi38-170 { color: #d75fd7; }.inv38-170 { background: #d75fd7; }.ansi48-170 { background: #d75fd7; }.inv48-170 { color: #d75fd7; }.ansi38-171 { color: #d75fff; }.inv38-171 { background: #d75fff; }.ansi48-171 { background: #d75fff; }.inv48-171 { color: #d75fff; }.ansi38-202 { color: #ff5f00; }.inv38-202 { background: #ff5f00; }.ansi48-202 { background: #ff5f00; }.inv48-202 { color: #ff5f00; }.ansi38-203 { color: #ff5f5f; }.inv38-203 { background: #ff5f5f; }.ansi48-203 { background: #ff5f5f; }.inv48-203 { color: #ff5f5f; }.ansi38-204 { color: #ff5f87; }.inv38-204 { background: #ff5f87; }.ansi48-204 { background: #ff5f87; }.inv48-204 { color: #ff5f87; }.ansi38-205 { color: #ff5faf; }.inv38-205 { background: #ff5faf; }.ansi48-205 { background: #ff5faf; }.inv48-205 { color: #ff5faf; }.ansi38-206 { color: #ff5fd7; }.inv38-206 { background: #ff5fd7; }.ansi48-206 { background: #ff5fd7; }.inv48-206 { color: #ff5fd7; }.ansi38-207 { color: #ff5fff; }.inv38-207 { background: #ff5fff; }.ansi48-207 { background: #ff5fff; }.inv48-207 { color: #ff5fff; }.ansi38-28 { color: #008700; }.inv38-28 { background: #008700; }.ansi48-28 { background: #008700; }.inv48-28 { color: #008700; }.ansi38-29 { color: #00875f; }.inv38-29 { background: #00875f; }.ansi48-29 { background: #00875f; }.inv48-29 { color: #00875f; }.ansi38-30 { color: #008787; }.inv38-30 { background: #008787; }.ansi48-30 { background: #008787; }.inv48-30 { color: #008787; }.ansi38-31 { color: #0087af; }.inv38-31 { background: #0087af; }.ansi48-31 { background: #0087af; }.inv48-31 { color: #0087af; }.ansi38-32 { color: #0087d7; }.inv38-32 { background: #0087d7; }.ansi48-32 { background: #0087d7; }.inv48-32 { color: #0087d7; }.ansi38-33 { color: #0087ff; }.inv38-33 { background: #0087ff; }.ansi48-33 { background: #0087ff; }.inv48-33 { color: #0087ff; }.ansi38-64 { color: #5f8700; }.inv38-64 { background: #5f8700; }.ansi48-64 { background: #5f8700; }.inv48-64 { color: #5f8700; }.ansi38-65 { color: #5f875f; }.inv38-65 { background: #5f875f; }.ansi48-65 { background: #5f875f; }.inv48-65 { color: #5f875f; }.ansi38-66 { color: #5f8787; }.inv38-66 { background: #5f8787; }.ansi48-66 { background: #5f8787; }.inv48-66 { color: #5f8787; }.ansi38-67 { color: #5f87af; }.inv38-67 { background: #5f87af; }.ansi48-67 { background: #5f87af; }.inv48-67 { color: #5f87af; }.ansi38-68 { color: #5f87d7; }.inv38-68 { background: #5f87d7; }.ansi48-68 { background: #5f87d7; }.inv48-68 { color: #5f87d7; }.ansi38-69 { color: #5f87ff; }.inv38-69 { background: #5f87ff; }.ansi48-69 { background: #5f87ff; }.inv48-69 { color: #5f87ff; }.ansi38-100 { color: #878700; }.inv38-100 { background: #878700; }.ansi48-100 { background: #878700; }.inv48-100 { color: #878700; }.ansi38-101 { color: #87875f; }.inv38-101 { background: #87875f; }.ansi48-101 { background: #87875f; }.inv48-101 { color: #87875f; }.ansi38-102 { color: #878787; }.inv38-102 { background: #878787; }.ansi48-102 { background: #878787; }.inv48-102 { color: #878787; }.ansi38-103 { color: #8787af; }.inv38-103 { background: #8787af; }.ansi48-103 { background: #8787af; }.inv48-103 { color: #8787af; }.ansi38-104 { color: #8787d7; }.inv38-104 { background: #8787d7; }.ansi48-104 { background: #8787d7; }.inv48-104 { color: #8787d7; }.ansi38-105 { color: #8787ff; }.inv38-105 { background: #8787ff; }.ansi48-105 { background: #8787ff; }.inv48-105 { color: #8787ff; }.ansi38-136 { color: #af8700; }.inv38-136 { background: #af8700; }.ansi48-136 { background: #af8700; }.inv48-136 { color: #af8700; }.ansi38-137 { color: #af875f; }.inv38-137 { background: #af875f; }.ansi48-137 { background: #af875f; }.inv48-137 { color: #af875f; }.ansi38-138 { color: #af8787; }.inv38-138 { background: #af8787; }.ansi48-138 { background: #af8787; }.inv48-138 { color: #af8787; }.ansi38-139 { color: #af87af; }.inv38-139 { background: #af87af; }.ansi48-139 { background: #af87af; }.inv48-139 { color: #af87af; }.ansi38-140 { color: #af87d7; }.inv38-140 { background: #af87d7; }.ansi48-140 { background: #af87d7; }.inv48-140 { color: #af87d7; }.ansi38-141 { color: #af87ff; }.inv38-141 { background: #af87ff; }.ansi48-141 { background: #af87ff; }.inv48-141 { color: #af87ff; }.ansi38-172 { color: #d78700; }.inv38-172 { background: #d78700; }.ansi48-172 { background: #d78700; }.inv48-172 { color: #d78700; }.ansi38-173 { color: #d7875f; }.inv38-173 { background: #d7875f; }.ansi48-173 { background: #d7875f; }.inv48-173 { color: #d7875f; }.ansi38-174 { color: #d78787; }.inv38-174 { background: #d78787; }.ansi48-174 { background: #d78787; }.inv48-174 { color: #d78787; }.ansi38-175 { color: #d787af; }.inv38-175 { background: #d787af; }.ansi48-175 { background: #d787af; }.inv48-175 { color: #d787af; }.ansi38-176 { color: #d787d7; }.inv38-176 { background: #d787d7; }.ansi48-176 { background: #d787d7; }.inv48-176 { color: #d787d7; }.ansi38-177 { color: #d787ff; }.inv38-177 { background: #d787ff; }.ansi48-177 { background: #d787ff; }.inv48-177 { color: #d787ff; }.ansi38-208 { color: #ff8700; }.inv38-208 { background: #ff8700; }.ansi48-208 { background: #ff8700; }.inv48-208 { color: #ff8700; }.ansi38-209 { color: #ff875f; }.inv38-209 { background: #ff875f; }.ansi48-209 { background: #ff875f; }.inv48-209 { color: #ff875f; }.ansi38-210 { color: #ff8787; }.inv38-210 { background: #ff8787; }.ansi48-210 { background: #ff8787; }.inv48-210 { color: #ff8787; }.ansi38-211 { color: #ff87af; }.inv38-211 { background: #ff87af; }.ansi48-211 { background: #ff87af; }.inv48-211 { color: #ff87af; }.ansi38-212 { color: #ff87d7; }.inv38-212 { background: #ff87d7; }.ansi48-212 { background: #ff87d7; }.inv48-212 { color: #ff87d7; }.ansi38-213 { color: #ff87ff; }.inv38-213 { background: #ff87ff; }.ansi48-213 { background: #ff87ff; }.inv48-213 { color: #ff87ff; }.ansi38-34 { color: #00af00; }.inv38-34 { background: #00af00; }.ansi48-34 { background: #00af00; }.inv48-34 { color: #00af00; }.ansi38-35 { color: #00af5f; }.inv38-35 { background: #00af5f; }.ansi48-35 { background: #00af5f; }.inv48-35 { color: #00af5f; }.ansi38-36 { color: #00af87; }.inv38-36 { background: #00af87; }.ansi48-36 { background: #00af87; }.inv48-36 { color: #00af87; }.ansi38-37 { color: #00afaf; }.inv38-37 { background: #00afaf; }.ansi48-37 { background: #00afaf; }.inv48-37 { color: #00afaf; }.ansi38-38 { color: #00afd7; }.inv38-38 { background: #00afd7; }.ansi48-38 { background: #00afd7; }.inv48-38 { color: #00afd7; }.ansi38-39 { color: #00afff; }.inv38-39 { background: #00afff; }.ansi48-39 { background: #00afff; }.inv48-39 { color: #00afff; }.ansi38-70 { color: #5faf00; }.inv38-70 { background: #5faf00; }.ansi48-70 { background: #5faf00; }.inv48-70 { color: #5faf00; }.ansi38-71 { color: #5faf5f; }.inv38-71 { background: #5faf5f; }.ansi48-71 { background: #5faf5f; }.inv48-71 { color: #5faf5f; }.ansi38-72 { color: #5faf87; }.inv38-72 { background: #5faf87; }.ansi48-72 { background: #5faf87; }.inv48-72 { color: #5faf87; }.ansi38-73 { color: #5fafaf; }.inv38-73 { background: #5fafaf; }.ansi48-73 { background: #5fafaf; }.inv48-73 { color: #5fafaf; }.ansi38-74 { color: #5fafd7; }.inv38-74 { background: #5fafd7; }.ansi48-74 { background: #5fafd7; }.inv48-74 { color: #5fafd7; }.ansi38-75 { color: #5fafff; }.inv38-75 { background: #5fafff; }.ansi48-75 { background: #5fafff; }.inv48-75 { color: #5fafff; }.ansi38-106 { color: #87af00; }.inv38-106 { background: #87af00; }.ansi48-106 { background: #87af00; }.inv48-106 { color: #87af00; }.ansi38-107 { color: #87af5f; }.inv38-107 { background: #87af5f; }.ansi48-107 { background: #87af5f; }.inv48-107 { color: #87af5f; }.ansi38-108 { color: #87af87; }.inv38-108 { background: #87af87; }.ansi48-108 { background: #87af87; }.inv48-108 { color: #87af87; }.ansi38-109 { color: #87afaf; }.inv38-109 { background: #87afaf; }.ansi48-109 { background: #87afaf; }.inv48-109 { color: #87afaf; }.ansi38-110 { color: #87afd7; }.inv38-110 { background: #87afd7; }.ansi48-110 { background: #87afd7; }.inv48-110 { color: #87afd7; }.ansi38-111 { color: #87afff; }.inv38-111 { background: #87afff; }.ansi48-111 { background: #87afff; }.inv48-111 { color: #87afff; }.ansi38-142 { color: #afaf00; }.inv38-142 { background: #afaf00; }.ansi48-142 { background: #afaf00; }.inv48-142 { color: #afaf00; }.ansi38-143 { color: #afaf5f; }.inv38-143 { background: #afaf5f; }.ansi48-143 { background: #afaf5f; }.inv48-143 { color: #afaf5f; }.ansi38-144 { color: #afaf87; }.inv38-144 { background: #afaf87; }.ansi48-144 { background: #afaf87; }.inv48-144 { color: #afaf87; }.ansi38-145 { color: #afafaf; }.inv38-145 { background: #afafaf; }.ansi48-145 { background: #afafaf; }.inv48-145 { color: #afafaf; }.ansi38-146 { color: #afafd7; }.inv38-146 { background: #afafd7; }.ansi48-146 { background: #afafd7; }.inv48-146 { color: #afafd7; }.ansi38-147 { color: #afafff; }.inv38-147 { background: #afafff; }.ansi48-147 { background: #afafff; }.inv48-147 { color: #afafff; }.ansi38-178 { color: #d7af00; }.inv38-178 { background: #d7af00; }.ansi48-178 { background: #d7af00; }.inv48-178 { color: #d7af00; }.ansi38-179 { color: #d7af5f; }.inv38-179 { background: #d7af5f; }.ansi48-179 { background: #d7af5f; }.inv48-179 { color: #d7af5f; }.ansi38-180 { color: #d7af87; }.inv38-180 { background: #d7af87; }.ansi48-180 { background: #d7af87; }.inv48-180 { color: #d7af87; }.ansi38-181 { color: #d7afaf; }.inv38-181 { background: #d7afaf; }.ansi48-181 { background: #d7afaf; }.inv48-181 { color: #d7afaf; }.ansi38-182 { color: #d7afd7; }.inv38-182 { background: #d7afd7; }.ansi48-182 { background: #d7afd7; }.inv48-182 { color: #d7afd7; }.ansi38-183 { color: #d7afff; }.inv38-183 { background: #d7afff; }.ansi48-183 { background: #d7afff; }.inv48-183 { color: #d7afff; }.ansi38-214 { color: #ffaf00; }.inv38-214 { background: #ffaf00; }.ansi48-214 { background: #ffaf00; }.inv48-214 { color: #ffaf00; }.ansi38-215 { color: #ffaf5f; }.inv38-215 { background: #ffaf5f; }.ansi48-215 { background: #ffaf5f; }.inv48-215 { color: #ffaf5f; }.ansi38-216 { color: #ffaf87; }.inv38-216 { background: #ffaf87; }.ansi48-216 { background: #ffaf87; }.inv48-216 { color: #ffaf87; }.ansi38-217 { color: #ffafaf; }.inv38-217 { background: #ffafaf; }.ansi48-217 { background: #ffafaf; }.inv48-217 { color: #ffafaf; }.ansi38-218 { color: #ffafd7; }.inv38-218 { background: #ffafd7; }.ansi48-218 { background: #ffafd7; }.inv48-218 { color: #ffafd7; }.ansi38-219 { color: #ffafff; }.inv38-219 { background: #ffafff; }.ansi48-219 { background: #ffafff; }.inv48-219 { color: #ffafff; }.ansi38-40 { color: #00d700; }.inv38-40 { background: #00d700; }.ansi48-40 { background: #00d700; }.inv48-40 { color: #00d700; }.ansi38-41 { color: #00d75f; }.inv38-41 { background: #00d75f; }.ansi48-41 { background: #00d75f; }.inv48-41 { color: #00d75f; }.ansi38-42 { color: #00d787; }.inv38-42 { background: #00d787; }.ansi48-42 { background: #00d787; }.inv48-42 { color: #00d787; }.ansi38-43 { color: #00d7af; }.inv38-43 { background: #00d7af; }.ansi48-43 { background: #00d7af; }.inv48-43 { color: #00d7af; }.ansi38-44 { color: #00d7d7; }.inv38-44 { background: #00d7d7; }.ansi48-44 { background: #00d7d7; }.inv48-44 { color: #00d7d7; }.ansi38-45 { color: #00d7ff; }.inv38-45 { background: #00d7ff; }.ansi48-45 { background: #00d7ff; }.inv48-45 { color: #00d7ff; }.ansi38-76 { color: #5fd700; }.inv38-76 { background: #5fd700; }.ansi48-76 { background: #5fd700; }.inv48-76 { color: #5fd700; }.ansi38-77 { color: #5fd75f; }.inv38-77 { background: #5fd75f; }.ansi48-77 { background: #5fd75f; }.inv48-77 { color: #5fd75f; }.ansi38-78 { color: #5fd787; }.inv38-78 { background: #5fd787; }.ansi48-78 { background: #5fd787; }.inv48-78 { color: #5fd787; }.ansi38-79 { color: #5fd7af; }.inv38-79 { background: #5fd7af; }.ansi48-79 { background: #5fd7af; }.inv48-79 { color: #5fd7af; }.ansi38-80 { color: #5fd7d7; }.inv38-80 { background: #5fd7d7; }.ansi48-80 { background: #5fd7d7; }.inv48-80 { color: #5fd7d7; }.ansi38-81 { color: #5fd7ff; }.inv38-81 { background: #5fd7ff; }.ansi48-81 { background: #5fd7ff; }.inv48-81 { color: #5fd7ff; }.ansi38-112 { color: #87d700; }.inv38-112 { background: #87d700; }.ansi48-112 { background: #87d700; }.inv48-112 { color: #87d700; }.ansi38-113 { color: #87d75f; }.inv38-113 { background: #87d75f; }.ansi48-113 { background: #87d75f; }.inv48-113 { color: #87d75f; }.ansi38-114 { color: #87d787; }.inv38-114 { background: #87d787; }.ansi48-114 { background: #87d787; }.inv48-114 { color: #87d787; }.ansi38-115 { color: #87d7af; }.inv38-115 { background: #87d7af; }.ansi48-115 { background: #87d7af; }.inv48-115 { color: #87d7af; }.ansi38-116 { color: #87d7d7; }.inv38-116 { background: #87d7d7; }.ansi48-116 { background: #87d7d7; }.inv48-116 { color: #87d7d7; }.ansi38-117 { color: #87d7ff; }.inv38-117 { background: #87d7ff; }.ansi48-117 { background: #87d7ff; }.inv48-117 { color: #87d7ff; }.ansi38-148 { color: #afd700; }.inv38-148 { background: #afd700; }.ansi48-148 { background: #afd700; }.inv48-148 { color: #afd700; }.ansi38-149 { color: #afd75f; }.inv38-149 { background: #afd75f; }.ansi48-149 { background: #afd75f; }.inv48-149 { color: #afd75f; }.ansi38-150 { color: #afd787; }.inv38-150 { background: #afd787; }.ansi48-150 { background: #afd787; }.inv48-150 { color: #afd787; }.ansi38-151 { color: #afd7af; }.inv38-151 { background: #afd7af; }.ansi48-151 { background: #afd7af; }.inv48-151 { color: #afd7af; }.ansi38-152 { color: #afd7d7; }.inv38-152 { background: #afd7d7; }.ansi48-152 { background: #afd7d7; }.inv48-152 { color: #afd7d7; }.ansi38-153 { color: #afd7ff; }.inv38-153 { background: #afd7ff; }.ansi48-153 { background: #afd7ff; }.inv48-153 { color: #afd7ff; }.ansi38-184 { color: #d7d700; }.inv38-184 { background: #d7d700; }.ansi48-184 { background: #d7d700; }.inv48-184 { color: #d7d700; }.ansi38-185 { color: #d7d75f; }.inv38-185 { background: #d7d75f; }.ansi48-185 { background: #d7d75f; }.inv48-185 { color: #d7d75f; }.ansi38-186 { color: #d7d787; }.inv38-186 { background: #d7d787; }.ansi48-186 { background: #d7d787; }.inv48-186 { color: #d7d787; }.ansi38-187 { color: #d7d7af; }.inv38-187 { background: #d7d7af; }.ansi48-187 { background: #d7d7af; }.inv48-187 { color: #d7d7af; }.ansi38-188 { color: #d7d7d7; }.inv38-188 { background: #d7d7d7; }.ansi48-188 { background: #d7d7d7; }.inv48-188 { color: #d7d7d7; }.ansi38-189 { color: #d7d7ff; }.inv38-189 { background: #d7d7ff; }.ansi48-189 { background: #d7d7ff; }.inv48-189 { color: #d7d7ff; }.ansi38-220 { color: #ffd700; }.inv38-220 { background: #ffd700; }.ansi48-220 { background: #ffd700; }.inv48-220 { color: #ffd700; }.ansi38-221 { color: #ffd75f; }.inv38-221 { background: #ffd75f; }.ansi48-221 { background: #ffd75f; }.inv48-221 { color: #ffd75f; }.ansi38-222 { color: #ffd787; }.inv38-222 { background: #ffd787; }.ansi48-222 { background: #ffd787; }.inv48-222 { color: #ffd787; }.ansi38-223 { color: #ffd7af; }.inv38-223 { background: #ffd7af; }.ansi48-223 { background: #ffd7af; }.inv48-223 { color: #ffd7af; }.ansi38-224 { color: #ffd7d7; }.inv38-224 { background: #ffd7d7; }.ansi48-224 { background: #ffd7d7; }.inv48-224 { color: #ffd7d7; }.ansi38-225 { color: #ffd7ff; }.inv38-225 { background: #ffd7ff; }.ansi48-225 { background: #ffd7ff; }.inv48-225 { color: #ffd7ff; }.ansi38-46 { color: #00ff00; }.inv38-46 { background: #00ff00; }.ansi48-46 { background: #00ff00; }.inv48-46 { color: #00ff00; }.ansi38-47 { color: #00ff5f; }.inv38-47 { background: #00ff5f; }.ansi48-47 { background: #00ff5f; }.inv48-47 { color: #00ff5f; }.ansi38-48 { color: #00ff87; }.inv38-48 { background: #00ff87; }.ansi48-48 { background: #00ff87; }.inv48-48 { color: #00ff87; }.ansi38-49 { color: #00ffaf; }.inv38-49 { background: #00ffaf; }.ansi48-49 { background: #00ffaf; }.inv48-49 { color: #00ffaf; }.ansi38-50 { color: #00ffd7; }.inv38-50 { background: #00ffd7; }.ansi48-50 { background: #00ffd7; }.inv48-50 { color: #00ffd7; }.ansi38-51 { color: #00ffff; }.inv38-51 { background: #00ffff; }.ansi48-51 { background: #00ffff; }.inv48-51 { color: #00ffff; }.ansi38-82 { color: #5fff00; }.inv38-82 { background: #5fff00; }.ansi48-82 { background: #5fff00; }.inv48-82 { color: #5fff00; }.ansi38-83 { color: #5fff5f; }.inv38-83 { background: #5fff5f; }.ansi48-83 { background: #5fff5f; }.inv48-83 { color: #5fff5f; }.ansi38-84 { color: #5fff87; }.inv38-84 { background: #5fff87; }.ansi48-84 { background: #5fff87; }.inv48-84 { color: #5fff87; }.ansi38-85 { color: #5fffaf; }.inv38-85 { background: #5fffaf; }.ansi48-85 { background: #5fffaf; }.inv48-85 { color: #5fffaf; }.ansi38-86 { color: #5fffd7; }.inv38-86 { background: #5fffd7; }.ansi48-86 { background: #5fffd7; }.inv48-86 { color: #5fffd7; }.ansi38-87 { color: #5fffff; }.inv38-87 { background: #5fffff; }.ansi48-87 { background: #5fffff; }.inv48-87 { color: #5fffff; }.ansi38-118 { color: #87ff00; }.inv38-118 { background: #87ff00; }.ansi48-118 { background: #87ff00; }.inv48-118 { color: #87ff00; }.ansi38-119 { color: #87ff5f; }.inv38-119 { background: #87ff5f; }.ansi48-119 { background: #87ff5f; }.inv48-119 { color: #87ff5f; }.ansi38-120 { color: #87ff87; }.inv38-120 { background: #87ff87; }.ansi48-120 { background: #87ff87; }.inv48-120 { color: #87ff87; }.ansi38-121 { color: #87ffaf; }.inv38-121 { background: #87ffaf; }.ansi48-121 { background: #87ffaf; }.inv48-121 { color: #87ffaf; }.ansi38-122 { color: #87ffd7; }.inv38-122 { background: #87ffd7; }.ansi48-122 { background: #87ffd7; }.inv48-122 { color: #87ffd7; }.ansi38-123 { color: #87ffff; }.inv38-123 { background: #87ffff; }.ansi48-123 { background: #87ffff; }.inv48-123 { color: #87ffff; }.ansi38-154 { color: #afff00; }.inv38-154 { background: #afff00; }.ansi48-154 { background: #afff00; }.inv48-154 { color: #afff00; }.ansi38-155 { color: #afff5f; }.inv38-155 { background: #afff5f; }.ansi48-155 { background: #afff5f; }.inv48-155 { color: #afff5f; }.ansi38-156 { color: #afff87; }.inv38-156 { background: #afff87; }.ansi48-156 { background: #afff87; }.inv48-156 { color: #afff87; }.ansi38-157 { color: #afffaf; }.inv38-157 { background: #afffaf; }.ansi48-157 { background: #afffaf; }.inv48-157 { color: #afffaf; }.ansi38-158 { color: #afffd7; }.inv38-158 { background: #afffd7; }.ansi48-158 { background: #afffd7; }.inv48-158 { color: #afffd7; }.ansi38-159 { color: #afffff; }.inv38-159 { background: #afffff; }.ansi48-159 { background: #afffff; }.inv48-159 { color: #afffff; }.ansi38-190 { color: #d7ff00; }.inv38-190 { background: #d7ff00; }.ansi48-190 { background: #d7ff00; }.inv48-190 { color: #d7ff00; }.ansi38-191 { color: #d7ff5f; }.inv38-191 { background: #d7ff5f; }.ansi48-191 { background: #d7ff5f; }.inv48-191 { color: #d7ff5f; }.ansi38-192 { color: #d7ff87; }.inv38-192 { background: #d7ff87; }.ansi48-192 { background: #d7ff87; }.inv48-192 { color: #d7ff87; }.ansi38-193 { color: #d7ffaf; }.inv38-193 { background: #d7ffaf; }.ansi48-193 { background: #d7ffaf; }.inv48-193 { color: #d7ffaf; }.ansi38-194 { color: #d7ffd7; }.inv38-194 { background: #d7ffd7; }.ansi48-194 { background: #d7ffd7; }.inv48-194 { color: #d7ffd7; }.ansi38-195 { color: #d7ffff; }.inv38-195 { background: #d7ffff; }.ansi48-195 { background: #d7ffff; }.inv48-195 { color: #d7ffff; }.ansi38-226 { color: #ffff00; }.inv38-226 { background: #ffff00; }.ansi48-226 { background: #ffff00; }.inv48-226 { color: #ffff00; }.ansi38-227 { color: #ffff5f; }.inv38-227 { background: #ffff5f; }.ansi48-227 { background: #ffff5f; }.inv48-227 { color: #ffff5f; }.ansi38-228 { color: #ffff87; }.inv38-228 { background: #ffff87; }.ansi48-228 { background: #ffff87; }.inv48-228 { color: #ffff87; }.ansi38-229 { color: #ffffaf; }.inv38-229 { background: #ffffaf; }.ansi48-229 { background: #ffffaf; }.inv48-229 { color: #ffffaf; }.ansi38-230 { color: #ffffd7; }.inv38-230 { background: #ffffd7; }.ansi48-230 { background: #ffffd7; }.inv48-230 { color: #ffffd7; }.ansi38-231 { color: #ffffff; }.inv38-231 { background: #ffffff; }.ansi48-231 { background: #ffffff; }.inv48-231 { color: #ffffff; }.ansi38-232 { color: #080808; }.inv38-232 { background: #080808; }.ansi48-232 { background: #080808; }.inv48-232 { color: #080808; }.ansi38-233 { color: #121212; }.inv38-233 { background: #121212; }.ansi48-233 { background: #121212; }.inv48-233 { color: #121212; }.ansi38-234 { color: #1c1c1c; }.inv38-234 { background: #1c1c1c; }.ansi48-234 { background: #1c1c1c; }.inv48-234 { color: #1c1c1c; }.ansi38-235 { color: #262626; }.inv38-235 { background: #262626; }.ansi48-235 { background: #262626; }.inv48-235 { color: #262626; }.ansi38-236 { color: #303030; }.inv38-236 { background: #303030; }.ansi48-236 { background: #303030; }.inv48-236 { color: #303030; }.ansi38-237 { color: #3a3a3a; }.inv38-237 { background: #3a3a3a; }.ansi48-237 { background: #3a3a3a; }.inv48-237 { color: #3a3a3a; }.ansi38-238 { color: #444444; }.inv38-238 { background: #444444; }.ansi48-238 { background: #444444; }.inv48-238 { color: #444444; }.ansi38-239 { color: #4e4e4e; }.inv38-239 { background: #4e4e4e; }.ansi48-239 { background: #4e4e4e; }.inv48-239 { color: #4e4e4e; }.ansi38-240 { color: #585858; }.inv38-240 { background: #585858; }.ansi48-240 { background: #585858; }.inv48-240 { color: #585858; }.ansi38-241 { color: #626262; }.inv38-241 { background: #626262; }.ansi48-241 { background: #626262; }.inv48-241 { color: #626262; }.ansi38-242 { color: #6c6c6c; }.inv38-242 { background: #6c6c6c; }.ansi48-242 { background: #6c6c6c; }.inv48-242 { color: #6c6c6c; }.ansi38-243 { color: #767676; }.inv38-243 { background: #767676; }.ansi48-243 { background: #767676; }.inv48-243 { color: #767676; }.ansi38-244 { color: #808080; }.inv38-244 { background: #808080; }.ansi48-244 { background: #808080; }.inv48-244 { color: #808080; }.ansi38-245 { color: #8a8a8a; }.inv38-245 { background: #8a8a8a; }.ansi48-245 { background: #8a8a8a; }.inv48-245 { color: #8a8a8a; }.ansi38-246 { color: #949494; }.inv38-246 { background: #949494; }.ansi48-246 { background: #949494; }.inv48-246 { color: #949494; }.ansi38-247 { color: #9e9e9e; }.inv38-247 { background: #9e9e9e; }.ansi48-247 { background: #9e9e9e; }.inv48-247 { color: #9e9e9e; }.ansi38-248 { color: #a8a8a8; }.inv38-248 { background: #a8a8a8; }.ansi48-248 { background: #a8a8a8; }.inv48-248 { color: #a8a8a8; }.ansi38-249 { color: #b2b2b2; }.inv38-249 { background: #b2b2b2; }.ansi48-249 { background: #b2b2b2; }.inv48-249 { color: #b2b2b2; }.ansi38-250 { color: #bcbcbc; }.inv38-250 { background: #bcbcbc; }.ansi48-250 { background: #bcbcbc; }.inv48-250 { color: #bcbcbc; }.ansi38-251 { color: #c6c6c6; }.inv38-251 { background: #c6c6c6; }.ansi48-251 { background: #c6c6c6; }.inv48-251 { color: #c6c6c6; }.ansi38-252 { color: #d0d0d0; }.inv38-252 { background: #d0d0d0; }.ansi48-252 { background: #d0d0d0; }.inv48-252 { color: #d0d0d0; }.ansi38-253 { color: #dadada; }.inv38-253 { background: #dadada; }.ansi48-253 { background: #dadada; }.inv48-253 { color: #dadada; }.ansi38-254 { color: #e4e4e4; }.inv38-254 { background: #e4e4e4; }.ansi48-254 { background: #e4e4e4; }.inv48-254 { color: #e4e4e4; }.ansi38-255 { color: #eeeeee; }.inv38-255 { background: #eeeeee; }.ansi48-255 { background: #eeeeee; }.inv48-255 { color: #eeeeee; }  html { font-family: Arial, Helvetica, sans-serif; font-size: 16px; } @media only screen and (max-width: 768px) { html { font-size: 14px; } } body { padding: 0; } @media only screen { body { background-color: #f3f3f3; color: #222222; } } section { padding: 0.75rem 0; } h1 { display: none; } pre { overflow-x: auto; background-color: #f3f3f3; font-size: 87.5%; padding: 0.75rem; margin: 0.75rem 0; border: 1px solid #c7c7c7; border-radius: 4px; } samp { white-space: pre-wrap; word-wrap: break-word; } @media only screen and (max-width: 768px) { samp { white-space: normal; word-wrap: normal; } } a { text-decoration: none; } a:hover { text-decoration: underline; } @media only screen { .container { margin: 0 2%; } } .badge { font-size: 85%; text-align: center; display: inline-block; padding: 0.2em 0.5em; border-radius: 4px; border: 1px solid black; } @media only screen { .box { background-color: white; border-radius: 4px; box-shadow: 0 1px 2px #afafaf; } .badge { background-color: #78909C; color: white; border: 0; } .status.passed { background-color: #43A047; color: #FFFFFF; } .status.failed { background-color: #F44336; color: #FFFFFF; } .status.error { background-color: #B71C1C; color: #FFFFFF; } .status.xfailed { background-color: #EF9A9A; color: #222222; } .status.xpassed { background-color: #A5D6A7; color: #222222; } .status.skipped { background-color: #9E9E9E; color: #FFFFFF; } .status.notrun { background-color: #9E9E9E; color: #FFFFFF; } .status.rerun { background-color: #FBC02D; color: #222222; } .status.warning { background-color: #FBC02D; color: #222222; } .status.green { background-color: #43A047; color: #FFFFFF; } .status.red { background-color: #E53935; color: #FFFFFF; } .status.yellow { background-color: #FBC02D; color: #222222; } } details > summary { display: block; cursor: pointer; list-style: none; border-radius: 4px; } details > summary:focus { outline: 0; } details > summary::-webkit-details-marker { display: none; } details > summary > ::before { content: " "; background-image: url("data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIj4KICA8cGF0aCBkPSJNIDMwLDEwIGwgNDAsNDAgbCAtNDAsNDAiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLXdpZHRoPSIyMCIgc3Ryb2tlPSIjOTk5IiBmaWxsPSJub25lIiAvPgo8L3N2Zz4K"); background-size: contain; background-repeat: no-repeat; background-position-x: center; width: 0.75rem; height: 0.75rem; display: inline-block; justify-self: end;  transition: transform ease-out 0.2s; } details[open] > summary > .title::before { transform: rotate(90deg); } .title { font-size: 1rem; margin: 0; padding: 0; } .duration { display: none; font-size: 0.875em; font-weight: normal; color: #888888; }  header { background-color: #455A64; color: white; padding: 1rem 0; } .report-title { font-weight: bold; font-size: 2rem; }  @media only screen and (min-width: 1024px) { #summary > .container { display: grid; grid-template-columns: auto minmax(15rem, 23rem); grid-gap: 1rem; align-items: start;  } } .metadata th, .metadata td { padding: 0.2rem; vertical-align: top; text-align: left; } .metadata th { font-weight: bold; padding-right: 0.75rem; } .metadata td { word-break: break-all; } .graph { display: grid; grid-template-columns: minmax(100px, 250px) auto; grid-gap: 0.75rem; align-items: center; justify-content: center; } .graph svg { width: 100%; height: auto; } .graph svg text { font-size: 10px; fill: #444444; } .legend { display: grid; grid-template-columns: auto 1fr; grid-gap: 0.3rem; align-items: center; }  #warnings > .container { display: grid; grid-template-columns: auto 1fr; grid-gap: 0.75rem; align-items: start; }  .file-title { display: grid; grid-template-columns: auto auto 1fr auto; grid-gap: 0.75rem; align-items: center; } .file > summary { padding: 0.4rem 0.5rem; } .file > summary:hover { background-color: rgba(200, 200, 200, 0.2); } .file > .content { margin-bottom: 0.75rem; } @media only print { .file > .title { border-bottom: 1px solid gray; } } .fspath { margin: 0; font-size: 1.125em; word-break: break-all; } .counts { white-space: nowrap; } .counts > span { display: inline-block; margin-right: 5px; }  .test > summary { position: sticky; top: 0; z-index: 100000;  padding: 0.5rem; padding-left: 0.75rem; background-color: #ffffff; } .test > summary:hover { background-color: #f6f6f6; } .test:not(:last-child) { border-bottom: 1px solid #e9e9e9; } .test > .content { padding: 0.75rem; } .status { font-weight: bold; } .test-title { display: grid; grid-template-columns: auto 5em 1fr auto; grid-gap: 0.75rem; align-items: center;  } @media only screen and (min-width: 500px) { .duration { display: inline-block; } } .test-name { font-size: 1em; margin: 0; word-break: break-all; } .test-name > .params { font-weight: normal; } .documentation p { margin-top: 0; margin-bottom: 1em; } .marker { display: inline-block; color: #5e5e5e; margin: 0 0.2rem 0.2rem 0; } .fixturename { margin: 0 0.2rem 0.2rem 0; } td > pre { margin: 0; } .extra img, .extra video { max-height: 300px; } .extra pre { white-space: pre-wrap; max-height: 300px; overflow-y: auto; }  .test-phases { border-left: 2px solid #dddddd; margin-left: 0.75rem; } .phase { position: relative; padding-left: 0.9rem; margin-bottom: 0; border-radius: 0; } .phase > summary { padding: 0.4rem;  } .phase > summary:hover { background-color: #f6f6f6; } .phase .status { position: absolute; display: inline-block; left: -1px; margin-top: -0.4rem; padding: 0; transform: translateX(-50%); width: 1.5rem; height: 1.5rem; text-align: center; border-radius: 500%; border: 3px solid white; background-size: 50%; background-repeat: no-repeat; background-position: center; } .phase .status.passed, .phase .status.xfailed { background-image: url("data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIj4KICA8cGF0aCBkPSJNIDEwLDUwIGwgMjUsMjUgbCA1NSwtNTUiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLXdpZHRoPSIyMCIgc3Ryb2tlPSIjZmZmIiBmaWxsPSJub25lIiAvPgo8L3N2Zz4K"); } .phase .status.failed, .phase .status.error, .phase .status.xpassed, .phase .status.skipped, .phase .status.rerun { background-image: url("data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIj4KICA8cGF0aCBkPSJNIDEwLDEwIEwgOTAsOTAiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLXdpZHRoPSIyMCIgc3Ryb2tlPSIjZmZmIiBmaWxsPSJub25lIiAvPgogIDxwYXRoIGQ9Ik0gMTAsOTAgTCA5MCwxMCIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2Utd2lkdGg9IjIwIiBzdHJva2U9IiNmZmYiIGZpbGw9Im5vbmUiIC8+Cjwvc3ZnPgo="); } .phase .status.skipped { background-image: url("data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIj4KICA8cGF0aCBkPSJNIDEwLDUwIEwgOTAsNTAiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLXdpZHRoPSIyMCIgc3Ryb2tlPSIjZmZmIiBmaWxsPSJub25lIiAvPgo8L3N2Zz4K"); } .phase-name {  display: inline-block; font-size: 1em; margin: 0; } .section-title { font-size: 1em; font-weight: normal; margin: 1em 0 0 0; padding: 0; }  footer { margin-bottom: 1rem; font-size: 0.875rem; font-style: italic; color: #999999; text-align: right; } 
  </style><script>
    
    
  </script></head> <body> <header> <div class=container> <span class=report-title>Test Report</span> </div> </header> <main> <section id=summary> <div class=container> <h1>Summary</h1> <div class=metadata> <table> <tr> <th>Started</th> <td>2023-06-30 01:14:20</td> </tr> <tr> <th>Ended</th> <td> 2023-06-30 01:14:59 </td> </tr> <tr> <th>Duration</th> <td>0:00:39.621536</td> </tr> <tr> <th>Total run time</th> <td>0:00:36.649417</td> </tr> <tr> <th>LIVE_TEST_BASE_URL</th> <td> <a href=https://data-converter-qal.kosc.net rel=noopener>https://data-converter-qal.kosc.net</a> </td> </tr> <tr> <th>LIVE_TEST_X3_BASE_URL</th> <td> <a href=https://sagex3-horsprod.covage.com/api1 rel=noopener>https://sagex3-horsprod.covage.com/api1</a> </td> </tr> <tr> <th>LIVE_TEST_X3_USERNAME</th> <td> intraco </td> </tr> <tr> <th>LIVE_TEST_X3_FOLDER</th> <td> QAL </td> </tr> <tr> <th>LIVE_TEST_X3_POOL_ALIAS</th> <td> QAL </td> </tr> <tr> <th>CI_COMMIT_REF_NAME</th> <td> develop </td> </tr> <tr> <th>CI_COMMIT_REF_SLUG</th> <td> develop </td> </tr> <tr> <th>CI_COMMIT_SHA</th> <td> 039822f513e94f5569b4d8d3bdba9b83e10e8bfb </td> </tr> <tr> <th>CI_JOB_ID</th> <td> 451224 </td> </tr> </table> </div> <div class=graph> <svg width=200 height=200 viewbox="0 0 42 42"> <circle class="donut-segment passed" stroke-dasharray="77.1524586486166 23.378506266256778" stroke-dashoffset=125.46370614359172 cx=21 cy=21 r=16 fill=transparent stroke=#43A047 stroke-width=4> </circle> <circle class="donut-segment xfailed" stroke-dasharray="20.4242713037952 80.10669361107819" stroke-dashoffset=47.911247494975115 cx=21 cy=21 r=16 fill=transparent stroke=#EF9A9A stroke-width=4> </circle> <circle class="donut-segment xpassed" stroke-dasharray="1.7542349624615725 98.77672995241181" stroke-dashoffset=27.086976191179918 cx=21 cy=21 r=16 fill=transparent stroke=#A5D6A7 stroke-width=4> </circle> <text x=21 y=24 text-anchor=middle>140</text> </svg> <div class=legend> <span class="status badge passed "> 108 </span> <span>passed</span> <span class="status badge xfailed "> 29 </span> <span>xfailed</span> <span class="status badge xpassed "> 3 </span> <span>xpassed</span> </div> </div> </div> </section> <section id=test-files> <div class=container> <h1>Tests</h1> <details class=file> <summary> <h2 class="title file-title"> <span class=fspath> app/api/live_tests/test_auth.py </span> <span class=counts> <span title="3 xpassed" class="count status badge xpassed ">3</span> </span> <span class=duration> 0:00:00.601293 </span> </h2> </summary> <div class="content box"> <details class="test xpassed"> <summary> <h3 class="title test-title"> <span class="status badge xpassed ">XPASS</span> <span class=test-name> <span class=funcname>test_auth_without_token</span> </span> <span class=duration>0:00:00.139204</span> </h3> </summary> <div class=content> <div class=documentation> <p>Test api route without Authorization header, should return</p> <p>{ &quot;detail&quot;: &quot;Informations d'authentification non fournies.&quot;, &quot;status_code&quot;: 401 }</p> </div> <table class=metadata> <tr> <th>Started</th> <td>2023-06-30 01:14:33</td> </tr> <tr> <th>Ended</th> <td>2023-06-30 01:14:33</td> </tr> <tr> <th>Duration</th> <td>0:00:00.139204</td> </tr> <tr> <th>Markers</th> <td> <div class=marker> <span class="marker-name badge">xfail</span> <span class=marker-args> </span> </div> <div class=marker> <span class="marker-name badge">read_data</span> <span class=marker-args> </span> </div> <div class=marker> <span class="marker-name badge">livetest</span> <span class=marker-args> </span> </div> </td> </tr> <tr> <th>Fixtures</th> <td> <span class="badge fixturename"> django_test_environment </span> <span class="badge fixturename"> django_db_blocker </span> <span class="badge fixturename"> test_client </span> <span class="badge fixturename"> request </span> </td> </tr> </table> <div class=test-phases> <details class="phase setup "> <summary> <h4 class=title> <span class=phase-name>Setup</span> </h4> </summary> <div class=content> </div> </details> <details class="phase call xpassed" open> <summary> <h4 class=title> <span class="status  xpassed"></span> <span class=phase-name>Call</span> </h4> </summary> <div class=content> </div> </details> <details class="phase teardown "> <summary> <h4 class=title> <span class=phase-name>Teardown</span> </h4> </summary> <div class=content> </div> </details> </div> </div> </details> <details class="test xpassed"> <summary> <h3 class="title test-title"> <span class="status badge xpassed ">XPASS</span> <span class=test-name> <span class=funcname>test_auth_with_bad_token</span> </span> <span class=duration>0:00:00.405808</span> </h3> </summary> <div class=content> <div class=documentation> <p>Test api route <cite>/api/v0/customers/</cite> with DUMMY token, should return</p> <p>{ &quot;detail&quot;: &quot;Token non valide.&quot;, &quot;status_code&quot;: 401 }</p> </div> <table class=metadata> <tr> <th>Started</th> <td>2023-06-30 01:14:33</td> </tr> <tr> <th>Ended</th> <td>2023-06-30 01:14:33</td> </tr> <tr> <th>Duration</th> <td>0:00:00.405808</td> </tr> <tr> <th>Markers</th> <td> <div class=marker> <span class="marker-name badge">read_data</span> <span class=marker-args> </span> </div> <div class=marker> <span class="marker-name badge">xfail</span> <span class=marker-args> </span> </div> <div class=marker> <span class="marker-name badge">livetest</span> <span class=marker-args> </span> </div> </td> </tr> <tr> <th>Fixtures</th> <td> <span class="badge fixturename"> django_test_environment </span> <span class="badge fixturename"> django_db_blocker </span> <span class="badge fixturename"> test_client </span> <span class="badge fixturename"> request </span> </td> </tr> </table> <div class=test-phases> <details class="phase setup "> <summary> <h4 class=title> <span class=phase-name>Setup</span> </h4> </summary> <div class=content> </div> </details> <details class="phase call xpassed" open> <summary> <h4 class=title> <span class="status  xpassed"></span> <span class=phase-name>Call</span> </h4> </summary> <div class=content> </div> </details> <details class="phase teardown "> <summary> <h4 class=title> <span class=phase-name>Teardown</span> </h4> </summary> <div class=content> </div> </details> </div> </div> </details> <details class="test xpassed"> <summary> <h3 class="title test-title"> <span class="status badge xpassed ">XPASS</span> <span class=test-name> <span class=funcname>test_user_info_route</span> </span> <span class=duration>0:00:00.056281</span> </h3> </summary> <div class=content> <div class=documentation> <p>Test api route <cite>/api/v0/users/me/</cite> with user token and validate response schema</p> </div> <table class=metadata> <tr> <th>Started</th> <td>2023-06-30 01:14:33</td> </tr> <tr> <th>Ended</th> <td>2023-06-30 01:14:33</td> </tr> <tr> <th>Duration</th> <td>0:00:00.056281</td> </tr> <tr> <th>Markers</th> <td> <div class=marker> <span class="marker-name badge">read_data</span> <span class=marker-args> </span> </div> <div class=marker> <span class="marker-name badge">xfail</span> <span class=marker-args> </span> </div> <div class=marker> <span class="marker-name badge">livetest</span> <span class=marker-args> </span> </div> </td> </tr> <tr> <th>Fixtures</th> <td> <span class="badge fixturename"> django_test_environment </span> <span class="badge fixturename"> django_db_blocker </span> <span class="badge fixturename"> test_client </span> <span class="badge fixturename"> request </span> </td> </tr> </table> <div class=test-phases> <details class="phase setup "> <summary> <h4 class=title> <span class=phase-name>Setup</span> </h4> </summary> <div class=content> </div> </details> <details class="phase call xpassed" open> <summary> <h4 class=title> <span class="status  xpassed"></span> <span class=phase-name>Call</span> </h4> </summary> <div class=content> </div> </details> <details class="phase teardown "> <summary> <h4 class=title> <span class=phase-name>Teardown</span> </h4> </summary> <div class=content> </div> </details> </div> </div> </details> </div> </details> <details class=file> <summary> <h2 class="title file-title"> <span class=fspath> app/api/live_tests/test_catalog/test_detail_catalog.py </span> <span class=counts> <span title="2 xfailed" class="count status badge xfailed ">2</span> </span> <span class=duration> 0:00:01.577420 </span> </h2> </summary> <div class="content box"> <details class="test xfailed"> <summary> <h3 class="title test-title"> <span class="status badge xfailed ">XFAIL</span> <span class=test-name> <span class=funcname>test_x3_schema_details_catalog</span> </span> <span class=duration>0:00:00.843851</span> </h3> </summary> <div class=content> <div class=documentation> <p>Validate X3 catalog schema representation <cite>XBODC</cite> details</p> </div> <table class=metadata> <tr> <th>Started</th> <td>2023-06-30 01:14:39</td> </tr> <tr> <th>Ended</th> <td>2023-06-30 01:14:40</td> </tr> <tr> <th>Duration</th> <td>0:00:00.843851</td> </tr> <tr> <th>Markers</th> <td> <div class=marker> <span class="marker-name badge">read_data</span> <span class=marker-args> </span> </div> <div class=marker> <span class="marker-name badge">xfail</span> <span class=marker-args> </span> </div> <div class=marker> <span class="marker-name badge">livetest</span> <span class=marker-args> </span> </div> </td> </tr> <tr> <th>Fixtures</th> <td> <span class="badge fixturename"> django_test_environment </span> <span class="badge fixturename"> django_db_blocker </span> <span class="badge fixturename"> test_client </span> <span class="badge fixturename"> x3_client </span> <span class="badge fixturename"> request </span> </td> </tr> </table> <div class=repr> <pre>AssertionError: b&#39;{&#34;detail&#34;:&#34;Server Error (500)&#34;,&#34;status_code&#34;:500}&#39;
assert 500 == 200
 +  where 500 = &lt;Response [500]&gt;.status_code</pre> </div> <div class=test-phases> <details class="phase setup "> <summary> <h4 class=title> <span class=phase-name>Setup</span> </h4> </summary> <div class=content> </div> </details> <details class="phase call xfailed" open> <summary> <h4 class=title> <span class="status  xfailed"></span> <span class=phase-name>Call</span> </h4> </summary> <div class=content> <div class=repr> <pre>test_client = &lt;conftest.LiveServerSession object at 0x7f34c1588700&gt;
x3_client = &lt;x3_wrapper.rest_client.X3RestClient object at 0x7f34bbe1f4f0&gt;

    @pytest.mark.livetest
    @pytest.mark.xfail
    @pytest.mark.read_data
    def test_x3_schema_details_catalog(test_client, x3_client):
        &#34;&#34;&#34;Validate X3 catalog schema representation `XBODC` details&#34;&#34;&#34;
&gt;       product_ref = get_random_catalog_id(test_client)

app/api/live_tests/test_catalog/test_detail_catalog.py:27: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

test_client = &lt;conftest.LiveServerSession object at 0x7f34c1588700&gt;

    def get_random_catalog_id(test_client):
        params = {
            &#34;order_by&#34;: &#34;UPDDATTIM desc&#34;,
        }
        resp = test_client.get(&#34;/api/v0/catalogs/&#34;, params=params)
&gt;       assert resp.status_code == 200, resp.content
E       AssertionError: b&#39;{&#34;detail&#34;:&#34;Server Error (500)&#34;,&#34;status_code&#34;:500}&#39;
E       assert 500 == 200
E        +  where 500 = &lt;Response [500]&gt;.status_code

app/api/live_tests/test_catalog/test_detail_catalog.py:17: AssertionError</pre> </div> </div> </details> <details class="phase teardown "> <summary> <h4 class=title> <span class=phase-name>Teardown</span> </h4> </summary> <div class=content> </div> </details> </div> </div> </details> <details class="test xfailed"> <summary> <h3 class="title test-title"> <span class="status badge xfailed ">XFAIL</span> <span class=test-name> <span class=funcname>test_api_schema_details_catalog</span> </span> <span class=duration>0:00:00.733569</span> </h3> </summary> <div class=content> <div class=documentation> <p>Validate api schema representation for route <cite>/catalogs/:product_ref</cite></p> </div> <table class=metadata> <tr> <th>Started</th> <td>2023-06-30 01:14:40</td> </tr> <tr> <th>Ended</th> <td>2023-06-30 01:14:41</td> </tr> <tr> <th>Duration</th> <td>0:00:00.733569</td> </tr> <tr> <th>Markers</th> <td> <div class=marker> <span class="marker-name badge">read_data</span> <span class=marker-args> </span> </div> <div class=marker> <span class="marker-name badge">xfail</span> <span class=marker-args> </span> </div> <div class=marker> <span class="marker-name badge">livetest</span> <span class=marker-args> </span> </div> </td> </tr> <tr> <th>Fixtures</th> <td> <span class="badge fixturename"> django_test_environment </span> <span class="badge fixturename"> django_db_blocker </span> <span class="badge fixturename"> test_client </span> <span class="badge fixturename"> request </span> </td> </tr> </table> <div class=repr> <pre>AssertionError: b&#39;{&#34;detail&#34;:&#34;Server Error (500)&#34;,&#34;status_code&#34;:500}&#39;
assert 500 == 200
 +  where 500 = &lt;Response [500]&gt;.status_code</pre> </div> <div class=test-phases> <details class="phase setup "> <summary> <h4 class=title> <span class=phase-name>Setup</span> </h4> </summary> <div class=content> </div> </details> <details class="phase call xfailed" open> <summary> <h4 class=title> <span class="status  xfailed"></span> <span class=phase-name>Call</span> </h4> </summary> <div class=content> <div class=repr> <pre>test_client = &lt;conftest.LiveServerSession object at 0x7f34bbd52d30&gt;

    @pytest.mark.livetest
    @pytest.mark.xfail
    @pytest.mark.read_data
    def test_api_schema_details_catalog(test_client):
        &#34;&#34;&#34;Validate api schema representation for route `/catalogs/:product_ref`&#34;&#34;&#34;
&gt;       product_ref = get_random_catalog_id(test_client)

app/api/live_tests/test_catalog/test_detail_catalog.py:38: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

test_client = &lt;conftest.LiveServerSession object at 0x7f34bbd52d30&gt;

    def get_random_catalog_id(test_client):
        params = {
            &#34;order_by&#34;: &#34;UPDDATTIM desc&#34;,
        }
        resp = test_client.get(&#34;/api/v0/catalogs/&#34;, params=params)
&gt;       assert resp.status_code == 200, resp.content
E       AssertionError: b&#39;{&#34;detail&#34;:&#34;Server Error (500)&#34;,&#34;status_code&#34;:500}&#39;
E       assert 500 == 200
E        +  where 500 = &lt;Response [500]&gt;.status_code

app/api/live_tests/test_catalog/test_detail_catalog.py:17: AssertionError</pre> </div> </div> </details> <details class="phase teardown "> <summary> <h4 class=title> <span class=phase-name>Teardown</span> </h4> </summary> <div class=content> </div> </details> </div> </div> </details> </div> </details> <details class=file> <summary> <h2 class="title file-title"> <span class=fspath> app/api/live_tests/test_catalog/test_query_catalog.py </span> <span class=counts> <span title="2 xfailed" class="count status badge xfailed ">2</span> </span> <span class=duration> 0:00:01.413590 </span> </h2> </summary> <div class="content box"> <details class="test xfailed"> <summary> <h3 class="title test-title"> <span class="status badge xfailed ">XFAIL</span> <span class=test-name> <span class=funcname>test_x3_schema_query_catalog</span> </span> <span class=duration>0:00:00.673680</span> </h3> </summary> <div class=content> <div class=documentation> <p>Validate catalog schema representation <cite>XBODC</cite> query</p> </div> <table class=metadata> <tr> <th>Started</th> <td>2023-06-30 01:14:41</td> </tr> <tr> <th>Ended</th> <td>2023-06-30 01:14:42</td> </tr> <tr> <th>Duration</th> <td>0:00:00.673680</td> </tr> <tr> <th>Markers</th> <td> <div class=marker> <span class="marker-name badge">read_data</span> <span class=marker-args> </span> </div> <div class=marker> <span class="marker-name badge">xfail</span> <span class=marker-args> </span> </div> <div class=marker> <span class="marker-name badge">livetest</span> <span class=marker-args> </span> </div> </td> </tr> <tr> <th>Fixtures</th> <td> <span class="badge fixturename"> django_test_environment </span> <span class="badge fixturename"> django_db_blocker </span> <span class="badge fixturename"> x3_client </span> <span class="badge fixturename"> request </span> </td> </tr> </table> <div class=repr> <pre>requests.exceptions.RetryError: HTTPSConnectionPool(host=&#39;sagex3-horsprod.covage.com&#39;, port=443): Max retries exceeded with url: /api1/x3/erp/QAL/XBODC?representation=XBODC.%24query&amp;count=50&amp;orderBy=UPDDATTIM%20desc (Caused by ResponseError(&#39;too many 502 error responses&#39;))</pre> </div> <div class=test-phases> <details class="phase setup "> <summary> <h4 class=title> <span class=phase-name>Setup</span> </h4> </summary> <div class=content> </div> </details> <details class="phase call xfailed" open> <summary> <h4 class=title> <span class="status  xfailed"></span> <span class=phase-name>Call</span> </h4> </summary> <div class=content> <div class=repr> <pre>self = &lt;requests.adapters.HTTPAdapter object at 0x7f34bbe08160&gt;
request = &lt;PreparedRequest [GET]&gt;, stream = False
timeout = Timeout(connect=None, read=None, total=None), verify = True
cert = None
proxies = OrderedDict([(&#39;no&#39;, &#39;gitlab-runner-cache-01-prd.nut.covage.com&#39;), (&#39;http&#39;, &#39;http://squid.kosc.net:3128&#39;), (&#39;https&#39;, &#39;http://squid.kosc.net:3128&#39;)])

    def send(
        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None
    ):
        &#34;&#34;&#34;Sends PreparedRequest object. Returns Response object.
    
        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.
        :param stream: (optional) Whether to stream the request content.
        :param timeout: (optional) How long to wait for the server to send
            data before giving up, as a float, or a :ref:`(connect timeout,
            read timeout) &lt;timeouts&gt;` tuple.
        :type timeout: float or tuple or urllib3 Timeout object
        :param verify: (optional) Either a boolean, in which case it controls whether
            we verify the server&#39;s TLS certificate, or a string, in which case it
            must be a path to a CA bundle to use
        :param cert: (optional) Any user-provided SSL certificate to be trusted.
        :param proxies: (optional) The proxies dictionary to apply to the request.
        :rtype: requests.Response
        &#34;&#34;&#34;
    
        try:
            conn = self.get_connection(request.url, proxies)
        except LocationValueError as e:
            raise InvalidURL(e, request=request)
    
        self.cert_verify(conn, request.url, verify, cert)
        url = self.request_url(request, proxies)
        self.add_headers(
            request,
            stream=stream,
            timeout=timeout,
            verify=verify,
            cert=cert,
            proxies=proxies,
        )
    
        chunked = not (request.body is None or &#34;Content-Length&#34; in request.headers)
    
        if isinstance(timeout, tuple):
            try:
                connect, read = timeout
                timeout = TimeoutSauce(connect=connect, read=read)
            except ValueError:
                raise ValueError(
                    f&#34;Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, &#34;
                    f&#34;or a single float to set both timeouts to the same value.&#34;
                )
        elif isinstance(timeout, TimeoutSauce):
            pass
        else:
            timeout = TimeoutSauce(connect=timeout, read=timeout)
    
        try:
            if not chunked:
&gt;               resp = conn.urlopen(
                    method=request.method,
                    url=url,
                    body=request.body,
                    headers=request.headers,
                    redirect=False,
                    assert_same_host=False,
                    preload_content=False,
                    decode_content=False,
                    retries=self.max_retries,
                    timeout=timeout,
                )

/usr/local/lib/python3.8/site-packages/requests/adapters.py:489: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connectionpool.HTTPSConnectionPool object at 0x7f34bbe08250&gt;
method = &#39;GET&#39;
url = &#39;/api1/x3/erp/QAL/XBODC?representation=XBODC.%24query&amp;count=50&amp;orderBy=UPDDATTIM%20desc&#39;
body = None
headers = {&#39;User-Agent&#39;: &#39;python-requests/2.28.1&#39;, &#39;Accept-Encoding&#39;: &#39;gzip, deflate&#39;, &#39;Accept&#39;: &#39;*/*&#39;, &#39;Connection&#39;: &#39;keep-alive&#39;, &#39;Content-Type&#39;: &#39;application/json&#39;, &#39;Authorization&#39;: &#39;Basic aW50cmFjbzpXYXNzaW1Db3ZhZ2VA&#39;}
retries = Retry(total=2, connect=None, read=None, redirect=None, status=None)
redirect = False, assert_same_host = False
timeout = Timeout(connect=None, read=None, total=None), pool_timeout = None
release_conn = False, chunked = False, body_pos = None
response_kw = {&#39;decode_content&#39;: False, &#39;preload_content&#39;: False, &#39;request_method&#39;: &#39;GET&#39;}
parsed_url = Url(scheme=None, auth=None, host=None, port=None, path=&#39;/api1/x3/erp/QAL/XBODC&#39;, query=&#39;representation=XBODC.%24query&amp;count=50&amp;orderBy=UPDDATTIM%20desc&#39;, fragment=None)
destination_scheme = None
conn = &lt;urllib3.connection.HTTPSConnection object at 0x7f34bbc44b80&gt;
release_this_conn = False, http_tunnel_required = True, err = None
clean_exit = True

    def urlopen(
        self,
        method,
        url,
        body=None,
        headers=None,
        retries=None,
        redirect=True,
        assert_same_host=True,
        timeout=_Default,
        pool_timeout=None,
        release_conn=None,
        chunked=False,
        body_pos=None,
        **response_kw
    ):
        &#34;&#34;&#34;
        Get a connection from the pool and perform an HTTP request. This is the
        lowest level call for making a request, so you&#39;ll need to specify all
        the raw details.
    
        .. note::
    
           More commonly, it&#39;s appropriate to use a convenience method provided
           by :class:`.RequestMethods`, such as :meth:`request`.
    
        .. note::
    
           `release_conn` will only behave as expected if
           `preload_content=False` because we want to make
           `preload_content=False` the default behaviour someday soon without
           breaking backwards compatibility.
    
        :param method:
            HTTP request method (such as GET, POST, PUT, etc.)
    
        :param url:
            The URL to perform the request on.
    
        :param body:
            Data to send in the request body, either :class:`str`, :class:`bytes`,
            an iterable of :class:`str`/:class:`bytes`, or a file-like object.
    
        :param headers:
            Dictionary of custom headers to send, such as User-Agent,
            If-None-Match, etc. If None, pool headers are used. If provided,
            these headers completely replace any pool-specific headers.
    
        :param retries:
            Configure the number of retries to allow before raising a
            :class:`~urllib3.exceptions.MaxRetryError` exception.
    
            Pass ``None`` to retry until you receive a response. Pass a
            :class:`~urllib3.util.retry.Retry` object for fine-grained control
            over different types of retries.
            Pass an integer number to retry connection errors that many times,
            but no other types of errors. Pass zero to never retry.
    
            If ``False``, then retries are disabled and any exception is raised
            immediately. Also, instead of raising a MaxRetryError on redirects,
            the redirect response will be returned.
    
        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.
    
        :param redirect:
            If True, automatically handle redirects (status codes 301, 302,
            303, 307, 308). Each redirect counts as a retry. Disabling retries
            will disable redirect, too.
    
        :param assert_same_host:
            If ``True``, will make sure that the host of the pool requests is
            consistent else will raise HostChangedError. When ``False``, you can
            use the pool on an HTTP proxy and request foreign hosts.
    
        :param timeout:
            If specified, overrides the default timeout for this one
            request. It may be a float (in seconds) or an instance of
            :class:`urllib3.util.Timeout`.
    
        :param pool_timeout:
            If set and the pool is set to block=True, then this method will
            block for ``pool_timeout`` seconds and raise EmptyPoolError if no
            connection is available within the time period.
    
        :param release_conn:
            If False, then the urlopen call will not release the connection
            back into the pool once a response is received (but will release if
            you read the entire contents of the response such as when
            `preload_content=True`). This is useful if you&#39;re not preloading
            the response&#39;s content immediately. You will need to call
            ``r.release_conn()`` on the response ``r`` to return the connection
            back into the pool. If None, it takes the value of
            ``response_kw.get(&#39;preload_content&#39;, True)``.
    
        :param chunked:
            If True, urllib3 will send the body using chunked transfer
            encoding. Otherwise, urllib3 will send the body using the standard
            content-length form. Defaults to False.
    
        :param int body_pos:
            Position to seek to in file-like body in the event of a retry or
            redirect. Typically this won&#39;t need to be set because urllib3 will
            auto-populate the value when needed.
    
        :param \\**response_kw:
            Additional parameters are passed to
            :meth:`urllib3.response.HTTPResponse.from_httplib`
        &#34;&#34;&#34;
    
        parsed_url = parse_url(url)
        destination_scheme = parsed_url.scheme
    
        if headers is None:
            headers = self.headers
    
        if not isinstance(retries, Retry):
            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)
    
        if release_conn is None:
            release_conn = response_kw.get(&#34;preload_content&#34;, True)
    
        # Check host
        if assert_same_host and not self.is_same_host(url):
            raise HostChangedError(self, url, retries)
    
        # Ensure that the URL we&#39;re connecting to is properly encoded
        if url.startswith(&#34;/&#34;):
            url = six.ensure_str(_encode_target(url))
        else:
            url = six.ensure_str(parsed_url.url)
    
        conn = None
    
        # Track whether `conn` needs to be released before
        # returning/raising/recursing. Update this variable if necessary, and
        # leave `release_conn` constant throughout the function. That way, if
        # the function recurses, the original value of `release_conn` will be
        # passed down into the recursive call, and its value will be respected.
        #
        # See issue #651 [1] for details.
        #
        # [1] &lt;https://github.com/urllib3/urllib3/issues/651&gt;
        release_this_conn = release_conn
    
        http_tunnel_required = connection_requires_http_tunnel(
            self.proxy, self.proxy_config, destination_scheme
        )
    
        # Merge the proxy headers. Only done when not using HTTP CONNECT. We
        # have to copy the headers dict so we can safely change it without those
        # changes being reflected in anyone else&#39;s copy.
        if not http_tunnel_required:
            headers = headers.copy()
            headers.update(self.proxy_headers)
    
        # Must keep the exception bound to a separate variable or else Python 3
        # complains about UnboundLocalError.
        err = None
    
        # Keep track of whether we cleanly exited the except block. This
        # ensures we do proper cleanup in finally.
        clean_exit = False
    
        # Rewind body position, if needed. Record current position
        # for future rewinds in the event of a redirect/retry.
        body_pos = set_file_position(body, body_pos)
    
        try:
            # Request a connection from the queue.
            timeout_obj = self._get_timeout(timeout)
            conn = self._get_conn(timeout=pool_timeout)
    
            conn.timeout = timeout_obj.connect_timeout
    
            is_new_proxy_conn = self.proxy is not None and not getattr(
                conn, &#34;sock&#34;, None
            )
            if is_new_proxy_conn and http_tunnel_required:
                self._prepare_proxy(conn)
    
            # Make the request on the httplib connection object.
            httplib_response = self._make_request(
                conn,
                method,
                url,
                timeout=timeout_obj,
                body=body,
                headers=headers,
                chunked=chunked,
            )
    
            # If we&#39;re going to release the connection in ``finally:``, then
            # the response doesn&#39;t need to know about the connection. Otherwise
            # it will also try to release it and we&#39;ll have a double-release
            # mess.
            response_conn = conn if not release_conn else None
    
            # Pass method to Response for length checking
            response_kw[&#34;request_method&#34;] = method
    
            # Import httplib&#39;s response into our own wrapper object
            response = self.ResponseCls.from_httplib(
                httplib_response,
                pool=self,
                connection=response_conn,
                retries=retries,
                **response_kw
            )
    
            # Everything went great!
            clean_exit = True
    
        except EmptyPoolError:
            # Didn&#39;t get a connection from the pool, no need to clean up
            clean_exit = True
            release_this_conn = False
            raise
    
        except (
            TimeoutError,
            HTTPException,
            SocketError,
            ProtocolError,
            BaseSSLError,
            SSLError,
            CertificateError,
        ) as e:
            # Discard the connection for these exceptions. It will be
            # replaced during the next _get_conn() call.
            clean_exit = False
    
            def _is_ssl_error_message_from_http_proxy(ssl_error):
                # We&#39;re trying to detect the message &#39;WRONG_VERSION_NUMBER&#39; but
                # SSLErrors are kinda all over the place when it comes to the message,
                # so we try to cover our bases here!
                message = &#34; &#34;.join(re.split(&#34;[^a-z]&#34;, str(ssl_error).lower()))
                return (
                    &#34;wrong version number&#34; in message or &#34;unknown protocol&#34; in message
                )
    
            # Try to detect a common user error with proxies which is to
            # set an HTTP proxy to be HTTPS when it should be &#39;http://&#39;
            # (ie {&#39;http&#39;: &#39;http://proxy&#39;, &#39;https&#39;: &#39;https://proxy&#39;})
            # Instead we add a nice error message and point to a URL.
            if (
                isinstance(e, BaseSSLError)
                and self.proxy
                and _is_ssl_error_message_from_http_proxy(e)
                and conn.proxy
                and conn.proxy.scheme == &#34;https&#34;
            ):
                e = ProxyError(
                    &#34;Your proxy appears to only use HTTP and not HTTPS, &#34;
                    &#34;try changing your proxy URL to be HTTP. See: &#34;
                    &#34;https://urllib3.readthedocs.io/en/1.26.x/advanced-usage.html&#34;
                    &#34;#https-proxy-error-http-proxy&#34;,
                    SSLError(e),
                )
            elif isinstance(e, (BaseSSLError, CertificateError)):
                e = SSLError(e)
            elif isinstance(e, (SocketError, NewConnectionError)) and self.proxy:
                e = ProxyError(&#34;Cannot connect to proxy.&#34;, e)
            elif isinstance(e, (SocketError, HTTPException)):
                e = ProtocolError(&#34;Connection aborted.&#34;, e)
    
            retries = retries.increment(
                method, url, error=e, _pool=self, _stacktrace=sys.exc_info()[2]
            )
            retries.sleep()
    
            # Keep track of the error for the retry warning.
            err = e
    
        finally:
            if not clean_exit:
                # We hit some kind of exception, handled or otherwise. We need
                # to throw the connection away unless explicitly told not to.
                # Close the connection, set the variable to None, and make sure
                # we put the None back in the pool to avoid leaking it.
                conn = conn and conn.close()
                release_this_conn = True
    
            if release_this_conn:
                # Put the connection back to be reused. If the connection is
                # expired then it will be None, which will get replaced with a
                # fresh connection during _get_conn.
                self._put_conn(conn)
    
        if not conn:
            # Try again
            log.warning(
                &#34;Retrying (%r) after connection broken by &#39;%r&#39;: %s&#34;, retries, err, url
            )
            return self.urlopen(
                method,
                url,
                body,
                headers,
                retries,
                redirect,
                assert_same_host,
                timeout=timeout,
                pool_timeout=pool_timeout,
                release_conn=release_conn,
                chunked=chunked,
                body_pos=body_pos,
                **response_kw
            )
    
        # Handle redirect?
        redirect_location = redirect and response.get_redirect_location()
        if redirect_location:
            if response.status == 303:
                method = &#34;GET&#34;
    
            try:
                retries = retries.increment(method, url, response=response, _pool=self)
            except MaxRetryError:
                if retries.raise_on_redirect:
                    response.drain_conn()
                    raise
                return response
    
            response.drain_conn()
            retries.sleep_for_retry(response)
            log.debug(&#34;Redirecting %s -&gt; %s&#34;, url, redirect_location)
            return self.urlopen(
                method,
                redirect_location,
                body,
                headers,
                retries=retries,
                redirect=redirect,
                assert_same_host=assert_same_host,
                timeout=timeout,
                pool_timeout=pool_timeout,
                release_conn=release_conn,
                chunked=chunked,
                body_pos=body_pos,
                **response_kw
            )
    
        # Check if we should retry the HTTP response.
        has_retry_after = bool(response.getheader(&#34;Retry-After&#34;))
        if retries.is_retry(method, response.status, has_retry_after):
            try:
                retries = retries.increment(method, url, response=response, _pool=self)
            except MaxRetryError:
                if retries.raise_on_status:
                    response.drain_conn()
                    raise
                return response
    
            response.drain_conn()
            retries.sleep(response)
            log.debug(&#34;Retry: %s&#34;, url)
&gt;           return self.urlopen(
                method,
                url,
                body,
                headers,
                retries=retries,
                redirect=redirect,
                assert_same_host=assert_same_host,
                timeout=timeout,
                pool_timeout=pool_timeout,
                release_conn=release_conn,
                chunked=chunked,
                body_pos=body_pos,
                **response_kw
            )

/usr/local/lib/python3.8/site-packages/urllib3/connectionpool.py:878: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connectionpool.HTTPSConnectionPool object at 0x7f34bbe08250&gt;
method = &#39;GET&#39;
url = &#39;/api1/x3/erp/QAL/XBODC?representation=XBODC.%24query&amp;count=50&amp;orderBy=UPDDATTIM%20desc&#39;
body = None
headers = {&#39;User-Agent&#39;: &#39;python-requests/2.28.1&#39;, &#39;Accept-Encoding&#39;: &#39;gzip, deflate&#39;, &#39;Accept&#39;: &#39;*/*&#39;, &#39;Connection&#39;: &#39;keep-alive&#39;, &#39;Content-Type&#39;: &#39;application/json&#39;, &#39;Authorization&#39;: &#39;Basic aW50cmFjbzpXYXNzaW1Db3ZhZ2VA&#39;}
retries = Retry(total=1, connect=None, read=None, redirect=None, status=None)
redirect = False, assert_same_host = False
timeout = Timeout(connect=None, read=None, total=None), pool_timeout = None
release_conn = False, chunked = False, body_pos = None
response_kw = {&#39;decode_content&#39;: False, &#39;preload_content&#39;: False, &#39;request_method&#39;: &#39;GET&#39;}
parsed_url = Url(scheme=None, auth=None, host=None, port=None, path=&#39;/api1/x3/erp/QAL/XBODC&#39;, query=&#39;representation=XBODC.%24query&amp;count=50&amp;orderBy=UPDDATTIM%20desc&#39;, fragment=None)
destination_scheme = None
conn = &lt;urllib3.connection.HTTPSConnection object at 0x7f34bbc44b80&gt;
release_this_conn = False, http_tunnel_required = True, err = None
clean_exit = True

    def urlopen(
        self,
        method,
        url,
        body=None,
        headers=None,
        retries=None,
        redirect=True,
        assert_same_host=True,
        timeout=_Default,
        pool_timeout=None,
        release_conn=None,
        chunked=False,
        body_pos=None,
        **response_kw
    ):
        &#34;&#34;&#34;
        Get a connection from the pool and perform an HTTP request. This is the
        lowest level call for making a request, so you&#39;ll need to specify all
        the raw details.
    
        .. note::
    
           More commonly, it&#39;s appropriate to use a convenience method provided
           by :class:`.RequestMethods`, such as :meth:`request`.
    
        .. note::
    
           `release_conn` will only behave as expected if
           `preload_content=False` because we want to make
           `preload_content=False` the default behaviour someday soon without
           breaking backwards compatibility.
    
        :param method:
            HTTP request method (such as GET, POST, PUT, etc.)
    
        :param url:
            The URL to perform the request on.
    
        :param body:
            Data to send in the request body, either :class:`str`, :class:`bytes`,
            an iterable of :class:`str`/:class:`bytes`, or a file-like object.
    
        :param headers:
            Dictionary of custom headers to send, such as User-Agent,
            If-None-Match, etc. If None, pool headers are used. If provided,
            these headers completely replace any pool-specific headers.
    
        :param retries:
            Configure the number of retries to allow before raising a
            :class:`~urllib3.exceptions.MaxRetryError` exception.
    
            Pass ``None`` to retry until you receive a response. Pass a
            :class:`~urllib3.util.retry.Retry` object for fine-grained control
            over different types of retries.
            Pass an integer number to retry connection errors that many times,
            but no other types of errors. Pass zero to never retry.
    
            If ``False``, then retries are disabled and any exception is raised
            immediately. Also, instead of raising a MaxRetryError on redirects,
            the redirect response will be returned.
    
        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.
    
        :param redirect:
            If True, automatically handle redirects (status codes 301, 302,
            303, 307, 308). Each redirect counts as a retry. Disabling retries
            will disable redirect, too.
    
        :param assert_same_host:
            If ``True``, will make sure that the host of the pool requests is
            consistent else will raise HostChangedError. When ``False``, you can
            use the pool on an HTTP proxy and request foreign hosts.
    
        :param timeout:
            If specified, overrides the default timeout for this one
            request. It may be a float (in seconds) or an instance of
            :class:`urllib3.util.Timeout`.
    
        :param pool_timeout:
            If set and the pool is set to block=True, then this method will
            block for ``pool_timeout`` seconds and raise EmptyPoolError if no
            connection is available within the time period.
    
        :param release_conn:
            If False, then the urlopen call will not release the connection
            back into the pool once a response is received (but will release if
            you read the entire contents of the response such as when
            `preload_content=True`). This is useful if you&#39;re not preloading
            the response&#39;s content immediately. You will need to call
            ``r.release_conn()`` on the response ``r`` to return the connection
            back into the pool. If None, it takes the value of
            ``response_kw.get(&#39;preload_content&#39;, True)``.
    
        :param chunked:
            If True, urllib3 will send the body using chunked transfer
            encoding. Otherwise, urllib3 will send the body using the standard
            content-length form. Defaults to False.
    
        :param int body_pos:
            Position to seek to in file-like body in the event of a retry or
            redirect. Typically this won&#39;t need to be set because urllib3 will
            auto-populate the value when needed.
    
        :param \\**response_kw:
            Additional parameters are passed to
            :meth:`urllib3.response.HTTPResponse.from_httplib`
        &#34;&#34;&#34;
    
        parsed_url = parse_url(url)
        destination_scheme = parsed_url.scheme
    
        if headers is None:
            headers = self.headers
    
        if not isinstance(retries, Retry):
            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)
    
        if release_conn is None:
            release_conn = response_kw.get(&#34;preload_content&#34;, True)
    
        # Check host
        if assert_same_host and not self.is_same_host(url):
            raise HostChangedError(self, url, retries)
    
        # Ensure that the URL we&#39;re connecting to is properly encoded
        if url.startswith(&#34;/&#34;):
            url = six.ensure_str(_encode_target(url))
        else:
            url = six.ensure_str(parsed_url.url)
    
        conn = None
    
        # Track whether `conn` needs to be released before
        # returning/raising/recursing. Update this variable if necessary, and
        # leave `release_conn` constant throughout the function. That way, if
        # the function recurses, the original value of `release_conn` will be
        # passed down into the recursive call, and its value will be respected.
        #
        # See issue #651 [1] for details.
        #
        # [1] &lt;https://github.com/urllib3/urllib3/issues/651&gt;
        release_this_conn = release_conn
    
        http_tunnel_required = connection_requires_http_tunnel(
            self.proxy, self.proxy_config, destination_scheme
        )
    
        # Merge the proxy headers. Only done when not using HTTP CONNECT. We
        # have to copy the headers dict so we can safely change it without those
        # changes being reflected in anyone else&#39;s copy.
        if not http_tunnel_required:
            headers = headers.copy()
            headers.update(self.proxy_headers)
    
        # Must keep the exception bound to a separate variable or else Python 3
        # complains about UnboundLocalError.
        err = None
    
        # Keep track of whether we cleanly exited the except block. This
        # ensures we do proper cleanup in finally.
        clean_exit = False
    
        # Rewind body position, if needed. Record current position
        # for future rewinds in the event of a redirect/retry.
        body_pos = set_file_position(body, body_pos)
    
        try:
            # Request a connection from the queue.
            timeout_obj = self._get_timeout(timeout)
            conn = self._get_conn(timeout=pool_timeout)
    
            conn.timeout = timeout_obj.connect_timeout
    
            is_new_proxy_conn = self.proxy is not None and not getattr(
                conn, &#34;sock&#34;, None
            )
            if is_new_proxy_conn and http_tunnel_required:
                self._prepare_proxy(conn)
    
            # Make the request on the httplib connection object.
            httplib_response = self._make_request(
                conn,
                method,
                url,
                timeout=timeout_obj,
                body=body,
                headers=headers,
                chunked=chunked,
            )
    
            # If we&#39;re going to release the connection in ``finally:``, then
            # the response doesn&#39;t need to know about the connection. Otherwise
            # it will also try to release it and we&#39;ll have a double-release
            # mess.
            response_conn = conn if not release_conn else None
    
            # Pass method to Response for length checking
            response_kw[&#34;request_method&#34;] = method
    
            # Import httplib&#39;s response into our own wrapper object
            response = self.ResponseCls.from_httplib(
                httplib_response,
                pool=self,
                connection=response_conn,
                retries=retries,
                **response_kw
            )
    
            # Everything went great!
            clean_exit = True
    
        except EmptyPoolError:
            # Didn&#39;t get a connection from the pool, no need to clean up
            clean_exit = True
            release_this_conn = False
            raise
    
        except (
            TimeoutError,
            HTTPException,
            SocketError,
            ProtocolError,
            BaseSSLError,
            SSLError,
            CertificateError,
        ) as e:
            # Discard the connection for these exceptions. It will be
            # replaced during the next _get_conn() call.
            clean_exit = False
    
            def _is_ssl_error_message_from_http_proxy(ssl_error):
                # We&#39;re trying to detect the message &#39;WRONG_VERSION_NUMBER&#39; but
                # SSLErrors are kinda all over the place when it comes to the message,
                # so we try to cover our bases here!
                message = &#34; &#34;.join(re.split(&#34;[^a-z]&#34;, str(ssl_error).lower()))
                return (
                    &#34;wrong version number&#34; in message or &#34;unknown protocol&#34; in message
                )
    
            # Try to detect a common user error with proxies which is to
            # set an HTTP proxy to be HTTPS when it should be &#39;http://&#39;
            # (ie {&#39;http&#39;: &#39;http://proxy&#39;, &#39;https&#39;: &#39;https://proxy&#39;})
            # Instead we add a nice error message and point to a URL.
            if (
                isinstance(e, BaseSSLError)
                and self.proxy
                and _is_ssl_error_message_from_http_proxy(e)
                and conn.proxy
                and conn.proxy.scheme == &#34;https&#34;
            ):
                e = ProxyError(
                    &#34;Your proxy appears to only use HTTP and not HTTPS, &#34;
                    &#34;try changing your proxy URL to be HTTP. See: &#34;
                    &#34;https://urllib3.readthedocs.io/en/1.26.x/advanced-usage.html&#34;
                    &#34;#https-proxy-error-http-proxy&#34;,
                    SSLError(e),
                )
            elif isinstance(e, (BaseSSLError, CertificateError)):
                e = SSLError(e)
            elif isinstance(e, (SocketError, NewConnectionError)) and self.proxy:
                e = ProxyError(&#34;Cannot connect to proxy.&#34;, e)
            elif isinstance(e, (SocketError, HTTPException)):
                e = ProtocolError(&#34;Connection aborted.&#34;, e)
    
            retries = retries.increment(
                method, url, error=e, _pool=self, _stacktrace=sys.exc_info()[2]
            )
            retries.sleep()
    
            # Keep track of the error for the retry warning.
            err = e
    
        finally:
            if not clean_exit:
                # We hit some kind of exception, handled or otherwise. We need
                # to throw the connection away unless explicitly told not to.
                # Close the connection, set the variable to None, and make sure
                # we put the None back in the pool to avoid leaking it.
                conn = conn and conn.close()
                release_this_conn = True
    
            if release_this_conn:
                # Put the connection back to be reused. If the connection is
                # expired then it will be None, which will get replaced with a
                # fresh connection during _get_conn.
                self._put_conn(conn)
    
        if not conn:
            # Try again
            log.warning(
                &#34;Retrying (%r) after connection broken by &#39;%r&#39;: %s&#34;, retries, err, url
            )
            return self.urlopen(
                method,
                url,
                body,
                headers,
                retries,
                redirect,
                assert_same_host,
                timeout=timeout,
                pool_timeout=pool_timeout,
                release_conn=release_conn,
                chunked=chunked,
                body_pos=body_pos,
                **response_kw
            )
    
        # Handle redirect?
        redirect_location = redirect and response.get_redirect_location()
        if redirect_location:
            if response.status == 303:
                method = &#34;GET&#34;
    
            try:
                retries = retries.increment(method, url, response=response, _pool=self)
            except MaxRetryError:
                if retries.raise_on_redirect:
                    response.drain_conn()
                    raise
                return response
    
            response.drain_conn()
            retries.sleep_for_retry(response)
            log.debug(&#34;Redirecting %s -&gt; %s&#34;, url, redirect_location)
            return self.urlopen(
                method,
                redirect_location,
                body,
                headers,
                retries=retries,
                redirect=redirect,
                assert_same_host=assert_same_host,
                timeout=timeout,
                pool_timeout=pool_timeout,
                release_conn=release_conn,
                chunked=chunked,
                body_pos=body_pos,
                **response_kw
            )
    
        # Check if we should retry the HTTP response.
        has_retry_after = bool(response.getheader(&#34;Retry-After&#34;))
        if retries.is_retry(method, response.status, has_retry_after):
            try:
                retries = retries.increment(method, url, response=response, _pool=self)
            except MaxRetryError:
                if retries.raise_on_status:
                    response.drain_conn()
                    raise
                return response
    
            response.drain_conn()
            retries.sleep(response)
            log.debug(&#34;Retry: %s&#34;, url)
&gt;           return self.urlopen(
                method,
                url,
                body,
                headers,
                retries=retries,
                redirect=redirect,
                assert_same_host=assert_same_host,
                timeout=timeout,
                pool_timeout=pool_timeout,
                release_conn=release_conn,
                chunked=chunked,
                body_pos=body_pos,
                **response_kw
            )

/usr/local/lib/python3.8/site-packages/urllib3/connectionpool.py:878: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connectionpool.HTTPSConnectionPool object at 0x7f34bbe08250&gt;
method = &#39;GET&#39;
url = &#39;/api1/x3/erp/QAL/XBODC?representation=XBODC.%24query&amp;count=50&amp;orderBy=UPDDATTIM%20desc&#39;
body = None
headers = {&#39;User-Agent&#39;: &#39;python-requests/2.28.1&#39;, &#39;Accept-Encoding&#39;: &#39;gzip, deflate&#39;, &#39;Accept&#39;: &#39;*/*&#39;, &#39;Connection&#39;: &#39;keep-alive&#39;, &#39;Content-Type&#39;: &#39;application/json&#39;, &#39;Authorization&#39;: &#39;Basic aW50cmFjbzpXYXNzaW1Db3ZhZ2VA&#39;}
retries = Retry(total=0, connect=None, read=None, redirect=None, status=None)
redirect = False, assert_same_host = False
timeout = Timeout(connect=None, read=None, total=None), pool_timeout = None
release_conn = False, chunked = False, body_pos = None
response_kw = {&#39;decode_content&#39;: False, &#39;preload_content&#39;: False, &#39;request_method&#39;: &#39;GET&#39;}
parsed_url = Url(scheme=None, auth=None, host=None, port=None, path=&#39;/api1/x3/erp/QAL/XBODC&#39;, query=&#39;representation=XBODC.%24query&amp;count=50&amp;orderBy=UPDDATTIM%20desc&#39;, fragment=None)
destination_scheme = None
conn = &lt;urllib3.connection.HTTPSConnection object at 0x7f34bbc44b80&gt;
release_this_conn = False, http_tunnel_required = True, err = None
clean_exit = True

    def urlopen(
        self,
        method,
        url,
        body=None,
        headers=None,
        retries=None,
        redirect=True,
        assert_same_host=True,
        timeout=_Default,
        pool_timeout=None,
        release_conn=None,
        chunked=False,
        body_pos=None,
        **response_kw
    ):
        &#34;&#34;&#34;
        Get a connection from the pool and perform an HTTP request. This is the
        lowest level call for making a request, so you&#39;ll need to specify all
        the raw details.
    
        .. note::
    
           More commonly, it&#39;s appropriate to use a convenience method provided
           by :class:`.RequestMethods`, such as :meth:`request`.
    
        .. note::
    
           `release_conn` will only behave as expected if
           `preload_content=False` because we want to make
           `preload_content=False` the default behaviour someday soon without
           breaking backwards compatibility.
    
        :param method:
            HTTP request method (such as GET, POST, PUT, etc.)
    
        :param url:
            The URL to perform the request on.
    
        :param body:
            Data to send in the request body, either :class:`str`, :class:`bytes`,
            an iterable of :class:`str`/:class:`bytes`, or a file-like object.
    
        :param headers:
            Dictionary of custom headers to send, such as User-Agent,
            If-None-Match, etc. If None, pool headers are used. If provided,
            these headers completely replace any pool-specific headers.
    
        :param retries:
            Configure the number of retries to allow before raising a
            :class:`~urllib3.exceptions.MaxRetryError` exception.
    
            Pass ``None`` to retry until you receive a response. Pass a
            :class:`~urllib3.util.retry.Retry` object for fine-grained control
            over different types of retries.
            Pass an integer number to retry connection errors that many times,
            but no other types of errors. Pass zero to never retry.
    
            If ``False``, then retries are disabled and any exception is raised
            immediately. Also, instead of raising a MaxRetryError on redirects,
            the redirect response will be returned.
    
        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.
    
        :param redirect:
            If True, automatically handle redirects (status codes 301, 302,
            303, 307, 308). Each redirect counts as a retry. Disabling retries
            will disable redirect, too.
    
        :param assert_same_host:
            If ``True``, will make sure that the host of the pool requests is
            consistent else will raise HostChangedError. When ``False``, you can
            use the pool on an HTTP proxy and request foreign hosts.
    
        :param timeout:
            If specified, overrides the default timeout for this one
            request. It may be a float (in seconds) or an instance of
            :class:`urllib3.util.Timeout`.
    
        :param pool_timeout:
            If set and the pool is set to block=True, then this method will
            block for ``pool_timeout`` seconds and raise EmptyPoolError if no
            connection is available within the time period.
    
        :param release_conn:
            If False, then the urlopen call will not release the connection
            back into the pool once a response is received (but will release if
            you read the entire contents of the response such as when
            `preload_content=True`). This is useful if you&#39;re not preloading
            the response&#39;s content immediately. You will need to call
            ``r.release_conn()`` on the response ``r`` to return the connection
            back into the pool. If None, it takes the value of
            ``response_kw.get(&#39;preload_content&#39;, True)``.
    
        :param chunked:
            If True, urllib3 will send the body using chunked transfer
            encoding. Otherwise, urllib3 will send the body using the standard
            content-length form. Defaults to False.
    
        :param int body_pos:
            Position to seek to in file-like body in the event of a retry or
            redirect. Typically this won&#39;t need to be set because urllib3 will
            auto-populate the value when needed.
    
        :param \\**response_kw:
            Additional parameters are passed to
            :meth:`urllib3.response.HTTPResponse.from_httplib`
        &#34;&#34;&#34;
    
        parsed_url = parse_url(url)
        destination_scheme = parsed_url.scheme
    
        if headers is None:
            headers = self.headers
    
        if not isinstance(retries, Retry):
            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)
    
        if release_conn is None:
            release_conn = response_kw.get(&#34;preload_content&#34;, True)
    
        # Check host
        if assert_same_host and not self.is_same_host(url):
            raise HostChangedError(self, url, retries)
    
        # Ensure that the URL we&#39;re connecting to is properly encoded
        if url.startswith(&#34;/&#34;):
            url = six.ensure_str(_encode_target(url))
        else:
            url = six.ensure_str(parsed_url.url)
    
        conn = None
    
        # Track whether `conn` needs to be released before
        # returning/raising/recursing. Update this variable if necessary, and
        # leave `release_conn` constant throughout the function. That way, if
        # the function recurses, the original value of `release_conn` will be
        # passed down into the recursive call, and its value will be respected.
        #
        # See issue #651 [1] for details.
        #
        # [1] &lt;https://github.com/urllib3/urllib3/issues/651&gt;
        release_this_conn = release_conn
    
        http_tunnel_required = connection_requires_http_tunnel(
            self.proxy, self.proxy_config, destination_scheme
        )
    
        # Merge the proxy headers. Only done when not using HTTP CONNECT. We
        # have to copy the headers dict so we can safely change it without those
        # changes being reflected in anyone else&#39;s copy.
        if not http_tunnel_required:
            headers = headers.copy()
            headers.update(self.proxy_headers)
    
        # Must keep the exception bound to a separate variable or else Python 3
        # complains about UnboundLocalError.
        err = None
    
        # Keep track of whether we cleanly exited the except block. This
        # ensures we do proper cleanup in finally.
        clean_exit = False
    
        # Rewind body position, if needed. Record current position
        # for future rewinds in the event of a redirect/retry.
        body_pos = set_file_position(body, body_pos)
    
        try:
            # Request a connection from the queue.
            timeout_obj = self._get_timeout(timeout)
            conn = self._get_conn(timeout=pool_timeout)
    
            conn.timeout = timeout_obj.connect_timeout
    
            is_new_proxy_conn = self.proxy is not None and not getattr(
                conn, &#34;sock&#34;, None
            )
            if is_new_proxy_conn and http_tunnel_required:
                self._prepare_proxy(conn)
    
            # Make the request on the httplib connection object.
            httplib_response = self._make_request(
                conn,
                method,
                url,
                timeout=timeout_obj,
                body=body,
                headers=headers,
                chunked=chunked,
            )
    
            # If we&#39;re going to release the connection in ``finally:``, then
            # the response doesn&#39;t need to know about the connection. Otherwise
            # it will also try to release it and we&#39;ll have a double-release
            # mess.
            response_conn = conn if not release_conn else None
    
            # Pass method to Response for length checking
            response_kw[&#34;request_method&#34;] = method
    
            # Import httplib&#39;s response into our own wrapper object
            response = self.ResponseCls.from_httplib(
                httplib_response,
                pool=self,
                connection=response_conn,
                retries=retries,
                **response_kw
            )
    
            # Everything went great!
            clean_exit = True
    
        except EmptyPoolError:
            # Didn&#39;t get a connection from the pool, no need to clean up
            clean_exit = True
            release_this_conn = False
            raise
    
        except (
            TimeoutError,
            HTTPException,
            SocketError,
            ProtocolError,
            BaseSSLError,
            SSLError,
            CertificateError,
        ) as e:
            # Discard the connection for these exceptions. It will be
            # replaced during the next _get_conn() call.
            clean_exit = False
    
            def _is_ssl_error_message_from_http_proxy(ssl_error):
                # We&#39;re trying to detect the message &#39;WRONG_VERSION_NUMBER&#39; but
                # SSLErrors are kinda all over the place when it comes to the message,
                # so we try to cover our bases here!
                message = &#34; &#34;.join(re.split(&#34;[^a-z]&#34;, str(ssl_error).lower()))
                return (
                    &#34;wrong version number&#34; in message or &#34;unknown protocol&#34; in message
                )
    
            # Try to detect a common user error with proxies which is to
            # set an HTTP proxy to be HTTPS when it should be &#39;http://&#39;
            # (ie {&#39;http&#39;: &#39;http://proxy&#39;, &#39;https&#39;: &#39;https://proxy&#39;})
            # Instead we add a nice error message and point to a URL.
            if (
                isinstance(e, BaseSSLError)
                and self.proxy
                and _is_ssl_error_message_from_http_proxy(e)
                and conn.proxy
                and conn.proxy.scheme == &#34;https&#34;
            ):
                e = ProxyError(
                    &#34;Your proxy appears to only use HTTP and not HTTPS, &#34;
                    &#34;try changing your proxy URL to be HTTP. See: &#34;
                    &#34;https://urllib3.readthedocs.io/en/1.26.x/advanced-usage.html&#34;
                    &#34;#https-proxy-error-http-proxy&#34;,
                    SSLError(e),
                )
            elif isinstance(e, (BaseSSLError, CertificateError)):
                e = SSLError(e)
            elif isinstance(e, (SocketError, NewConnectionError)) and self.proxy:
                e = ProxyError(&#34;Cannot connect to proxy.&#34;, e)
            elif isinstance(e, (SocketError, HTTPException)):
                e = ProtocolError(&#34;Connection aborted.&#34;, e)
    
            retries = retries.increment(
                method, url, error=e, _pool=self, _stacktrace=sys.exc_info()[2]
            )
            retries.sleep()
    
            # Keep track of the error for the retry warning.
            err = e
    
        finally:
            if not clean_exit:
                # We hit some kind of exception, handled or otherwise. We need
                # to throw the connection away unless explicitly told not to.
                # Close the connection, set the variable to None, and make sure
                # we put the None back in the pool to avoid leaking it.
                conn = conn and conn.close()
                release_this_conn = True
    
            if release_this_conn:
                # Put the connection back to be reused. If the connection is
                # expired then it will be None, which will get replaced with a
                # fresh connection during _get_conn.
                self._put_conn(conn)
    
        if not conn:
            # Try again
            log.warning(
                &#34;Retrying (%r) after connection broken by &#39;%r&#39;: %s&#34;, retries, err, url
            )
            return self.urlopen(
                method,
                url,
                body,
                headers,
                retries,
                redirect,
                assert_same_host,
                timeout=timeout,
                pool_timeout=pool_timeout,
                release_conn=release_conn,
                chunked=chunked,
                body_pos=body_pos,
                **response_kw
            )
    
        # Handle redirect?
        redirect_location = redirect and response.get_redirect_location()
        if redirect_location:
            if response.status == 303:
                method = &#34;GET&#34;
    
            try:
                retries = retries.increment(method, url, response=response, _pool=self)
            except MaxRetryError:
                if retries.raise_on_redirect:
                    response.drain_conn()
                    raise
                return response
    
            response.drain_conn()
            retries.sleep_for_retry(response)
            log.debug(&#34;Redirecting %s -&gt; %s&#34;, url, redirect_location)
            return self.urlopen(
                method,
                redirect_location,
                body,
                headers,
                retries=retries,
                redirect=redirect,
                assert_same_host=assert_same_host,
                timeout=timeout,
                pool_timeout=pool_timeout,
                release_conn=release_conn,
                chunked=chunked,
                body_pos=body_pos,
                **response_kw
            )
    
        # Check if we should retry the HTTP response.
        has_retry_after = bool(response.getheader(&#34;Retry-After&#34;))
        if retries.is_retry(method, response.status, has_retry_after):
            try:
                retries = retries.increment(method, url, response=response, _pool=self)
            except MaxRetryError:
                if retries.raise_on_status:
                    response.drain_conn()
                    raise
                return response
    
            response.drain_conn()
            retries.sleep(response)
            log.debug(&#34;Retry: %s&#34;, url)
&gt;           return self.urlopen(
                method,
                url,
                body,
                headers,
                retries=retries,
                redirect=redirect,
                assert_same_host=assert_same_host,
                timeout=timeout,
                pool_timeout=pool_timeout,
                release_conn=release_conn,
                chunked=chunked,
                body_pos=body_pos,
                **response_kw
            )

/usr/local/lib/python3.8/site-packages/urllib3/connectionpool.py:878: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connectionpool.HTTPSConnectionPool object at 0x7f34bbe08250&gt;
method = &#39;GET&#39;
url = &#39;/api1/x3/erp/QAL/XBODC?representation=XBODC.%24query&amp;count=50&amp;orderBy=UPDDATTIM%20desc&#39;
body = None
headers = {&#39;User-Agent&#39;: &#39;python-requests/2.28.1&#39;, &#39;Accept-Encoding&#39;: &#39;gzip, deflate&#39;, &#39;Accept&#39;: &#39;*/*&#39;, &#39;Connection&#39;: &#39;keep-alive&#39;, &#39;Content-Type&#39;: &#39;application/json&#39;, &#39;Authorization&#39;: &#39;Basic aW50cmFjbzpXYXNzaW1Db3ZhZ2VA&#39;}
retries = Retry(total=0, connect=None, read=None, redirect=None, status=None)
redirect = False, assert_same_host = False
timeout = Timeout(connect=None, read=None, total=None), pool_timeout = None
release_conn = False, chunked = False, body_pos = None
response_kw = {&#39;decode_content&#39;: False, &#39;preload_content&#39;: False, &#39;request_method&#39;: &#39;GET&#39;}
parsed_url = Url(scheme=None, auth=None, host=None, port=None, path=&#39;/api1/x3/erp/QAL/XBODC&#39;, query=&#39;representation=XBODC.%24query&amp;count=50&amp;orderBy=UPDDATTIM%20desc&#39;, fragment=None)
destination_scheme = None
conn = &lt;urllib3.connection.HTTPSConnection object at 0x7f34bbc44b80&gt;
release_this_conn = False, http_tunnel_required = True, err = None
clean_exit = True

    def urlopen(
        self,
        method,
        url,
        body=None,
        headers=None,
        retries=None,
        redirect=True,
        assert_same_host=True,
        timeout=_Default,
        pool_timeout=None,
        release_conn=None,
        chunked=False,
        body_pos=None,
        **response_kw
    ):
        &#34;&#34;&#34;
        Get a connection from the pool and perform an HTTP request. This is the
        lowest level call for making a request, so you&#39;ll need to specify all
        the raw details.
    
        .. note::
    
           More commonly, it&#39;s appropriate to use a convenience method provided
           by :class:`.RequestMethods`, such as :meth:`request`.
    
        .. note::
    
           `release_conn` will only behave as expected if
           `preload_content=False` because we want to make
           `preload_content=False` the default behaviour someday soon without
           breaking backwards compatibility.
    
        :param method:
            HTTP request method (such as GET, POST, PUT, etc.)
    
        :param url:
            The URL to perform the request on.
    
        :param body:
            Data to send in the request body, either :class:`str`, :class:`bytes`,
            an iterable of :class:`str`/:class:`bytes`, or a file-like object.
    
        :param headers:
            Dictionary of custom headers to send, such as User-Agent,
            If-None-Match, etc. If None, pool headers are used. If provided,
            these headers completely replace any pool-specific headers.
    
        :param retries:
            Configure the number of retries to allow before raising a
            :class:`~urllib3.exceptions.MaxRetryError` exception.
    
            Pass ``None`` to retry until you receive a response. Pass a
            :class:`~urllib3.util.retry.Retry` object for fine-grained control
            over different types of retries.
            Pass an integer number to retry connection errors that many times,
            but no other types of errors. Pass zero to never retry.
    
            If ``False``, then retries are disabled and any exception is raised
            immediately. Also, instead of raising a MaxRetryError on redirects,
            the redirect response will be returned.
    
        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.
    
        :param redirect:
            If True, automatically handle redirects (status codes 301, 302,
            303, 307, 308). Each redirect counts as a retry. Disabling retries
            will disable redirect, too.
    
        :param assert_same_host:
            If ``True``, will make sure that the host of the pool requests is
            consistent else will raise HostChangedError. When ``False``, you can
            use the pool on an HTTP proxy and request foreign hosts.
    
        :param timeout:
            If specified, overrides the default timeout for this one
            request. It may be a float (in seconds) or an instance of
            :class:`urllib3.util.Timeout`.
    
        :param pool_timeout:
            If set and the pool is set to block=True, then this method will
            block for ``pool_timeout`` seconds and raise EmptyPoolError if no
            connection is available within the time period.
    
        :param release_conn:
            If False, then the urlopen call will not release the connection
            back into the pool once a response is received (but will release if
            you read the entire contents of the response such as when
            `preload_content=True`). This is useful if you&#39;re not preloading
            the response&#39;s content immediately. You will need to call
            ``r.release_conn()`` on the response ``r`` to return the connection
            back into the pool. If None, it takes the value of
            ``response_kw.get(&#39;preload_content&#39;, True)``.
    
        :param chunked:
            If True, urllib3 will send the body using chunked transfer
            encoding. Otherwise, urllib3 will send the body using the standard
            content-length form. Defaults to False.
    
        :param int body_pos:
            Position to seek to in file-like body in the event of a retry or
            redirect. Typically this won&#39;t need to be set because urllib3 will
            auto-populate the value when needed.
    
        :param \\**response_kw:
            Additional parameters are passed to
            :meth:`urllib3.response.HTTPResponse.from_httplib`
        &#34;&#34;&#34;
    
        parsed_url = parse_url(url)
        destination_scheme = parsed_url.scheme
    
        if headers is None:
            headers = self.headers
    
        if not isinstance(retries, Retry):
            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)
    
        if release_conn is None:
            release_conn = response_kw.get(&#34;preload_content&#34;, True)
    
        # Check host
        if assert_same_host and not self.is_same_host(url):
            raise HostChangedError(self, url, retries)
    
        # Ensure that the URL we&#39;re connecting to is properly encoded
        if url.startswith(&#34;/&#34;):
            url = six.ensure_str(_encode_target(url))
        else:
            url = six.ensure_str(parsed_url.url)
    
        conn = None
    
        # Track whether `conn` needs to be released before
        # returning/raising/recursing. Update this variable if necessary, and
        # leave `release_conn` constant throughout the function. That way, if
        # the function recurses, the original value of `release_conn` will be
        # passed down into the recursive call, and its value will be respected.
        #
        # See issue #651 [1] for details.
        #
        # [1] &lt;https://github.com/urllib3/urllib3/issues/651&gt;
        release_this_conn = release_conn
    
        http_tunnel_required = connection_requires_http_tunnel(
            self.proxy, self.proxy_config, destination_scheme
        )
    
        # Merge the proxy headers. Only done when not using HTTP CONNECT. We
        # have to copy the headers dict so we can safely change it without those
        # changes being reflected in anyone else&#39;s copy.
        if not http_tunnel_required:
            headers = headers.copy()
            headers.update(self.proxy_headers)
    
        # Must keep the exception bound to a separate variable or else Python 3
        # complains about UnboundLocalError.
        err = None
    
        # Keep track of whether we cleanly exited the except block. This
        # ensures we do proper cleanup in finally.
        clean_exit = False
    
        # Rewind body position, if needed. Record current position
        # for future rewinds in the event of a redirect/retry.
        body_pos = set_file_position(body, body_pos)
    
        try:
            # Request a connection from the queue.
            timeout_obj = self._get_timeout(timeout)
            conn = self._get_conn(timeout=pool_timeout)
    
            conn.timeout = timeout_obj.connect_timeout
    
            is_new_proxy_conn = self.proxy is not None and not getattr(
                conn, &#34;sock&#34;, None
            )
            if is_new_proxy_conn and http_tunnel_required:
                self._prepare_proxy(conn)
    
            # Make the request on the httplib connection object.
            httplib_response = self._make_request(
                conn,
                method,
                url,
                timeout=timeout_obj,
                body=body,
                headers=headers,
                chunked=chunked,
            )
    
            # If we&#39;re going to release the connection in ``finally:``, then
            # the response doesn&#39;t need to know about the connection. Otherwise
            # it will also try to release it and we&#39;ll have a double-release
            # mess.
            response_conn = conn if not release_conn else None
    
            # Pass method to Response for length checking
            response_kw[&#34;request_method&#34;] = method
    
            # Import httplib&#39;s response into our own wrapper object
            response = self.ResponseCls.from_httplib(
                httplib_response,
                pool=self,
                connection=response_conn,
                retries=retries,
                **response_kw
            )
    
            # Everything went great!
            clean_exit = True
    
        except EmptyPoolError:
            # Didn&#39;t get a connection from the pool, no need to clean up
            clean_exit = True
            release_this_conn = False
            raise
    
        except (
            TimeoutError,
            HTTPException,
            SocketError,
            ProtocolError,
            BaseSSLError,
            SSLError,
            CertificateError,
        ) as e:
            # Discard the connection for these exceptions. It will be
            # replaced during the next _get_conn() call.
            clean_exit = False
    
            def _is_ssl_error_message_from_http_proxy(ssl_error):
                # We&#39;re trying to detect the message &#39;WRONG_VERSION_NUMBER&#39; but
                # SSLErrors are kinda all over the place when it comes to the message,
                # so we try to cover our bases here!
                message = &#34; &#34;.join(re.split(&#34;[^a-z]&#34;, str(ssl_error).lower()))
                return (
                    &#34;wrong version number&#34; in message or &#34;unknown protocol&#34; in message
                )
    
            # Try to detect a common user error with proxies which is to
            # set an HTTP proxy to be HTTPS when it should be &#39;http://&#39;
            # (ie {&#39;http&#39;: &#39;http://proxy&#39;, &#39;https&#39;: &#39;https://proxy&#39;})
            # Instead we add a nice error message and point to a URL.
            if (
                isinstance(e, BaseSSLError)
                and self.proxy
                and _is_ssl_error_message_from_http_proxy(e)
                and conn.proxy
                and conn.proxy.scheme == &#34;https&#34;
            ):
                e = ProxyError(
                    &#34;Your proxy appears to only use HTTP and not HTTPS, &#34;
                    &#34;try changing your proxy URL to be HTTP. See: &#34;
                    &#34;https://urllib3.readthedocs.io/en/1.26.x/advanced-usage.html&#34;
                    &#34;#https-proxy-error-http-proxy&#34;,
                    SSLError(e),
                )
            elif isinstance(e, (BaseSSLError, CertificateError)):
                e = SSLError(e)
            elif isinstance(e, (SocketError, NewConnectionError)) and self.proxy:
                e = ProxyError(&#34;Cannot connect to proxy.&#34;, e)
            elif isinstance(e, (SocketError, HTTPException)):
                e = ProtocolError(&#34;Connection aborted.&#34;, e)
    
            retries = retries.increment(
                method, url, error=e, _pool=self, _stacktrace=sys.exc_info()[2]
            )
            retries.sleep()
    
            # Keep track of the error for the retry warning.
            err = e
    
        finally:
            if not clean_exit:
                # We hit some kind of exception, handled or otherwise. We need
                # to throw the connection away unless explicitly told not to.
                # Close the connection, set the variable to None, and make sure
                # we put the None back in the pool to avoid leaking it.
                conn = conn and conn.close()
                release_this_conn = True
    
            if release_this_conn:
                # Put the connection back to be reused. If the connection is
                # expired then it will be None, which will get replaced with a
                # fresh connection during _get_conn.
                self._put_conn(conn)
    
        if not conn:
            # Try again
            log.warning(
                &#34;Retrying (%r) after connection broken by &#39;%r&#39;: %s&#34;, retries, err, url
            )
            return self.urlopen(
                method,
                url,
                body,
                headers,
                retries,
                redirect,
                assert_same_host,
                timeout=timeout,
                pool_timeout=pool_timeout,
                release_conn=release_conn,
                chunked=chunked,
                body_pos=body_pos,
                **response_kw
            )
    
        # Handle redirect?
        redirect_location = redirect and response.get_redirect_location()
        if redirect_location:
            if response.status == 303:
                method = &#34;GET&#34;
    
            try:
                retries = retries.increment(method, url, response=response, _pool=self)
            except MaxRetryError:
                if retries.raise_on_redirect:
                    response.drain_conn()
                    raise
                return response
    
            response.drain_conn()
            retries.sleep_for_retry(response)
            log.debug(&#34;Redirecting %s -&gt; %s&#34;, url, redirect_location)
            return self.urlopen(
                method,
                redirect_location,
                body,
                headers,
                retries=retries,
                redirect=redirect,
                assert_same_host=assert_same_host,
                timeout=timeout,
                pool_timeout=pool_timeout,
                release_conn=release_conn,
                chunked=chunked,
                body_pos=body_pos,
                **response_kw
            )
    
        # Check if we should retry the HTTP response.
        has_retry_after = bool(response.getheader(&#34;Retry-After&#34;))
        if retries.is_retry(method, response.status, has_retry_after):
            try:
&gt;               retries = retries.increment(method, url, response=response, _pool=self)

/usr/local/lib/python3.8/site-packages/urllib3/connectionpool.py:868: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Retry(total=0, connect=None, read=None, redirect=None, status=None)
method = &#39;GET&#39;
url = &#39;/api1/x3/erp/QAL/XBODC?representation=XBODC.%24query&amp;count=50&amp;orderBy=UPDDATTIM%20desc&#39;
response = &lt;urllib3.response.HTTPResponse object at 0x7f34bbd55280&gt;
error = None
_pool = &lt;urllib3.connectionpool.HTTPSConnectionPool object at 0x7f34bbe08250&gt;
_stacktrace = None

    def increment(
        self,
        method=None,
        url=None,
        response=None,
        error=None,
        _pool=None,
        _stacktrace=None,
    ):
        &#34;&#34;&#34;Return a new Retry object with incremented retry counters.
    
        :param response: A response object, or None, if the server did not
            return a response.
        :type response: :class:`~urllib3.response.HTTPResponse`
        :param Exception error: An error encountered during the request, or
            None if the response was received successfully.
    
        :return: A new ``Retry`` object.
        &#34;&#34;&#34;
        if self.total is False and error:
            # Disabled, indicate to re-raise the error.
            raise six.reraise(type(error), error, _stacktrace)
    
        total = self.total
        if total is not None:
            total -= 1
    
        connect = self.connect
        read = self.read
        redirect = self.redirect
        status_count = self.status
        other = self.other
        cause = &#34;unknown&#34;
        status = None
        redirect_location = None
    
        if error and self._is_connection_error(error):
            # Connect retry?
            if connect is False:
                raise six.reraise(type(error), error, _stacktrace)
            elif connect is not None:
                connect -= 1
    
        elif error and self._is_read_error(error):
            # Read retry?
            if read is False or not self._is_method_retryable(method):
                raise six.reraise(type(error), error, _stacktrace)
            elif read is not None:
                read -= 1
    
        elif error:
            # Other retry?
            if other is not None:
                other -= 1
    
        elif response and response.get_redirect_location():
            # Redirect retry?
            if redirect is not None:
                redirect -= 1
            cause = &#34;too many redirects&#34;
            redirect_location = response.get_redirect_location()
            status = response.status
    
        else:
            # Incrementing because of a server error like a 500 in
            # status_forcelist and the given method is in the allowed_methods
            cause = ResponseError.GENERIC_ERROR
            if response and response.status:
                if status_count is not None:
                    status_count -= 1
                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)
                status = response.status
    
        history = self.history + (
            RequestHistory(method, url, error, status, redirect_location),
        )
    
        new_retry = self.new(
            total=total,
            connect=connect,
            read=read,
            redirect=redirect,
            status=status_count,
            other=other,
            history=history,
        )
    
        if new_retry.is_exhausted():
&gt;           raise MaxRetryError(_pool, url, error or ResponseError(cause))
E           urllib3.exceptions.MaxRetryError: HTTPSConnectionPool(host=&#39;sagex3-horsprod.covage.com&#39;, port=443): Max retries exceeded with url: /api1/x3/erp/QAL/XBODC?representation=XBODC.%24query&amp;count=50&amp;orderBy=UPDDATTIM%20desc (Caused by ResponseError(&#39;too many 502 error responses&#39;))

/usr/local/lib/python3.8/site-packages/urllib3/util/retry.py:592: MaxRetryError

During handling of the above exception, another exception occurred:

x3_client = &lt;x3_wrapper.rest_client.X3RestClient object at 0x7f34bbe085b0&gt;

    @pytest.mark.livetest
    @pytest.mark.xfail
    @pytest.mark.read_data
    def test_x3_schema_query_catalog(x3_client):
        &#34;&#34;&#34;
        Validate catalog schema representation `XBODC` query
        &#34;&#34;&#34;
&gt;       resp = x3_client.list(
            class_name=&#34;XBODC&#34;,
            representation=&#34;XBODC&#34;,
            count=50,
            **{&#34;orderBy&#34;: &#34;UPDDATTIM desc&#34;}
        )

app/api/live_tests/test_catalog/test_query_catalog.py:14: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
app/x3_wrapper/rest_client.py:84: in list
    resp = self._cal_x3(&#34;GET&#34;, url, query_params)
app/x3_wrapper/rest_client.py:70: in _cal_x3
    resp = self.client.request(method, url, params=query_params)
/usr/local/lib/python3.8/site-packages/requests/sessions.py:587: in request
    resp = self.send(prep, **send_kwargs)
/usr/local/lib/python3.8/site-packages/requests/sessions.py:701: in send
    r = adapter.send(request, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;requests.adapters.HTTPAdapter object at 0x7f34bbe08160&gt;
request = &lt;PreparedRequest [GET]&gt;, stream = False
timeout = Timeout(connect=None, read=None, total=None), verify = True
cert = None
proxies = OrderedDict([(&#39;no&#39;, &#39;gitlab-runner-cache-01-prd.nut.covage.com&#39;), (&#39;http&#39;, &#39;http://squid.kosc.net:3128&#39;), (&#39;https&#39;, &#39;http://squid.kosc.net:3128&#39;)])

    def send(
        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None
    ):
        &#34;&#34;&#34;Sends PreparedRequest object. Returns Response object.
    
        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.
        :param stream: (optional) Whether to stream the request content.
        :param timeout: (optional) How long to wait for the server to send
            data before giving up, as a float, or a :ref:`(connect timeout,
            read timeout) &lt;timeouts&gt;` tuple.
        :type timeout: float or tuple or urllib3 Timeout object
        :param verify: (optional) Either a boolean, in which case it controls whether
            we verify the server&#39;s TLS certificate, or a string, in which case it
            must be a path to a CA bundle to use
        :param cert: (optional) Any user-provided SSL certificate to be trusted.
        :param proxies: (optional) The proxies dictionary to apply to the request.
        :rtype: requests.Response
        &#34;&#34;&#34;
    
        try:
            conn = self.get_connection(request.url, proxies)
        except LocationValueError as e:
            raise InvalidURL(e, request=request)
    
        self.cert_verify(conn, request.url, verify, cert)
        url = self.request_url(request, proxies)
        self.add_headers(
            request,
            stream=stream,
            timeout=timeout,
            verify=verify,
            cert=cert,
            proxies=proxies,
        )
    
        chunked = not (request.body is None or &#34;Content-Length&#34; in request.headers)
    
        if isinstance(timeout, tuple):
            try:
                connect, read = timeout
                timeout = TimeoutSauce(connect=connect, read=read)
            except ValueError:
                raise ValueError(
                    f&#34;Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, &#34;
                    f&#34;or a single float to set both timeouts to the same value.&#34;
                )
        elif isinstance(timeout, TimeoutSauce):
            pass
        else:
            timeout = TimeoutSauce(connect=timeout, read=timeout)
    
        try:
            if not chunked:
                resp = conn.urlopen(
                    method=request.method,
                    url=url,
                    body=request.body,
                    headers=request.headers,
                    redirect=False,
                    assert_same_host=False,
                    preload_content=False,
                    decode_content=False,
                    retries=self.max_retries,
                    timeout=timeout,
                )
    
            # Send the request.
            else:
                if hasattr(conn, &#34;proxy_pool&#34;):
                    conn = conn.proxy_pool
    
                low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)
    
                try:
                    skip_host = &#34;Host&#34; in request.headers
                    low_conn.putrequest(
                        request.method,
                        url,
                        skip_accept_encoding=True,
                        skip_host=skip_host,
                    )
    
                    for header, value in request.headers.items():
                        low_conn.putheader(header, value)
    
                    low_conn.endheaders()
    
                    for i in request.body:
                        low_conn.send(hex(len(i))[2:].encode(&#34;utf-8&#34;))
                        low_conn.send(b&#34;\r\n&#34;)
                        low_conn.send(i)
                        low_conn.send(b&#34;\r\n&#34;)
                    low_conn.send(b&#34;0\r\n\r\n&#34;)
    
                    # Receive the response from the server
                    r = low_conn.getresponse()
    
                    resp = HTTPResponse.from_httplib(
                        r,
                        pool=conn,
                        connection=low_conn,
                        preload_content=False,
                        decode_content=False,
                    )
                except Exception:
                    # If we hit any problems here, clean up the connection.
                    # Then, raise so that we can handle the actual exception.
                    low_conn.close()
                    raise
    
        except (ProtocolError, OSError) as err:
            raise ConnectionError(err, request=request)
    
        except MaxRetryError as e:
            if isinstance(e.reason, ConnectTimeoutError):
                # TODO: Remove this in 3.0.0: see #2811
                if not isinstance(e.reason, NewConnectionError):
                    raise ConnectTimeout(e, request=request)
    
            if isinstance(e.reason, ResponseError):
&gt;               raise RetryError(e, request=request)
E               requests.exceptions.RetryError: HTTPSConnectionPool(host=&#39;sagex3-horsprod.covage.com&#39;, port=443): Max retries exceeded with url: /api1/x3/erp/QAL/XBODC?representation=XBODC.%24query&amp;count=50&amp;orderBy=UPDDATTIM%20desc (Caused by ResponseError(&#39;too many 502 error responses&#39;))

/usr/local/lib/python3.8/site-packages/requests/adapters.py:556: RetryError</pre> </div> </div> </details> <details class="phase teardown "> <summary> <h4 class=title> <span class=phase-name>Teardown</span> </h4> </summary> <div class=content> </div> </details> </div> </div> </details> <details class="test xfailed"> <summary> <h3 class="title test-title"> <span class="status badge xfailed ">XFAIL</span> <span class=test-name> <span class=funcname>test_api_list_catalog</span> </span> <span class=duration>0:00:00.739910</span> </h3> </summary> <div class=content> <div class=documentation> <p>Validate api schema representation for route <cite>/catalogs/</cite></p> <p>Validate pagination next_page</p> </div> <table class=metadata> <tr> <th>Started</th> <td>2023-06-30 01:14:42</td> </tr> <tr> <th>Ended</th> <td>2023-06-30 01:14:42</td> </tr> <tr> <th>Duration</th> <td>0:00:00.739910</td> </tr> <tr> <th>Markers</th> <td> <div class=marker> <span class="marker-name badge">read_data</span> <span class=marker-args> </span> </div> <div class=marker> <span class="marker-name badge">xfail</span> <span class=marker-args> </span> </div> <div class=marker> <span class="marker-name badge">livetest</span> <span class=marker-args> </span> </div> </td> </tr> <tr> <th>Fixtures</th> <td> <span class="badge fixturename"> django_test_environment </span> <span class="badge fixturename"> django_db_blocker </span> <span class="badge fixturename"> test_client </span> <span class="badge fixturename"> request </span> </td> </tr> </table> <div class=repr> <pre>AssertionError: b&#39;{&#34;detail&#34;:&#34;Server Error (500)&#34;,&#34;status_code&#34;:500}&#39;
assert 500 == 200
 +  where 500 = &lt;Response [500]&gt;.status_code</pre> </div> <div class=test-phases> <details class="phase setup "> <summary> <h4 class=title> <span class=phase-name>Setup</span> </h4> </summary> <div class=content> </div> </details> <details class="phase call xfailed" open> <summary> <h4 class=title> <span class="status  xfailed"></span> <span class=phase-name>Call</span> </h4> </summary> <div class=content> <div class=repr> <pre>test_client = &lt;conftest.LiveServerSession object at 0x7f34c148e940&gt;

    @pytest.mark.livetest
    @pytest.mark.xfail
    @pytest.mark.read_data
    def test_api_list_catalog(test_client):
        &#34;&#34;&#34;
        Validate api schema representation for route `/catalogs/`\n
        Validate pagination next_page
        &#34;&#34;&#34;
        resp = test_client.get(&#34;/api/v0/catalogs/&#34;)
&gt;       assert resp.status_code == 200, resp.content
E       AssertionError: b&#39;{&#34;detail&#34;:&#34;Server Error (500)&#34;,&#34;status_code&#34;:500}&#39;
E       assert 500 == 200
E        +  where 500 = &lt;Response [500]&gt;.status_code

app/api/live_tests/test_catalog/test_query_catalog.py:32: AssertionError</pre> </div> </div> </details> <details class="phase teardown "> <summary> <h4 class=title> <span class=phase-name>Teardown</span> </h4> </summary> <div class=content> </div> </details> </div> </div> </details> </div> </details> <details class=file> <summary> <h2 class="title file-title"> <span class=fspath> app/api/live_tests/test_contracts/test_activate_contract.py </span> <span class=counts> <span title="1 xfailed" class="count status badge xfailed ">1</span> </span> <span class=duration> 0:00:00.781037 </span> </h2> </summary> <div class="content box"> <details class="test xfailed"> <summary> <h3 class="title test-title"> <span class="status badge xfailed ">XFAIL</span> <span class=test-name> <span class=funcname>test_activate_contract_adsl</span> </span> <span class=duration>0:00:00.781037</span> </h3> </summary> <div class=content> <table class=metadata> <tr> <th>Started</th> <td>2023-06-30 01:14:42</td> </tr> <tr> <th>Ended</th> <td>2023-06-30 01:14:43</td> </tr> <tr> <th>Duration</th> <td>0:00:00.781037</td> </tr> <tr> <th>Markers</th> <td> <div class=marker> <span class="marker-name badge">write_data</span> <span class=marker-args> </span> </div> <div class=marker> <span class="marker-name badge">xfail</span> <span class=marker-args> </span> </div> <div class=marker> <span class="marker-name badge">livetest</span> <span class=marker-args> </span> </div> </td> </tr> <tr> <th>Fixtures</th> <td> <span class="badge fixturename"> django_test_environment </span> <span class="badge fixturename"> django_db_blocker </span> <span class="badge fixturename"> test_client </span> <span class="badge fixturename"> request </span> </td> </tr> </table> <div class=repr> <pre>AssertionError: b&#39;{&#34;detail&#34;:&#34;Server Error (500)&#34;,&#34;status_code&#34;:500}&#39;
assert 500 == 201
 +  where 500 = &lt;Response [500]&gt;.status_code</pre> </div> <div class=test-phases> <details class="phase setup "> <summary> <h4 class=title> <span class=phase-name>Setup</span> </h4> </summary> <div class=content> </div> </details> <details class="phase call xfailed" open> <summary> <h4 class=title> <span class="status  xfailed"></span> <span class=phase-name>Call</span> </h4> </summary> <div class=content> <div class=repr> <pre>test_client = &lt;conftest.LiveServerSession object at 0x7f34c044f760&gt;

    @pytest.mark.livetest
    @pytest.mark.xfail
    @pytest.mark.write_data
    def test_activate_contract_adsl(test_client):
        # Test create ADSL contract not yet enabled
        payload = load_json(&#34;contracts/test_activate_contract_adsl/payload.json&#34;)
        timestamp = datetime.datetime.now().strftime(&#34;%d%H%M%S&#34;)
        soh_num = f&#34;96860_{timestamp}&#34;
        logger.info(soh_num)
        payload[&#34;SOHNUM&#34;] = soh_num
        resp = test_client.post(&#34;/api/v0/contracts/&#34;, json=payload)
&gt;       assert resp.status_code == 201, resp.content
E       AssertionError: b&#39;{&#34;detail&#34;:&#34;Server Error (500)&#34;,&#34;status_code&#34;:500}&#39;
E       assert 500 == 201
E        +  where 500 = &lt;Response [500]&gt;.status_code

app/api/live_tests/test_contracts/test_activate_contract.py:23: AssertionError</pre> </div> <div class=section> <h5 class=section-title>Captured log call</h5> <pre><samp>INFO     pytestDC:test_activate_contract.py:20 96860_30011442</samp></pre> </div> </div> </details> <details class="phase teardown "> <summary> <h4 class=title> <span class=phase-name>Teardown</span> </h4> </summary> <div class=content> </div> </details> </div> </div> </details> </div> </details> <details class=file> <summary> <h2 class="title file-title"> <span class=fspath> app/api/live_tests/test_contracts/test_create_contract.py </span> <span class=counts> <span title="2 xfailed" class="count status badge xfailed ">2</span> </span> <span class=duration> 0:00:01.563202 </span> </h2> </summary> <div class="content box"> <details class="test xfailed"> <summary> <h3 class="title test-title"> <span class="status badge xfailed ">XFAIL</span> <span class=test-name> <span class=funcname>test_create_contract_adsl_not_enabled</span> </span> <span class=duration>0:00:00.780057</span> </h3> </summary> <div class=content> <table class=metadata> <tr> <th>Started</th> <td>2023-06-30 01:14:43</td> </tr> <tr> <th>Ended</th> <td>2023-06-30 01:14:44</td> </tr> <tr> <th>Duration</th> <td>0:00:00.780057</td> </tr> <tr> <th>Markers</th> <td> <div class=marker> <span class="marker-name badge">write_data</span> <span class=marker-args> </span> </div> <div class=marker> <span class="marker-name badge">xfail</span> <span class=marker-args> </span> </div> <div class=marker> <span class="marker-name badge">livetest</span> <span class=marker-args> </span> </div> </td> </tr> <tr> <th>Fixtures</th> <td> <span class="badge fixturename"> django_test_environment </span> <span class="badge fixturename"> django_db_blocker </span> <span class="badge fixturename"> test_client </span> <span class="badge fixturename"> request </span> </td> </tr> </table> <div class=repr> <pre>AssertionError: b&#39;{&#34;detail&#34;:&#34;Server Error (500)&#34;,&#34;status_code&#34;:500}&#39;
assert 500 == 201
 +  where 500 = &lt;Response [500]&gt;.status_code</pre> </div> <div class=test-phases> <details class="phase setup "> <summary> <h4 class=title> <span class=phase-name>Setup</span> </h4> </summary> <div class=content> </div> </details> <details class="phase call xfailed" open> <summary> <h4 class=title> <span class="status  xfailed"></span> <span class=phase-name>Call</span> </h4> </summary> <div class=content> <div class=repr> <pre>test_client = &lt;conftest.LiveServerSession object at 0x7f34c04bb760&gt;

    @pytest.mark.livetest
    @pytest.mark.xfail
    @pytest.mark.write_data
    def test_create_contract_adsl_not_enabled(test_client):
        # Test create ADSL contract not enabled
        payload = load_json(&#34;contracts/adsl_not_enabled/payload.json&#34;)
        timestamp = datetime.datetime.now().strftime(&#34;%d%H%M%S&#34;)
        payload[&#34;SOHNUM&#34;] = f&#34;TEST_{timestamp}&#34;
        logger.info(payload[&#34;SOHNUM&#34;])
        resp = test_client.post(&#34;/api/v0/contracts/&#34;, json=payload)
&gt;       assert resp.status_code == 201, resp.content
E       AssertionError: b&#39;{&#34;detail&#34;:&#34;Server Error (500)&#34;,&#34;status_code&#34;:500}&#39;
E       assert 500 == 201
E        +  where 500 = &lt;Response [500]&gt;.status_code

app/api/live_tests/test_contracts/test_create_contract.py:22: AssertionError</pre> </div> <div class=section> <h5 class=section-title>Captured log call</h5> <pre><samp>INFO     pytestDC:test_create_contract.py:20 TEST_30011443</samp></pre> </div> </div> </details> <details class="phase teardown "> <summary> <h4 class=title> <span class=phase-name>Teardown</span> </h4> </summary> <div class=content> </div> </details> </div> </div> </details> <details class="test xfailed"> <summary> <h3 class="title test-title"> <span class="status badge xfailed ">XFAIL</span> <span class=test-name> <span class=funcname>test_create_contract_adsl_enabled</span> </span> <span class=duration>0:00:00.783144</span> </h3> </summary> <div class=content> <table class=metadata> <tr> <th>Started</th> <td>2023-06-30 01:14:44</td> </tr> <tr> <th>Ended</th> <td>2023-06-30 01:14:45</td> </tr> <tr> <th>Duration</th> <td>0:00:00.783144</td> </tr> <tr> <th>Markers</th> <td> <div class=marker> <span class="marker-name badge">write_data</span> <span class=marker-args> </span> </div> <div class=marker> <span class="marker-name badge">xfail</span> <span class=marker-args> </span> </div> <div class=marker> <span class="marker-name badge">livetest</span> <span class=marker-args> </span> </div> </td> </tr> <tr> <th>Fixtures</th> <td> <span class="badge fixturename"> django_test_environment </span> <span class="badge fixturename"> django_db_blocker </span> <span class="badge fixturename"> test_client </span> <span class="badge fixturename"> request </span> </td> </tr> </table> <div class=repr> <pre>AssertionError: b&#39;{&#34;detail&#34;:&#34;Server Error (500)&#34;,&#34;status_code&#34;:500}&#39;
assert 500 == 201
 +  where 500 = &lt;Response [500]&gt;.status_code</pre> </div> <div class=test-phases> <details class="phase setup "> <summary> <h4 class=title> <span class=phase-name>Setup</span> </h4> </summary> <div class=content> </div> </details> <details class="phase call xfailed" open> <summary> <h4 class=title> <span class="status  xfailed"></span> <span class=phase-name>Call</span> </h4> </summary> <div class=content> <div class=repr> <pre>test_client = &lt;conftest.LiveServerSession object at 0x7f34c0e38880&gt;

    @pytest.mark.livetest
    @pytest.mark.xfail
    @pytest.mark.write_data
    def test_create_contract_adsl_enabled(test_client):
        # Test create ADSL contract with a service enabled
        payload = load_json(&#34;contracts/adsl_enabled/payload.json&#34;)
        timestamp = datetime.datetime.now().strftime(&#34;%d%H%M%S&#34;)
        payload[&#34;SOHNUM&#34;] = f&#34;TEST_{timestamp}&#34;
        payload[&#34;YRDSREF&#34;] = f&#34;S_{timestamp}&#34;
        resp = test_client.post(&#34;/api/v0/contracts/&#34;, json=payload)
&gt;       assert resp.status_code == 201, resp.content
E       AssertionError: b&#39;{&#34;detail&#34;:&#34;Server Error (500)&#34;,&#34;status_code&#34;:500}&#39;
E       assert 500 == 201
E        +  where 500 = &lt;Response [500]&gt;.status_code

app/api/live_tests/test_contracts/test_create_contract.py:57: AssertionError</pre> </div> </div> </details> <details class="phase teardown "> <summary> <h4 class=title> <span class=phase-name>Teardown</span> </h4> </summary> <div class=content> </div> </details> </div> </div> </details> </div> </details> <details class=file> <summary> <h2 class="title file-title"> <span class=fspath> app/api/live_tests/test_contracts/test_detail_contract.py </span> <span class=counts> <span title="3 xfailed" class="count status badge xfailed ">3</span> </span> <span class=duration> 0:00:02.314249 </span> </h2> </summary> <div class="content box"> <details class="test xfailed"> <summary> <h3 class="title test-title"> <span class="status badge xfailed ">XFAIL</span> <span class=test-name> <span class=funcname>test_x3_schema_details_contract</span> </span> <span class=duration>0:00:00.727518</span> </h3> </summary> <div class=content> <div class=documentation> <p>Validate X3 contract schema representation <cite>XSORDERW</cite> details</p> </div> <table class=metadata> <tr> <th>Started</th> <td>2023-06-30 01:14:45</td> </tr> <tr> <th>Ended</th> <td>2023-06-30 01:14:45</td> </tr> <tr> <th>Duration</th> <td>0:00:00.727518</td> </tr> <tr> <th>Markers</th> <td> <div class=marker> <span class="marker-name badge">read_data</span> <span class=marker-args> </span> </div> <div class=marker> <span class="marker-name badge">xfail</span> <span class=marker-args> </span> </div> <div class=marker> <span class="marker-name badge">livetest</span> <span class=marker-args> </span> </div> </td> </tr> <tr> <th>Fixtures</th> <td> <span class="badge fixturename"> django_test_environment </span> <span class="badge fixturename"> django_db_blocker </span> <span class="badge fixturename"> test_client </span> <span class="badge fixturename"> x3_client </span> <span class="badge fixturename"> request </span> </td> </tr> </table> <div class=repr> <pre>AssertionError: b&#39;{&#34;detail&#34;:&#34;Server Error (500)&#34;,&#34;status_code&#34;:500}&#39;
assert 500 == 200
 +  where 500 = &lt;Response [500]&gt;.status_code</pre> </div> <div class=test-phases> <details class="phase setup "> <summary> <h4 class=title> <span class=phase-name>Setup</span> </h4> </summary> <div class=content> </div> </details> <details class="phase call xfailed" open> <summary> <h4 class=title> <span class="status  xfailed"></span> <span class=phase-name>Call</span> </h4> </summary> <div class=content> <div class=repr> <pre>test_client = &lt;conftest.LiveServerSession object at 0x7f34c14ea130&gt;
x3_client = &lt;x3_wrapper.rest_client.X3RestClient object at 0x7f34c14ea580&gt;

    @pytest.mark.livetest
    @pytest.mark.xfail
    @pytest.mark.read_data
    def test_x3_schema_details_contract(test_client, x3_client):
        &#34;&#34;&#34;Validate X3 contract schema representation `XSORDERW` details&#34;&#34;&#34;
&gt;       soh_num = get_random_contract_ref(test_client)

app/api/live_tests/test_contracts/test_detail_contract.py:26: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

test_client = &lt;conftest.LiveServerSession object at 0x7f34c14ea130&gt;

    def get_random_contract_ref(test_client):
        params = {
            &#34;order_by&#34;: &#34;UPDDATTIM desc&#34;,
        }
        resp = test_client.get(&#34;/api/v0/contracts/&#34;, params=params)
&gt;       assert resp.status_code == 200, resp.content
E       AssertionError: b&#39;{&#34;detail&#34;:&#34;Server Error (500)&#34;,&#34;status_code&#34;:500}&#39;
E       assert 500 == 200
E        +  where 500 = &lt;Response [500]&gt;.status_code

app/api/live_tests/test_contracts/test_detail_contract.py:17: AssertionError</pre> </div> </div> </details> <details class="phase teardown "> <summary> <h4 class=title> <span class=phase-name>Teardown</span> </h4> </summary> <div class=content> </div> </details> </div> </div> </details> <details class="test xfailed"> <summary> <h3 class="title test-title"> <span class="status badge xfailed ">XFAIL</span> <span class=test-name> <span class=funcname>test_api_schema_details_contracts</span> </span> <span class=duration>0:00:00.726918</span> </h3> </summary> <div class=content> <div class=documentation> <p>Validate api response schema for route <cite>/contracts/:sohnum</cite></p> </div> <table class=metadata> <tr> <th>Started</th> <td>2023-06-30 01:14:45</td> </tr> <tr> <th>Ended</th> <td>2023-06-30 01:14:46</td> </tr> <tr> <th>Duration</th> <td>0:00:00.726918</td> </tr> <tr> <th>Markers</th> <td> <div class=marker> <span class="marker-name badge">read_data</span> <span class=marker-args> </span> </div> <div class=marker> <span class="marker-name badge">xfail</span> <span class=marker-args> </span> </div> <div class=marker> <span class="marker-name badge">livetest</span> <span class=marker-args> </span> </div> </td> </tr> <tr> <th>Fixtures</th> <td> <span class="badge fixturename"> django_test_environment </span> <span class="badge fixturename"> django_db_blocker </span> <span class="badge fixturename"> test_client </span> <span class="badge fixturename"> request </span> </td> </tr> </table> <div class=repr> <pre>AssertionError: b&#39;{&#34;detail&#34;:&#34;Server Error (500)&#34;,&#34;status_code&#34;:500}&#39;
assert 500 == 200
 +  where 500 = &lt;Response [500]&gt;.status_code</pre> </div> <div class=test-phases> <details class="phase setup "> <summary> <h4 class=title> <span class=phase-name>Setup</span> </h4> </summary> <div class=content> </div> </details> <details class="phase call xfailed" open> <summary> <h4 class=title> <span class="status  xfailed"></span> <span class=phase-name>Call</span> </h4> </summary> <div class=content> <div class=repr> <pre>test_client = &lt;conftest.LiveServerSession object at 0x7f34c04d3460&gt;

    @pytest.mark.livetest
    @pytest.mark.xfail
    @pytest.mark.read_data
    def test_api_schema_details_contracts(test_client):
        &#34;&#34;&#34;Validate api response schema for route `/contracts/:sohnum`&#34;&#34;&#34;
&gt;       soh_num = get_random_contract_ref(test_client)

app/api/live_tests/test_contracts/test_detail_contract.py:42: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

test_client = &lt;conftest.LiveServerSession object at 0x7f34c04d3460&gt;

    def get_random_contract_ref(test_client):
        params = {
            &#34;order_by&#34;: &#34;UPDDATTIM desc&#34;,
        }
        resp = test_client.get(&#34;/api/v0/contracts/&#34;, params=params)
&gt;       assert resp.status_code == 200, resp.content
E       AssertionError: b&#39;{&#34;detail&#34;:&#34;Server Error (500)&#34;,&#34;status_code&#34;:500}&#39;
E       assert 500 == 200
E        +  where 500 = &lt;Response [500]&gt;.status_code

app/api/live_tests/test_contracts/test_detail_contract.py:17: AssertionError</pre> </div> </div> </details> <details class="phase teardown "> <summary> <h4 class=title> <span class=phase-name>Teardown</span> </h4> </summary> <div class=content> </div> </details> </div> </div> </details> <details class="test xfailed"> <summary> <h3 class="title test-title"> <span class="status badge xfailed ">XFAIL</span> <span class=test-name> <span class=funcname>test_api_details_contracts_empty_items</span> </span> <span class=duration>0:00:00.859812</span> </h3> </summary> <div class=content> <div class=documentation> <p>Validate api response schema for route <cite>/contracts/:sohnum</cite> with empty items list</p> </div> <table class=metadata> <tr> <th>Started</th> <td>2023-06-30 01:14:46</td> </tr> <tr> <th>Ended</th> <td>2023-06-30 01:14:47</td> </tr> <tr> <th>Duration</th> <td>0:00:00.859812</td> </tr> <tr> <th>Markers</th> <td> <div class=marker> <span class="marker-name badge">read_data</span> <span class=marker-args> </span> </div> <div class=marker> <span class="marker-name badge">xfail</span> <span class=marker-args> </span> </div> <div class=marker> <span class="marker-name badge">livetest</span> <span class=marker-args> </span> </div> </td> </tr> <tr> <th>Fixtures</th> <td> <span class="badge fixturename"> django_test_environment </span> <span class="badge fixturename"> django_db_blocker </span> <span class="badge fixturename"> test_client </span> <span class="badge fixturename"> request </span> </td> </tr> </table> <div class=repr> <pre>AssertionError: b&#39;{&#34;detail&#34;:&#34;Server Error (500)&#34;,&#34;status_code&#34;:500}&#39;
assert 500 == 200
 +  where 500 = &lt;Response [500]&gt;.status_code</pre> </div> <div class=test-phases> <details class="phase setup "> <summary> <h4 class=title> <span class=phase-name>Setup</span> </h4> </summary> <div class=content> </div> </details> <details class="phase call xfailed" open> <summary> <h4 class=title> <span class="status  xfailed"></span> <span class=phase-name>Call</span> </h4> </summary> <div class=content> <div class=repr> <pre>test_client = &lt;conftest.LiveServerSession object at 0x7f34c1558a00&gt;

    @pytest.mark.livetest
    @pytest.mark.xfail
    @pytest.mark.read_data
    def test_api_details_contracts_empty_items(test_client):
        &#34;&#34;&#34;Validate api response schema for route `/contracts/:sohnum` with empty items list&#34;&#34;&#34;
        soh_num = (
            &#34;EMPTY_ARTICLES&#34;  # Contract with empty articles list, available on DEV2 and QAL
        )
        logger.info(f&#34;SOHNUM: {soh_num}&#34;)
        resp = test_client.get(f&#34;/api/v0/contracts/{soh_num}/&#34;)
&gt;       assert resp.status_code == 200, resp.content
E       AssertionError: b&#39;{&#34;detail&#34;:&#34;Server Error (500)&#34;,&#34;status_code&#34;:500}&#39;
E       assert 500 == 200
E        +  where 500 = &lt;Response [500]&gt;.status_code

app/api/live_tests/test_contracts/test_detail_contract.py:59: AssertionError</pre> </div> <div class=section> <h5 class=section-title>Captured log call</h5> <pre><samp>INFO     pytestDC:test_detail_contract.py:57 SOHNUM: EMPTY_ARTICLES</samp></pre> </div> </div> </details> <details class="phase teardown "> <summary> <h4 class=title> <span class=phase-name>Teardown</span> </h4> </summary> <div class=content> </div> </details> </div> </div> </details> </div> </details> <details class=file> <summary> <h2 class="title file-title"> <span class=fspath> app/api/live_tests/test_contracts/test_modify_option_activated_contract.py </span> <span class=counts> <span title="1 xfailed" class="count status badge xfailed ">1</span> </span> <span class=duration> 0:00:00.790532 </span> </h2> </summary> <div class="content box"> <details class="test xfailed"> <summary> <h3 class="title test-title"> <span class="status badge xfailed ">XFAIL</span> <span class=test-name> <span class=funcname>test_modify_option_activated_contract_adsl</span> </span> <span class=duration>0:00:00.790532</span> </h3> </summary> <div class=content> <table class=metadata> <tr> <th>Started</th> <td>2023-06-30 01:14:47</td> </tr> <tr> <th>Ended</th> <td>2023-06-30 01:14:48</td> </tr> <tr> <th>Duration</th> <td>0:00:00.790532</td> </tr> <tr> <th>Markers</th> <td> <div class=marker> <span class="marker-name badge">write_data</span> <span class=marker-args> </span> </div> <div class=marker> <span class="marker-name badge">xfail</span> <span class=marker-args> </span> </div> <div class=marker> <span class="marker-name badge">livetest</span> <span class=marker-args> </span> </div> </td> </tr> <tr> <th>Fixtures</th> <td> <span class="badge fixturename"> django_test_environment </span> <span class="badge fixturename"> django_db_blocker </span> <span class="badge fixturename"> test_client </span> <span class="badge fixturename"> request </span> </td> </tr> </table> <div class=repr> <pre>AssertionError: b&#39;{&#34;detail&#34;:&#34;Server Error (500)&#34;,&#34;status_code&#34;:500}&#39;
assert 500 == 201
 +  where 500 = &lt;Response [500]&gt;.status_code</pre> </div> <div class=test-phases> <details class="phase setup "> <summary> <h4 class=title> <span class=phase-name>Setup</span> </h4> </summary> <div class=content> </div> </details> <details class="phase call xfailed" open> <summary> <h4 class=title> <span class="status  xfailed"></span> <span class=phase-name>Call</span> </h4> </summary> <div class=content> <div class=repr> <pre>test_client = &lt;conftest.LiveServerSession object at 0x7f34c04c56a0&gt;

    @pytest.mark.livetest
    @pytest.mark.xfail
    @pytest.mark.write_data
    def test_modify_option_activated_contract_adsl(test_client):
        # Create ADSL contract enabled (parent item 1286) and items
        # [ (1, normal), (206, normal), (245, normal), (915, variante) ]
        payload = load_json(
            &#34;contracts/test_modify_option_activated_contract_adsl/payload.json&#34;
        )
        timestamp = datetime.datetime.now().strftime(&#34;%d%H%M%S&#34;)
        soh_num = f&#34;PyTest_{timestamp}&#34;
        logger.info(soh_num)
        payload[&#34;SOHNUM&#34;] = soh_num
        payload[&#34;YRDSREF&#34;] = f&#34;S_{timestamp}&#34;
        resp = test_client.post(&#34;/api/v0/contracts/&#34;, json=payload)
&gt;       assert resp.status_code == 201, resp.content
E       AssertionError: b&#39;{&#34;detail&#34;:&#34;Server Error (500)&#34;,&#34;status_code&#34;:500}&#39;
E       assert 500 == 201
E        +  where 500 = &lt;Response [500]&gt;.status_code

app/api/live_tests/test_contracts/test_modify_option_activated_contract.py:28: AssertionError</pre> </div> <div class=section> <h5 class=section-title>Captured log call</h5> <pre><samp>INFO     pytestDC:test_modify_option_activated_contract.py:24 PyTest_30011447</samp></pre> </div> </div> </details> <details class="phase teardown "> <summary> <h4 class=title> <span class=phase-name>Teardown</span> </h4> </summary> <div class=content> </div> </details> </div> </div> </details> </div> </details> <details class=file> <summary> <h2 class="title file-title"> <span class=fspath> app/api/live_tests/test_contracts/test_modify_option_contract.py </span> <span class=counts> <span title="1 xfailed" class="count status badge xfailed ">1</span> </span> <span class=duration> 0:00:00.774743 </span> </h2> </summary> <div class="content box"> <details class="test xfailed"> <summary> <h3 class="title test-title"> <span class="status badge xfailed ">XFAIL</span> <span class=test-name> <span class=funcname>test_modify_option_contract_adsl</span> </span> <span class=duration>0:00:00.774743</span> </h3> </summary> <div class=content> <table class=metadata> <tr> <th>Started</th> <td>2023-06-30 01:14:48</td> </tr> <tr> <th>Ended</th> <td>2023-06-30 01:14:49</td> </tr> <tr> <th>Duration</th> <td>0:00:00.774743</td> </tr> <tr> <th>Markers</th> <td> <div class=marker> <span class="marker-name badge">write_data</span> <span class=marker-args> </span> </div> <div class=marker> <span class="marker-name badge">xfail</span> <span class=marker-args> </span> </div> <div class=marker> <span class="marker-name badge">livetest</span> <span class=marker-args> </span> </div> </td> </tr> <tr> <th>Fixtures</th> <td> <span class="badge fixturename"> django_test_environment </span> <span class="badge fixturename"> django_db_blocker </span> <span class="badge fixturename"> test_client </span> <span class="badge fixturename"> request </span> </td> </tr> </table> <div class=repr> <pre>AssertionError: b&#39;{&#34;detail&#34;:&#34;Server Error (500)&#34;,&#34;status_code&#34;:500}&#39;
assert 500 == 201
 +  where 500 = &lt;Response [500]&gt;.status_code</pre> </div> <div class=test-phases> <details class="phase setup "> <summary> <h4 class=title> <span class=phase-name>Setup</span> </h4> </summary> <div class=content> </div> </details> <details class="phase call xfailed" open> <summary> <h4 class=title> <span class="status  xfailed"></span> <span class=phase-name>Call</span> </h4> </summary> <div class=content> <div class=repr> <pre>test_client = &lt;conftest.LiveServerSession object at 0x7f34c155f940&gt;

    @pytest.mark.livetest
    @pytest.mark.xfail
    @pytest.mark.write_data
    def test_modify_option_contract_adsl(test_client):
        # Create ADSL contract not yet enabled (parent item 1286) and items
        # [ (1, normal), (206, normal), (245, normal), (915, variante) ]
        payload = load_json(&#34;contracts/test_modify_option_contract_adsl/payload.json&#34;)
        timestamp = datetime.datetime.now().strftime(&#34;%d%H%M%S&#34;)
        soh_num = f&#34;PyTest_{timestamp}&#34;
        logger.info(soh_num)
        payload[&#34;SOHNUM&#34;] = soh_num
        resp = test_client.post(&#34;/api/v0/contracts/&#34;, json=payload)
&gt;       assert resp.status_code == 201, resp.content
E       AssertionError: b&#39;{&#34;detail&#34;:&#34;Server Error (500)&#34;,&#34;status_code&#34;:500}&#39;
E       assert 500 == 201
E        +  where 500 = &lt;Response [500]&gt;.status_code

app/api/live_tests/test_contracts/test_modify_option_contract.py:25: AssertionError</pre> </div> <div class=section> <h5 class=section-title>Captured log call</h5> <pre><samp>INFO     pytestDC:test_modify_option_contract.py:22 PyTest_30011448</samp></pre> </div> </div> </details> <details class="phase teardown "> <summary> <h4 class=title> <span class=phase-name>Teardown</span> </h4> </summary> <div class=content> </div> </details> </div> </div> </details> </div> </details> <details class=file> <summary> <h2 class="title file-title"> <span class=fspath> app/api/live_tests/test_contracts/test_query_contract.py </span> <span class=counts> <span title="2 xfailed" class="count status badge xfailed ">2</span> </span> <span class=duration> 0:00:01.389798 </span> </h2> </summary> <div class="content box"> <details class="test xfailed"> <summary> <h3 class="title test-title"> <span class="status badge xfailed ">XFAIL</span> <span class=test-name> <span class=funcname>test_x3_schema_query_contracts</span> </span> <span class=duration>0:00:00.664315</span> </h3> </summary> <div class=content> <div class=documentation> <p>Validate contract schema representation <cite>XSORDERW</cite> query</p> </div> <table class=metadata> <tr> <th>Started</th> <td>2023-06-30 01:14:49</td> </tr> <tr> <th>Ended</th> <td>2023-06-30 01:14:49</td> </tr> <tr> <th>Duration</th> <td>0:00:00.664315</td> </tr> <tr> <th>Markers</th> <td> <div class=marker> <span class="marker-name badge">read_data</span> <span class=marker-args> </span> </div> <div class=marker> <span class="marker-name badge">xfail</span> <span class=marker-args> </span> </div> <div class=marker> <span class="marker-name badge">livetest</span> <span class=marker-args> </span> </div> </td> </tr> <tr> <th>Fixtures</th> <td> <span class="badge fixturename"> django_test_environment </span> <span class="badge fixturename"> django_db_blocker </span> <span class="badge fixturename"> x3_client </span> <span class="badge fixturename"> request </span> </td> </tr> </table> <div class=repr> <pre>requests.exceptions.RetryError: HTTPSConnectionPool(host=&#39;sagex3-horsprod.covage.com&#39;, port=443): Max retries exceeded with url: /api1/x3/erp/QAL/XSORDERW?representation=XSORDERW.%24query&amp;count=20&amp;orderBy=UPDDATTIM%20desc (Caused by ResponseError(&#39;too many 502 error responses&#39;))</pre> </div> <div class=test-phases> <details class="phase setup "> <summary> <h4 class=title> <span class=phase-name>Setup</span> </h4> </summary> <div class=content> </div> </details> <details class="phase call xfailed" open> <summary> <h4 class=title> <span class="status  xfailed"></span> <span class=phase-name>Call</span> </h4> </summary> <div class=content> <div class=repr> <pre>self = &lt;requests.adapters.HTTPAdapter object at 0x7f34bbf99dc0&gt;
request = &lt;PreparedRequest [GET]&gt;, stream = False
timeout = Timeout(connect=None, read=None, total=None), verify = True
cert = None
proxies = OrderedDict([(&#39;no&#39;, &#39;gitlab-runner-cache-01-prd.nut.covage.com&#39;), (&#39;http&#39;, &#39;http://squid.kosc.net:3128&#39;), (&#39;https&#39;, &#39;http://squid.kosc.net:3128&#39;)])

    def send(
        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None
    ):
        &#34;&#34;&#34;Sends PreparedRequest object. Returns Response object.
    
        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.
        :param stream: (optional) Whether to stream the request content.
        :param timeout: (optional) How long to wait for the server to send
            data before giving up, as a float, or a :ref:`(connect timeout,
            read timeout) &lt;timeouts&gt;` tuple.
        :type timeout: float or tuple or urllib3 Timeout object
        :param verify: (optional) Either a boolean, in which case it controls whether
            we verify the server&#39;s TLS certificate, or a string, in which case it
            must be a path to a CA bundle to use
        :param cert: (optional) Any user-provided SSL certificate to be trusted.
        :param proxies: (optional) The proxies dictionary to apply to the request.
        :rtype: requests.Response
        &#34;&#34;&#34;
    
        try:
            conn = self.get_connection(request.url, proxies)
        except LocationValueError as e:
            raise InvalidURL(e, request=request)
    
        self.cert_verify(conn, request.url, verify, cert)
        url = self.request_url(request, proxies)
        self.add_headers(
            request,
            stream=stream,
            timeout=timeout,
            verify=verify,
            cert=cert,
            proxies=proxies,
        )
    
        chunked = not (request.body is None or &#34;Content-Length&#34; in request.headers)
    
        if isinstance(timeout, tuple):
            try:
                connect, read = timeout
                timeout = TimeoutSauce(connect=connect, read=read)
            except ValueError:
                raise ValueError(
                    f&#34;Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, &#34;
                    f&#34;or a single float to set both timeouts to the same value.&#34;
                )
        elif isinstance(timeout, TimeoutSauce):
            pass
        else:
            timeout = TimeoutSauce(connect=timeout, read=timeout)
    
        try:
            if not chunked:
&gt;               resp = conn.urlopen(
                    method=request.method,
                    url=url,
                    body=request.body,
                    headers=request.headers,
                    redirect=False,
                    assert_same_host=False,
                    preload_content=False,
                    decode_content=False,
                    retries=self.max_retries,
                    timeout=timeout,
                )

/usr/local/lib/python3.8/site-packages/requests/adapters.py:489: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connectionpool.HTTPSConnectionPool object at 0x7f34bbf99c10&gt;
method = &#39;GET&#39;
url = &#39;/api1/x3/erp/QAL/XSORDERW?representation=XSORDERW.%24query&amp;count=20&amp;orderBy=UPDDATTIM%20desc&#39;
body = None
headers = {&#39;User-Agent&#39;: &#39;python-requests/2.28.1&#39;, &#39;Accept-Encoding&#39;: &#39;gzip, deflate&#39;, &#39;Accept&#39;: &#39;*/*&#39;, &#39;Connection&#39;: &#39;keep-alive&#39;, &#39;Content-Type&#39;: &#39;application/json&#39;, &#39;Authorization&#39;: &#39;Basic aW50cmFjbzpXYXNzaW1Db3ZhZ2VA&#39;}
retries = Retry(total=2, connect=None, read=None, redirect=None, status=None)
redirect = False, assert_same_host = False
timeout = Timeout(connect=None, read=None, total=None), pool_timeout = None
release_conn = False, chunked = False, body_pos = None
response_kw = {&#39;decode_content&#39;: False, &#39;preload_content&#39;: False, &#39;request_method&#39;: &#39;GET&#39;}
parsed_url = Url(scheme=None, auth=None, host=None, port=None, path=&#39;/api1/x3/erp/QAL/XSORDERW&#39;, query=&#39;representation=XSORDERW.%24query&amp;count=20&amp;orderBy=UPDDATTIM%20desc&#39;, fragment=None)
destination_scheme = None
conn = &lt;urllib3.connection.HTTPSConnection object at 0x7f34bbf84820&gt;
release_this_conn = False, http_tunnel_required = True, err = None
clean_exit = True

    def urlopen(
        self,
        method,
        url,
        body=None,
        headers=None,
        retries=None,
        redirect=True,
        assert_same_host=True,
        timeout=_Default,
        pool_timeout=None,
        release_conn=None,
        chunked=False,
        body_pos=None,
        **response_kw
    ):
        &#34;&#34;&#34;
        Get a connection from the pool and perform an HTTP request. This is the
        lowest level call for making a request, so you&#39;ll need to specify all
        the raw details.
    
        .. note::
    
           More commonly, it&#39;s appropriate to use a convenience method provided
           by :class:`.RequestMethods`, such as :meth:`request`.
    
        .. note::
    
           `release_conn` will only behave as expected if
           `preload_content=False` because we want to make
           `preload_content=False` the default behaviour someday soon without
           breaking backwards compatibility.
    
        :param method:
            HTTP request method (such as GET, POST, PUT, etc.)
    
        :param url:
            The URL to perform the request on.
    
        :param body:
            Data to send in the request body, either :class:`str`, :class:`bytes`,
            an iterable of :class:`str`/:class:`bytes`, or a file-like object.
    
        :param headers:
            Dictionary of custom headers to send, such as User-Agent,
            If-None-Match, etc. If None, pool headers are used. If provided,
            these headers completely replace any pool-specific headers.
    
        :param retries:
            Configure the number of retries to allow before raising a
            :class:`~urllib3.exceptions.MaxRetryError` exception.
    
            Pass ``None`` to retry until you receive a response. Pass a
            :class:`~urllib3.util.retry.Retry` object for fine-grained control
            over different types of retries.
            Pass an integer number to retry connection errors that many times,
            but no other types of errors. Pass zero to never retry.
    
            If ``False``, then retries are disabled and any exception is raised
            immediately. Also, instead of raising a MaxRetryError on redirects,
            the redirect response will be returned.
    
        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.
    
        :param redirect:
            If True, automatically handle redirects (status codes 301, 302,
            303, 307, 308). Each redirect counts as a retry. Disabling retries
            will disable redirect, too.
    
        :param assert_same_host:
            If ``True``, will make sure that the host of the pool requests is
            consistent else will raise HostChangedError. When ``False``, you can
            use the pool on an HTTP proxy and request foreign hosts.
    
        :param timeout:
            If specified, overrides the default timeout for this one
            request. It may be a float (in seconds) or an instance of
            :class:`urllib3.util.Timeout`.
    
        :param pool_timeout:
            If set and the pool is set to block=True, then this method will
            block for ``pool_timeout`` seconds and raise EmptyPoolError if no
            connection is available within the time period.
    
        :param release_conn:
            If False, then the urlopen call will not release the connection
            back into the pool once a response is received (but will release if
            you read the entire contents of the response such as when
            `preload_content=True`). This is useful if you&#39;re not preloading
            the response&#39;s content immediately. You will need to call
            ``r.release_conn()`` on the response ``r`` to return the connection
            back into the pool. If None, it takes the value of
            ``response_kw.get(&#39;preload_content&#39;, True)``.
    
        :param chunked:
            If True, urllib3 will send the body using chunked transfer
            encoding. Otherwise, urllib3 will send the body using the standard
            content-length form. Defaults to False.
    
        :param int body_pos:
            Position to seek to in file-like body in the event of a retry or
            redirect. Typically this won&#39;t need to be set because urllib3 will
            auto-populate the value when needed.
    
        :param \\**response_kw:
            Additional parameters are passed to
            :meth:`urllib3.response.HTTPResponse.from_httplib`
        &#34;&#34;&#34;
    
        parsed_url = parse_url(url)
        destination_scheme = parsed_url.scheme
    
        if headers is None:
            headers = self.headers
    
        if not isinstance(retries, Retry):
            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)
    
        if release_conn is None:
            release_conn = response_kw.get(&#34;preload_content&#34;, True)
    
        # Check host
        if assert_same_host and not self.is_same_host(url):
            raise HostChangedError(self, url, retries)
    
        # Ensure that the URL we&#39;re connecting to is properly encoded
        if url.startswith(&#34;/&#34;):
            url = six.ensure_str(_encode_target(url))
        else:
            url = six.ensure_str(parsed_url.url)
    
        conn = None
    
        # Track whether `conn` needs to be released before
        # returning/raising/recursing. Update this variable if necessary, and
        # leave `release_conn` constant throughout the function. That way, if
        # the function recurses, the original value of `release_conn` will be
        # passed down into the recursive call, and its value will be respected.
        #
        # See issue #651 [1] for details.
        #
        # [1] &lt;https://github.com/urllib3/urllib3/issues/651&gt;
        release_this_conn = release_conn
    
        http_tunnel_required = connection_requires_http_tunnel(
            self.proxy, self.proxy_config, destination_scheme
        )
    
        # Merge the proxy headers. Only done when not using HTTP CONNECT. We
        # have to copy the headers dict so we can safely change it without those
        # changes being reflected in anyone else&#39;s copy.
        if not http_tunnel_required:
            headers = headers.copy()
            headers.update(self.proxy_headers)
    
        # Must keep the exception bound to a separate variable or else Python 3
        # complains about UnboundLocalError.
        err = None
    
        # Keep track of whether we cleanly exited the except block. This
        # ensures we do proper cleanup in finally.
        clean_exit = False
    
        # Rewind body position, if needed. Record current position
        # for future rewinds in the event of a redirect/retry.
        body_pos = set_file_position(body, body_pos)
    
        try:
            # Request a connection from the queue.
            timeout_obj = self._get_timeout(timeout)
            conn = self._get_conn(timeout=pool_timeout)
    
            conn.timeout = timeout_obj.connect_timeout
    
            is_new_proxy_conn = self.proxy is not None and not getattr(
                conn, &#34;sock&#34;, None
            )
            if is_new_proxy_conn and http_tunnel_required:
                self._prepare_proxy(conn)
    
            # Make the request on the httplib connection object.
            httplib_response = self._make_request(
                conn,
                method,
                url,
                timeout=timeout_obj,
                body=body,
                headers=headers,
                chunked=chunked,
            )
    
            # If we&#39;re going to release the connection in ``finally:``, then
            # the response doesn&#39;t need to know about the connection. Otherwise
            # it will also try to release it and we&#39;ll have a double-release
            # mess.
            response_conn = conn if not release_conn else None
    
            # Pass method to Response for length checking
            response_kw[&#34;request_method&#34;] = method
    
            # Import httplib&#39;s response into our own wrapper object
            response = self.ResponseCls.from_httplib(
                httplib_response,
                pool=self,
                connection=response_conn,
                retries=retries,
                **response_kw
            )
    
            # Everything went great!
            clean_exit = True
    
        except EmptyPoolError:
            # Didn&#39;t get a connection from the pool, no need to clean up
            clean_exit = True
            release_this_conn = False
            raise
    
        except (
            TimeoutError,
            HTTPException,
            SocketError,
            ProtocolError,
            BaseSSLError,
            SSLError,
            CertificateError,
        ) as e:
            # Discard the connection for these exceptions. It will be
            # replaced during the next _get_conn() call.
            clean_exit = False
    
            def _is_ssl_error_message_from_http_proxy(ssl_error):
                # We&#39;re trying to detect the message &#39;WRONG_VERSION_NUMBER&#39; but
                # SSLErrors are kinda all over the place when it comes to the message,
                # so we try to cover our bases here!
                message = &#34; &#34;.join(re.split(&#34;[^a-z]&#34;, str(ssl_error).lower()))
                return (
                    &#34;wrong version number&#34; in message or &#34;unknown protocol&#34; in message
                )
    
            # Try to detect a common user error with proxies which is to
            # set an HTTP proxy to be HTTPS when it should be &#39;http://&#39;
            # (ie {&#39;http&#39;: &#39;http://proxy&#39;, &#39;https&#39;: &#39;https://proxy&#39;})
            # Instead we add a nice error message and point to a URL.
            if (
                isinstance(e, BaseSSLError)
                and self.proxy
                and _is_ssl_error_message_from_http_proxy(e)
                and conn.proxy
                and conn.proxy.scheme == &#34;https&#34;
            ):
                e = ProxyError(
                    &#34;Your proxy appears to only use HTTP and not HTTPS, &#34;
                    &#34;try changing your proxy URL to be HTTP. See: &#34;
                    &#34;https://urllib3.readthedocs.io/en/1.26.x/advanced-usage.html&#34;
                    &#34;#https-proxy-error-http-proxy&#34;,
                    SSLError(e),
                )
            elif isinstance(e, (BaseSSLError, CertificateError)):
                e = SSLError(e)
            elif isinstance(e, (SocketError, NewConnectionError)) and self.proxy:
                e = ProxyError(&#34;Cannot connect to proxy.&#34;, e)
            elif isinstance(e, (SocketError, HTTPException)):
                e = ProtocolError(&#34;Connection aborted.&#34;, e)
    
            retries = retries.increment(
                method, url, error=e, _pool=self, _stacktrace=sys.exc_info()[2]
            )
            retries.sleep()
    
            # Keep track of the error for the retry warning.
            err = e
    
        finally:
            if not clean_exit:
                # We hit some kind of exception, handled or otherwise. We need
                # to throw the connection away unless explicitly told not to.
                # Close the connection, set the variable to None, and make sure
                # we put the None back in the pool to avoid leaking it.
                conn = conn and conn.close()
                release_this_conn = True
    
            if release_this_conn:
                # Put the connection back to be reused. If the connection is
                # expired then it will be None, which will get replaced with a
                # fresh connection during _get_conn.
                self._put_conn(conn)
    
        if not conn:
            # Try again
            log.warning(
                &#34;Retrying (%r) after connection broken by &#39;%r&#39;: %s&#34;, retries, err, url
            )
            return self.urlopen(
                method,
                url,
                body,
                headers,
                retries,
                redirect,
                assert_same_host,
                timeout=timeout,
                pool_timeout=pool_timeout,
                release_conn=release_conn,
                chunked=chunked,
                body_pos=body_pos,
                **response_kw
            )
    
        # Handle redirect?
        redirect_location = redirect and response.get_redirect_location()
        if redirect_location:
            if response.status == 303:
                method = &#34;GET&#34;
    
            try:
                retries = retries.increment(method, url, response=response, _pool=self)
            except MaxRetryError:
                if retries.raise_on_redirect:
                    response.drain_conn()
                    raise
                return response
    
            response.drain_conn()
            retries.sleep_for_retry(response)
            log.debug(&#34;Redirecting %s -&gt; %s&#34;, url, redirect_location)
            return self.urlopen(
                method,
                redirect_location,
                body,
                headers,
                retries=retries,
                redirect=redirect,
                assert_same_host=assert_same_host,
                timeout=timeout,
                pool_timeout=pool_timeout,
                release_conn=release_conn,
                chunked=chunked,
                body_pos=body_pos,
                **response_kw
            )
    
        # Check if we should retry the HTTP response.
        has_retry_after = bool(response.getheader(&#34;Retry-After&#34;))
        if retries.is_retry(method, response.status, has_retry_after):
            try:
                retries = retries.increment(method, url, response=response, _pool=self)
            except MaxRetryError:
                if retries.raise_on_status:
                    response.drain_conn()
                    raise
                return response
    
            response.drain_conn()
            retries.sleep(response)
            log.debug(&#34;Retry: %s&#34;, url)
&gt;           return self.urlopen(
                method,
                url,
                body,
                headers,
                retries=retries,
                redirect=redirect,
                assert_same_host=assert_same_host,
                timeout=timeout,
                pool_timeout=pool_timeout,
                release_conn=release_conn,
                chunked=chunked,
                body_pos=body_pos,
                **response_kw
            )

/usr/local/lib/python3.8/site-packages/urllib3/connectionpool.py:878: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connectionpool.HTTPSConnectionPool object at 0x7f34bbf99c10&gt;
method = &#39;GET&#39;
url = &#39;/api1/x3/erp/QAL/XSORDERW?representation=XSORDERW.%24query&amp;count=20&amp;orderBy=UPDDATTIM%20desc&#39;
body = None
headers = {&#39;User-Agent&#39;: &#39;python-requests/2.28.1&#39;, &#39;Accept-Encoding&#39;: &#39;gzip, deflate&#39;, &#39;Accept&#39;: &#39;*/*&#39;, &#39;Connection&#39;: &#39;keep-alive&#39;, &#39;Content-Type&#39;: &#39;application/json&#39;, &#39;Authorization&#39;: &#39;Basic aW50cmFjbzpXYXNzaW1Db3ZhZ2VA&#39;}
retries = Retry(total=1, connect=None, read=None, redirect=None, status=None)
redirect = False, assert_same_host = False
timeout = Timeout(connect=None, read=None, total=None), pool_timeout = None
release_conn = False, chunked = False, body_pos = None
response_kw = {&#39;decode_content&#39;: False, &#39;preload_content&#39;: False, &#39;request_method&#39;: &#39;GET&#39;}
parsed_url = Url(scheme=None, auth=None, host=None, port=None, path=&#39;/api1/x3/erp/QAL/XSORDERW&#39;, query=&#39;representation=XSORDERW.%24query&amp;count=20&amp;orderBy=UPDDATTIM%20desc&#39;, fragment=None)
destination_scheme = None
conn = &lt;urllib3.connection.HTTPSConnection object at 0x7f34bbf84820&gt;
release_this_conn = False, http_tunnel_required = True, err = None
clean_exit = True

    def urlopen(
        self,
        method,
        url,
        body=None,
        headers=None,
        retries=None,
        redirect=True,
        assert_same_host=True,
        timeout=_Default,
        pool_timeout=None,
        release_conn=None,
        chunked=False,
        body_pos=None,
        **response_kw
    ):
        &#34;&#34;&#34;
        Get a connection from the pool and perform an HTTP request. This is the
        lowest level call for making a request, so you&#39;ll need to specify all
        the raw details.
    
        .. note::
    
           More commonly, it&#39;s appropriate to use a convenience method provided
           by :class:`.RequestMethods`, such as :meth:`request`.
    
        .. note::
    
           `release_conn` will only behave as expected if
           `preload_content=False` because we want to make
           `preload_content=False` the default behaviour someday soon without
           breaking backwards compatibility.
    
        :param method:
            HTTP request method (such as GET, POST, PUT, etc.)
    
        :param url:
            The URL to perform the request on.
    
        :param body:
            Data to send in the request body, either :class:`str`, :class:`bytes`,
            an iterable of :class:`str`/:class:`bytes`, or a file-like object.
    
        :param headers:
            Dictionary of custom headers to send, such as User-Agent,
            If-None-Match, etc. If None, pool headers are used. If provided,
            these headers completely replace any pool-specific headers.
    
        :param retries:
            Configure the number of retries to allow before raising a
            :class:`~urllib3.exceptions.MaxRetryError` exception.
    
            Pass ``None`` to retry until you receive a response. Pass a
            :class:`~urllib3.util.retry.Retry` object for fine-grained control
            over different types of retries.
            Pass an integer number to retry connection errors that many times,
            but no other types of errors. Pass zero to never retry.
    
            If ``False``, then retries are disabled and any exception is raised
            immediately. Also, instead of raising a MaxRetryError on redirects,
            the redirect response will be returned.
    
        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.
    
        :param redirect:
            If True, automatically handle redirects (status codes 301, 302,
            303, 307, 308). Each redirect counts as a retry. Disabling retries
            will disable redirect, too.
    
        :param assert_same_host:
            If ``True``, will make sure that the host of the pool requests is
            consistent else will raise HostChangedError. When ``False``, you can
            use the pool on an HTTP proxy and request foreign hosts.
    
        :param timeout:
            If specified, overrides the default timeout for this one
            request. It may be a float (in seconds) or an instance of
            :class:`urllib3.util.Timeout`.
    
        :param pool_timeout:
            If set and the pool is set to block=True, then this method will
            block for ``pool_timeout`` seconds and raise EmptyPoolError if no
            connection is available within the time period.
    
        :param release_conn:
            If False, then the urlopen call will not release the connection
            back into the pool once a response is received (but will release if
            you read the entire contents of the response such as when
            `preload_content=True`). This is useful if you&#39;re not preloading
            the response&#39;s content immediately. You will need to call
            ``r.release_conn()`` on the response ``r`` to return the connection
            back into the pool. If None, it takes the value of
            ``response_kw.get(&#39;preload_content&#39;, True)``.
    
        :param chunked:
            If True, urllib3 will send the body using chunked transfer
            encoding. Otherwise, urllib3 will send the body using the standard
            content-length form. Defaults to False.
    
        :param int body_pos:
            Position to seek to in file-like body in the event of a retry or
            redirect. Typically this won&#39;t need to be set because urllib3 will
            auto-populate the value when needed.
    
        :param \\**response_kw:
            Additional parameters are passed to
            :meth:`urllib3.response.HTTPResponse.from_httplib`
        &#34;&#34;&#34;
    
        parsed_url = parse_url(url)
        destination_scheme = parsed_url.scheme
    
        if headers is None:
            headers = self.headers
    
        if not isinstance(retries, Retry):
            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)
    
        if release_conn is None:
            release_conn = response_kw.get(&#34;preload_content&#34;, True)
    
        # Check host
        if assert_same_host and not self.is_same_host(url):
            raise HostChangedError(self, url, retries)
    
        # Ensure that the URL we&#39;re connecting to is properly encoded
        if url.startswith(&#34;/&#34;):
            url = six.ensure_str(_encode_target(url))
        else:
            url = six.ensure_str(parsed_url.url)
    
        conn = None
    
        # Track whether `conn` needs to be released before
        # returning/raising/recursing. Update this variable if necessary, and
        # leave `release_conn` constant throughout the function. That way, if
        # the function recurses, the original value of `release_conn` will be
        # passed down into the recursive call, and its value will be respected.
        #
        # See issue #651 [1] for details.
        #
        # [1] &lt;https://github.com/urllib3/urllib3/issues/651&gt;
        release_this_conn = release_conn
    
        http_tunnel_required = connection_requires_http_tunnel(
            self.proxy, self.proxy_config, destination_scheme
        )
    
        # Merge the proxy headers. Only done when not using HTTP CONNECT. We
        # have to copy the headers dict so we can safely change it without those
        # changes being reflected in anyone else&#39;s copy.
        if not http_tunnel_required:
            headers = headers.copy()
            headers.update(self.proxy_headers)
    
        # Must keep the exception bound to a separate variable or else Python 3
        # complains about UnboundLocalError.
        err = None
    
        # Keep track of whether we cleanly exited the except block. This
        # ensures we do proper cleanup in finally.
        clean_exit = False
    
        # Rewind body position, if needed. Record current position
        # for future rewinds in the event of a redirect/retry.
        body_pos = set_file_position(body, body_pos)
    
        try:
            # Request a connection from the queue.
            timeout_obj = self._get_timeout(timeout)
            conn = self._get_conn(timeout=pool_timeout)
    
            conn.timeout = timeout_obj.connect_timeout
    
            is_new_proxy_conn = self.proxy is not None and not getattr(
                conn, &#34;sock&#34;, None
            )
            if is_new_proxy_conn and http_tunnel_required:
                self._prepare_proxy(conn)
    
            # Make the request on the httplib connection object.
            httplib_response = self._make_request(
                conn,
                method,
                url,
                timeout=timeout_obj,
                body=body,
                headers=headers,
                chunked=chunked,
            )
    
            # If we&#39;re going to release the connection in ``finally:``, then
            # the response doesn&#39;t need to know about the connection. Otherwise
            # it will also try to release it and we&#39;ll have a double-release
            # mess.
            response_conn = conn if not release_conn else None
    
            # Pass method to Response for length checking
            response_kw[&#34;request_method&#34;] = method
    
            # Import httplib&#39;s response into our own wrapper object
            response = self.ResponseCls.from_httplib(
                httplib_response,
                pool=self,
                connection=response_conn,
                retries=retries,
                **response_kw
            )
    
            # Everything went great!
            clean_exit = True
    
        except EmptyPoolError:
            # Didn&#39;t get a connection from the pool, no need to clean up
            clean_exit = True
            release_this_conn = False
            raise
    
        except (
            TimeoutError,
            HTTPException,
            SocketError,
            ProtocolError,
            BaseSSLError,
            SSLError,
            CertificateError,
        ) as e:
            # Discard the connection for these exceptions. It will be
            # replaced during the next _get_conn() call.
            clean_exit = False
    
            def _is_ssl_error_message_from_http_proxy(ssl_error):
                # We&#39;re trying to detect the message &#39;WRONG_VERSION_NUMBER&#39; but
                # SSLErrors are kinda all over the place when it comes to the message,
                # so we try to cover our bases here!
                message = &#34; &#34;.join(re.split(&#34;[^a-z]&#34;, str(ssl_error).lower()))
                return (
                    &#34;wrong version number&#34; in message or &#34;unknown protocol&#34; in message
                )
    
            # Try to detect a common user error with proxies which is to
            # set an HTTP proxy to be HTTPS when it should be &#39;http://&#39;
            # (ie {&#39;http&#39;: &#39;http://proxy&#39;, &#39;https&#39;: &#39;https://proxy&#39;})
            # Instead we add a nice error message and point to a URL.
            if (
                isinstance(e, BaseSSLError)
                and self.proxy
                and _is_ssl_error_message_from_http_proxy(e)
                and conn.proxy
                and conn.proxy.scheme == &#34;https&#34;
            ):
                e = ProxyError(
                    &#34;Your proxy appears to only use HTTP and not HTTPS, &#34;
                    &#34;try changing your proxy URL to be HTTP. See: &#34;
                    &#34;https://urllib3.readthedocs.io/en/1.26.x/advanced-usage.html&#34;
                    &#34;#https-proxy-error-http-proxy&#34;,
                    SSLError(e),
                )
            elif isinstance(e, (BaseSSLError, CertificateError)):
                e = SSLError(e)
            elif isinstance(e, (SocketError, NewConnectionError)) and self.proxy:
                e = ProxyError(&#34;Cannot connect to proxy.&#34;, e)
            elif isinstance(e, (SocketError, HTTPException)):
                e = ProtocolError(&#34;Connection aborted.&#34;, e)
    
            retries = retries.increment(
                method, url, error=e, _pool=self, _stacktrace=sys.exc_info()[2]
            )
            retries.sleep()
    
            # Keep track of the error for the retry warning.
            err = e
    
        finally:
            if not clean_exit:
                # We hit some kind of exception, handled or otherwise. We need
                # to throw the connection away unless explicitly told not to.
                # Close the connection, set the variable to None, and make sure
                # we put the None back in the pool to avoid leaking it.
                conn = conn and conn.close()
                release_this_conn = True
    
            if release_this_conn:
                # Put the connection back to be reused. If the connection is
                # expired then it will be None, which will get replaced with a
                # fresh connection during _get_conn.
                self._put_conn(conn)
    
        if not conn:
            # Try again
            log.warning(
                &#34;Retrying (%r) after connection broken by &#39;%r&#39;: %s&#34;, retries, err, url
            )
            return self.urlopen(
                method,
                url,
                body,
                headers,
                retries,
                redirect,
                assert_same_host,
                timeout=timeout,
                pool_timeout=pool_timeout,
                release_conn=release_conn,
                chunked=chunked,
                body_pos=body_pos,
                **response_kw
            )
    
        # Handle redirect?
        redirect_location = redirect and response.get_redirect_location()
        if redirect_location:
            if response.status == 303:
                method = &#34;GET&#34;
    
            try:
                retries = retries.increment(method, url, response=response, _pool=self)
            except MaxRetryError:
                if retries.raise_on_redirect:
                    response.drain_conn()
                    raise
                return response
    
            response.drain_conn()
            retries.sleep_for_retry(response)
            log.debug(&#34;Redirecting %s -&gt; %s&#34;, url, redirect_location)
            return self.urlopen(
                method,
                redirect_location,
                body,
                headers,
                retries=retries,
                redirect=redirect,
                assert_same_host=assert_same_host,
                timeout=timeout,
                pool_timeout=pool_timeout,
                release_conn=release_conn,
                chunked=chunked,
                body_pos=body_pos,
                **response_kw
            )
    
        # Check if we should retry the HTTP response.
        has_retry_after = bool(response.getheader(&#34;Retry-After&#34;))
        if retries.is_retry(method, response.status, has_retry_after):
            try:
                retries = retries.increment(method, url, response=response, _pool=self)
            except MaxRetryError:
                if retries.raise_on_status:
                    response.drain_conn()
                    raise
                return response
    
            response.drain_conn()
            retries.sleep(response)
            log.debug(&#34;Retry: %s&#34;, url)
&gt;           return self.urlopen(
                method,
                url,
                body,
                headers,
                retries=retries,
                redirect=redirect,
                assert_same_host=assert_same_host,
                timeout=timeout,
                pool_timeout=pool_timeout,
                release_conn=release_conn,
                chunked=chunked,
                body_pos=body_pos,
                **response_kw
            )

/usr/local/lib/python3.8/site-packages/urllib3/connectionpool.py:878: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connectionpool.HTTPSConnectionPool object at 0x7f34bbf99c10&gt;
method = &#39;GET&#39;
url = &#39;/api1/x3/erp/QAL/XSORDERW?representation=XSORDERW.%24query&amp;count=20&amp;orderBy=UPDDATTIM%20desc&#39;
body = None
headers = {&#39;User-Agent&#39;: &#39;python-requests/2.28.1&#39;, &#39;Accept-Encoding&#39;: &#39;gzip, deflate&#39;, &#39;Accept&#39;: &#39;*/*&#39;, &#39;Connection&#39;: &#39;keep-alive&#39;, &#39;Content-Type&#39;: &#39;application/json&#39;, &#39;Authorization&#39;: &#39;Basic aW50cmFjbzpXYXNzaW1Db3ZhZ2VA&#39;}
retries = Retry(total=0, connect=None, read=None, redirect=None, status=None)
redirect = False, assert_same_host = False
timeout = Timeout(connect=None, read=None, total=None), pool_timeout = None
release_conn = False, chunked = False, body_pos = None
response_kw = {&#39;decode_content&#39;: False, &#39;preload_content&#39;: False, &#39;request_method&#39;: &#39;GET&#39;}
parsed_url = Url(scheme=None, auth=None, host=None, port=None, path=&#39;/api1/x3/erp/QAL/XSORDERW&#39;, query=&#39;representation=XSORDERW.%24query&amp;count=20&amp;orderBy=UPDDATTIM%20desc&#39;, fragment=None)
destination_scheme = None
conn = &lt;urllib3.connection.HTTPSConnection object at 0x7f34bbf84820&gt;
release_this_conn = False, http_tunnel_required = True, err = None
clean_exit = True

    def urlopen(
        self,
        method,
        url,
        body=None,
        headers=None,
        retries=None,
        redirect=True,
        assert_same_host=True,
        timeout=_Default,
        pool_timeout=None,
        release_conn=None,
        chunked=False,
        body_pos=None,
        **response_kw
    ):
        &#34;&#34;&#34;
        Get a connection from the pool and perform an HTTP request. This is the
        lowest level call for making a request, so you&#39;ll need to specify all
        the raw details.
    
        .. note::
    
           More commonly, it&#39;s appropriate to use a convenience method provided
           by :class:`.RequestMethods`, such as :meth:`request`.
    
        .. note::
    
           `release_conn` will only behave as expected if
           `preload_content=False` because we want to make
           `preload_content=False` the default behaviour someday soon without
           breaking backwards compatibility.
    
        :param method:
            HTTP request method (such as GET, POST, PUT, etc.)
    
        :param url:
            The URL to perform the request on.
    
        :param body:
            Data to send in the request body, either :class:`str`, :class:`bytes`,
            an iterable of :class:`str`/:class:`bytes`, or a file-like object.
    
        :param headers:
            Dictionary of custom headers to send, such as User-Agent,
            If-None-Match, etc. If None, pool headers are used. If provided,
            these headers completely replace any pool-specific headers.
    
        :param retries:
            Configure the number of retries to allow before raising a
            :class:`~urllib3.exceptions.MaxRetryError` exception.
    
            Pass ``None`` to retry until you receive a response. Pass a
            :class:`~urllib3.util.retry.Retry` object for fine-grained control
            over different types of retries.
            Pass an integer number to retry connection errors that many times,
            but no other types of errors. Pass zero to never retry.
    
            If ``False``, then retries are disabled and any exception is raised
            immediately. Also, instead of raising a MaxRetryError on redirects,
            the redirect response will be returned.
    
        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.
    
        :param redirect:
            If True, automatically handle redirects (status codes 301, 302,
            303, 307, 308). Each redirect counts as a retry. Disabling retries
            will disable redirect, too.
    
        :param assert_same_host:
            If ``True``, will make sure that the host of the pool requests is
            consistent else will raise HostChangedError. When ``False``, you can
            use the pool on an HTTP proxy and request foreign hosts.
    
        :param timeout:
            If specified, overrides the default timeout for this one
            request. It may be a float (in seconds) or an instance of
            :class:`urllib3.util.Timeout`.
    
        :param pool_timeout:
            If set and the pool is set to block=True, then this method will
            block for ``pool_timeout`` seconds and raise EmptyPoolError if no
            connection is available within the time period.
    
        :param release_conn:
            If False, then the urlopen call will not release the connection
            back into the pool once a response is received (but will release if
            you read the entire contents of the response such as when
            `preload_content=True`). This is useful if you&#39;re not preloading
            the response&#39;s content immediately. You will need to call
            ``r.release_conn()`` on the response ``r`` to return the connection
            back into the pool. If None, it takes the value of
            ``response_kw.get(&#39;preload_content&#39;, True)``.
    
        :param chunked:
            If True, urllib3 will send the body using chunked transfer
            encoding. Otherwise, urllib3 will send the body using the standard
            content-length form. Defaults to False.
    
        :param int body_pos:
            Position to seek to in file-like body in the event of a retry or
            redirect. Typically this won&#39;t need to be set because urllib3 will
            auto-populate the value when needed.
    
        :param \\**response_kw:
            Additional parameters are passed to
            :meth:`urllib3.response.HTTPResponse.from_httplib`
        &#34;&#34;&#34;
    
        parsed_url = parse_url(url)
        destination_scheme = parsed_url.scheme
    
        if headers is None:
            headers = self.headers
    
        if not isinstance(retries, Retry):
            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)
    
        if release_conn is None:
            release_conn = response_kw.get(&#34;preload_content&#34;, True)
    
        # Check host
        if assert_same_host and not self.is_same_host(url):
            raise HostChangedError(self, url, retries)
    
        # Ensure that the URL we&#39;re connecting to is properly encoded
        if url.startswith(&#34;/&#34;):
            url = six.ensure_str(_encode_target(url))
        else:
            url = six.ensure_str(parsed_url.url)
    
        conn = None
    
        # Track whether `conn` needs to be released before
        # returning/raising/recursing. Update this variable if necessary, and
        # leave `release_conn` constant throughout the function. That way, if
        # the function recurses, the original value of `release_conn` will be
        # passed down into the recursive call, and its value will be respected.
        #
        # See issue #651 [1] for details.
        #
        # [1] &lt;https://github.com/urllib3/urllib3/issues/651&gt;
        release_this_conn = release_conn
    
        http_tunnel_required = connection_requires_http_tunnel(
            self.proxy, self.proxy_config, destination_scheme
        )
    
        # Merge the proxy headers. Only done when not using HTTP CONNECT. We
        # have to copy the headers dict so we can safely change it without those
        # changes being reflected in anyone else&#39;s copy.
        if not http_tunnel_required:
            headers = headers.copy()
            headers.update(self.proxy_headers)
    
        # Must keep the exception bound to a separate variable or else Python 3
        # complains about UnboundLocalError.
        err = None
    
        # Keep track of whether we cleanly exited the except block. This
        # ensures we do proper cleanup in finally.
        clean_exit = False
    
        # Rewind body position, if needed. Record current position
        # for future rewinds in the event of a redirect/retry.
        body_pos = set_file_position(body, body_pos)
    
        try:
            # Request a connection from the queue.
            timeout_obj = self._get_timeout(timeout)
            conn = self._get_conn(timeout=pool_timeout)
    
            conn.timeout = timeout_obj.connect_timeout
    
            is_new_proxy_conn = self.proxy is not None and not getattr(
                conn, &#34;sock&#34;, None
            )
            if is_new_proxy_conn and http_tunnel_required:
                self._prepare_proxy(conn)
    
            # Make the request on the httplib connection object.
            httplib_response = self._make_request(
                conn,
                method,
                url,
                timeout=timeout_obj,
                body=body,
                headers=headers,
                chunked=chunked,
            )
    
            # If we&#39;re going to release the connection in ``finally:``, then
            # the response doesn&#39;t need to know about the connection. Otherwise
            # it will also try to release it and we&#39;ll have a double-release
            # mess.
            response_conn = conn if not release_conn else None
    
            # Pass method to Response for length checking
            response_kw[&#34;request_method&#34;] = method
    
            # Import httplib&#39;s response into our own wrapper object
            response = self.ResponseCls.from_httplib(
                httplib_response,
                pool=self,
                connection=response_conn,
                retries=retries,
                **response_kw
            )
    
            # Everything went great!
            clean_exit = True
    
        except EmptyPoolError:
            # Didn&#39;t get a connection from the pool, no need to clean up
            clean_exit = True
            release_this_conn = False
            raise
    
        except (
            TimeoutError,
            HTTPException,
            SocketError,
            ProtocolError,
            BaseSSLError,
            SSLError,
            CertificateError,
        ) as e:
            # Discard the connection for these exceptions. It will be
            # replaced during the next _get_conn() call.
            clean_exit = False
    
            def _is_ssl_error_message_from_http_proxy(ssl_error):
                # We&#39;re trying to detect the message &#39;WRONG_VERSION_NUMBER&#39; but
                # SSLErrors are kinda all over the place when it comes to the message,
                # so we try to cover our bases here!
                message = &#34; &#34;.join(re.split(&#34;[^a-z]&#34;, str(ssl_error).lower()))
                return (
                    &#34;wrong version number&#34; in message or &#34;unknown protocol&#34; in message
                )
    
            # Try to detect a common user error with proxies which is to
            # set an HTTP proxy to be HTTPS when it should be &#39;http://&#39;
            # (ie {&#39;http&#39;: &#39;http://proxy&#39;, &#39;https&#39;: &#39;https://proxy&#39;})
            # Instead we add a nice error message and point to a URL.
            if (
                isinstance(e, BaseSSLError)
                and self.proxy
                and _is_ssl_error_message_from_http_proxy(e)
                and conn.proxy
                and conn.proxy.scheme == &#34;https&#34;
            ):
                e = ProxyError(
                    &#34;Your proxy appears to only use HTTP and not HTTPS, &#34;
                    &#34;try changing your proxy URL to be HTTP. See: &#34;
                    &#34;https://urllib3.readthedocs.io/en/1.26.x/advanced-usage.html&#34;
                    &#34;#https-proxy-error-http-proxy&#34;,
                    SSLError(e),
                )
            elif isinstance(e, (BaseSSLError, CertificateError)):
                e = SSLError(e)
            elif isinstance(e, (SocketError, NewConnectionError)) and self.proxy:
                e = ProxyError(&#34;Cannot connect to proxy.&#34;, e)
            elif isinstance(e, (SocketError, HTTPException)):
                e = ProtocolError(&#34;Connection aborted.&#34;, e)
    
            retries = retries.increment(
                method, url, error=e, _pool=self, _stacktrace=sys.exc_info()[2]
            )
            retries.sleep()
    
            # Keep track of the error for the retry warning.
            err = e
    
        finally:
            if not clean_exit:
                # We hit some kind of exception, handled or otherwise. We need
                # to throw the connection away unless explicitly told not to.
                # Close the connection, set the variable to None, and make sure
                # we put the None back in the pool to avoid leaking it.
                conn = conn and conn.close()
                release_this_conn = True
    
            if release_this_conn:
                # Put the connection back to be reused. If the connection is
                # expired then it will be None, which will get replaced with a
                # fresh connection during _get_conn.
                self._put_conn(conn)
    
        if not conn:
            # Try again
            log.warning(
                &#34;Retrying (%r) after connection broken by &#39;%r&#39;: %s&#34;, retries, err, url
            )
            return self.urlopen(
                method,
                url,
                body,
                headers,
                retries,
                redirect,
                assert_same_host,
                timeout=timeout,
                pool_timeout=pool_timeout,
                release_conn=release_conn,
                chunked=chunked,
                body_pos=body_pos,
                **response_kw
            )
    
        # Handle redirect?
        redirect_location = redirect and response.get_redirect_location()
        if redirect_location:
            if response.status == 303:
                method = &#34;GET&#34;
    
            try:
                retries = retries.increment(method, url, response=response, _pool=self)
            except MaxRetryError:
                if retries.raise_on_redirect:
                    response.drain_conn()
                    raise
                return response
    
            response.drain_conn()
            retries.sleep_for_retry(response)
            log.debug(&#34;Redirecting %s -&gt; %s&#34;, url, redirect_location)
            return self.urlopen(
                method,
                redirect_location,
                body,
                headers,
                retries=retries,
                redirect=redirect,
                assert_same_host=assert_same_host,
                timeout=timeout,
                pool_timeout=pool_timeout,
                release_conn=release_conn,
                chunked=chunked,
                body_pos=body_pos,
                **response_kw
            )
    
        # Check if we should retry the HTTP response.
        has_retry_after = bool(response.getheader(&#34;Retry-After&#34;))
        if retries.is_retry(method, response.status, has_retry_after):
            try:
                retries = retries.increment(method, url, response=response, _pool=self)
            except MaxRetryError:
                if retries.raise_on_status:
                    response.drain_conn()
                    raise
                return response
    
            response.drain_conn()
            retries.sleep(response)
            log.debug(&#34;Retry: %s&#34;, url)
&gt;           return self.urlopen(
                method,
                url,
                body,
                headers,
                retries=retries,
                redirect=redirect,
                assert_same_host=assert_same_host,
                timeout=timeout,
                pool_timeout=pool_timeout,
                release_conn=release_conn,
                chunked=chunked,
                body_pos=body_pos,
                **response_kw
            )

/usr/local/lib/python3.8/site-packages/urllib3/connectionpool.py:878: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connectionpool.HTTPSConnectionPool object at 0x7f34bbf99c10&gt;
method = &#39;GET&#39;
url = &#39;/api1/x3/erp/QAL/XSORDERW?representation=XSORDERW.%24query&amp;count=20&amp;orderBy=UPDDATTIM%20desc&#39;
body = None
headers = {&#39;User-Agent&#39;: &#39;python-requests/2.28.1&#39;, &#39;Accept-Encoding&#39;: &#39;gzip, deflate&#39;, &#39;Accept&#39;: &#39;*/*&#39;, &#39;Connection&#39;: &#39;keep-alive&#39;, &#39;Content-Type&#39;: &#39;application/json&#39;, &#39;Authorization&#39;: &#39;Basic aW50cmFjbzpXYXNzaW1Db3ZhZ2VA&#39;}
retries = Retry(total=0, connect=None, read=None, redirect=None, status=None)
redirect = False, assert_same_host = False
timeout = Timeout(connect=None, read=None, total=None), pool_timeout = None
release_conn = False, chunked = False, body_pos = None
response_kw = {&#39;decode_content&#39;: False, &#39;preload_content&#39;: False, &#39;request_method&#39;: &#39;GET&#39;}
parsed_url = Url(scheme=None, auth=None, host=None, port=None, path=&#39;/api1/x3/erp/QAL/XSORDERW&#39;, query=&#39;representation=XSORDERW.%24query&amp;count=20&amp;orderBy=UPDDATTIM%20desc&#39;, fragment=None)
destination_scheme = None
conn = &lt;urllib3.connection.HTTPSConnection object at 0x7f34bbf84820&gt;
release_this_conn = False, http_tunnel_required = True, err = None
clean_exit = True

    def urlopen(
        self,
        method,
        url,
        body=None,
        headers=None,
        retries=None,
        redirect=True,
        assert_same_host=True,
        timeout=_Default,
        pool_timeout=None,
        release_conn=None,
        chunked=False,
        body_pos=None,
        **response_kw
    ):
        &#34;&#34;&#34;
        Get a connection from the pool and perform an HTTP request. This is the
        lowest level call for making a request, so you&#39;ll need to specify all
        the raw details.
    
        .. note::
    
           More commonly, it&#39;s appropriate to use a convenience method provided
           by :class:`.RequestMethods`, such as :meth:`request`.
    
        .. note::
    
           `release_conn` will only behave as expected if
           `preload_content=False` because we want to make
           `preload_content=False` the default behaviour someday soon without
           breaking backwards compatibility.
    
        :param method:
            HTTP request method (such as GET, POST, PUT, etc.)
    
        :param url:
            The URL to perform the request on.
    
        :param body:
            Data to send in the request body, either :class:`str`, :class:`bytes`,
            an iterable of :class:`str`/:class:`bytes`, or a file-like object.
    
        :param headers:
            Dictionary of custom headers to send, such as User-Agent,
            If-None-Match, etc. If None, pool headers are used. If provided,
            these headers completely replace any pool-specific headers.
    
        :param retries:
            Configure the number of retries to allow before raising a
            :class:`~urllib3.exceptions.MaxRetryError` exception.
    
            Pass ``None`` to retry until you receive a response. Pass a
            :class:`~urllib3.util.retry.Retry` object for fine-grained control
            over different types of retries.
            Pass an integer number to retry connection errors that many times,
            but no other types of errors. Pass zero to never retry.
    
            If ``False``, then retries are disabled and any exception is raised
            immediately. Also, instead of raising a MaxRetryError on redirects,
            the redirect response will be returned.
    
        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.
    
        :param redirect:
            If True, automatically handle redirects (status codes 301, 302,
            303, 307, 308). Each redirect counts as a retry. Disabling retries
            will disable redirect, too.
    
        :param assert_same_host:
            If ``True``, will make sure that the host of the pool requests is
            consistent else will raise HostChangedError. When ``False``, you can
            use the pool on an HTTP proxy and request foreign hosts.
    
        :param timeout:
            If specified, overrides the default timeout for this one
            request. It may be a float (in seconds) or an instance of
            :class:`urllib3.util.Timeout`.
    
        :param pool_timeout:
            If set and the pool is set to block=True, then this method will
            block for ``pool_timeout`` seconds and raise EmptyPoolError if no
            connection is available within the time period.
    
        :param release_conn:
            If False, then the urlopen call will not release the connection
            back into the pool once a response is received (but will release if
            you read the entire contents of the response such as when
            `preload_content=True`). This is useful if you&#39;re not preloading
            the response&#39;s content immediately. You will need to call
            ``r.release_conn()`` on the response ``r`` to return the connection
            back into the pool. If None, it takes the value of
            ``response_kw.get(&#39;preload_content&#39;, True)``.
    
        :param chunked:
            If True, urllib3 will send the body using chunked transfer
            encoding. Otherwise, urllib3 will send the body using the standard
            content-length form. Defaults to False.
    
        :param int body_pos:
            Position to seek to in file-like body in the event of a retry or
            redirect. Typically this won&#39;t need to be set because urllib3 will
            auto-populate the value when needed.
    
        :param \\**response_kw:
            Additional parameters are passed to
            :meth:`urllib3.response.HTTPResponse.from_httplib`
        &#34;&#34;&#34;
    
        parsed_url = parse_url(url)
        destination_scheme = parsed_url.scheme
    
        if headers is None:
            headers = self.headers
    
        if not isinstance(retries, Retry):
            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)
    
        if release_conn is None:
            release_conn = response_kw.get(&#34;preload_content&#34;, True)
    
        # Check host
        if assert_same_host and not self.is_same_host(url):
            raise HostChangedError(self, url, retries)
    
        # Ensure that the URL we&#39;re connecting to is properly encoded
        if url.startswith(&#34;/&#34;):
            url = six.ensure_str(_encode_target(url))
        else:
            url = six.ensure_str(parsed_url.url)
    
        conn = None
    
        # Track whether `conn` needs to be released before
        # returning/raising/recursing. Update this variable if necessary, and
        # leave `release_conn` constant throughout the function. That way, if
        # the function recurses, the original value of `release_conn` will be
        # passed down into the recursive call, and its value will be respected.
        #
        # See issue #651 [1] for details.
        #
        # [1] &lt;https://github.com/urllib3/urllib3/issues/651&gt;
        release_this_conn = release_conn
    
        http_tunnel_required = connection_requires_http_tunnel(
            self.proxy, self.proxy_config, destination_scheme
        )
    
        # Merge the proxy headers. Only done when not using HTTP CONNECT. We
        # have to copy the headers dict so we can safely change it without those
        # changes being reflected in anyone else&#39;s copy.
        if not http_tunnel_required:
            headers = headers.copy()
            headers.update(self.proxy_headers)
    
        # Must keep the exception bound to a separate variable or else Python 3
        # complains about UnboundLocalError.
        err = None
    
        # Keep track of whether we cleanly exited the except block. This
        # ensures we do proper cleanup in finally.
        clean_exit = False
    
        # Rewind body position, if needed. Record current position
        # for future rewinds in the event of a redirect/retry.
        body_pos = set_file_position(body, body_pos)
    
        try:
            # Request a connection from the queue.
            timeout_obj = self._get_timeout(timeout)
            conn = self._get_conn(timeout=pool_timeout)
    
            conn.timeout = timeout_obj.connect_timeout
    
            is_new_proxy_conn = self.proxy is not None and not getattr(
                conn, &#34;sock&#34;, None
            )
            if is_new_proxy_conn and http_tunnel_required:
                self._prepare_proxy(conn)
    
            # Make the request on the httplib connection object.
            httplib_response = self._make_request(
                conn,
                method,
                url,
                timeout=timeout_obj,
                body=body,
                headers=headers,
                chunked=chunked,
            )
    
            # If we&#39;re going to release the connection in ``finally:``, then
            # the response doesn&#39;t need to know about the connection. Otherwise
            # it will also try to release it and we&#39;ll have a double-release
            # mess.
            response_conn = conn if not release_conn else None
    
            # Pass method to Response for length checking
            response_kw[&#34;request_method&#34;] = method
    
            # Import httplib&#39;s response into our own wrapper object
            response = self.ResponseCls.from_httplib(
                httplib_response,
                pool=self,
                connection=response_conn,
                retries=retries,
                **response_kw
            )
    
            # Everything went great!
            clean_exit = True
    
        except EmptyPoolError:
            # Didn&#39;t get a connection from the pool, no need to clean up
            clean_exit = True
            release_this_conn = False
            raise
    
        except (
            TimeoutError,
            HTTPException,
            SocketError,
            ProtocolError,
            BaseSSLError,
            SSLError,
            CertificateError,
        ) as e:
            # Discard the connection for these exceptions. It will be
            # replaced during the next _get_conn() call.
            clean_exit = False
    
            def _is_ssl_error_message_from_http_proxy(ssl_error):
                # We&#39;re trying to detect the message &#39;WRONG_VERSION_NUMBER&#39; but
                # SSLErrors are kinda all over the place when it comes to the message,
                # so we try to cover our bases here!
                message = &#34; &#34;.join(re.split(&#34;[^a-z]&#34;, str(ssl_error).lower()))
                return (
                    &#34;wrong version number&#34; in message or &#34;unknown protocol&#34; in message
                )
    
            # Try to detect a common user error with proxies which is to
            # set an HTTP proxy to be HTTPS when it should be &#39;http://&#39;
            # (ie {&#39;http&#39;: &#39;http://proxy&#39;, &#39;https&#39;: &#39;https://proxy&#39;})
            # Instead we add a nice error message and point to a URL.
            if (
                isinstance(e, BaseSSLError)
                and self.proxy
                and _is_ssl_error_message_from_http_proxy(e)
                and conn.proxy
                and conn.proxy.scheme == &#34;https&#34;
            ):
                e = ProxyError(
                    &#34;Your proxy appears to only use HTTP and not HTTPS, &#34;
                    &#34;try changing your proxy URL to be HTTP. See: &#34;
                    &#34;https://urllib3.readthedocs.io/en/1.26.x/advanced-usage.html&#34;
                    &#34;#https-proxy-error-http-proxy&#34;,
                    SSLError(e),
                )
            elif isinstance(e, (BaseSSLError, CertificateError)):
                e = SSLError(e)
            elif isinstance(e, (SocketError, NewConnectionError)) and self.proxy:
                e = ProxyError(&#34;Cannot connect to proxy.&#34;, e)
            elif isinstance(e, (SocketError, HTTPException)):
                e = ProtocolError(&#34;Connection aborted.&#34;, e)
    
            retries = retries.increment(
                method, url, error=e, _pool=self, _stacktrace=sys.exc_info()[2]
            )
            retries.sleep()
    
            # Keep track of the error for the retry warning.
            err = e
    
        finally:
            if not clean_exit:
                # We hit some kind of exception, handled or otherwise. We need
                # to throw the connection away unless explicitly told not to.
                # Close the connection, set the variable to None, and make sure
                # we put the None back in the pool to avoid leaking it.
                conn = conn and conn.close()
                release_this_conn = True
    
            if release_this_conn:
                # Put the connection back to be reused. If the connection is
                # expired then it will be None, which will get replaced with a
                # fresh connection during _get_conn.
                self._put_conn(conn)
    
        if not conn:
            # Try again
            log.warning(
                &#34;Retrying (%r) after connection broken by &#39;%r&#39;: %s&#34;, retries, err, url
            )
            return self.urlopen(
                method,
                url,
                body,
                headers,
                retries,
                redirect,
                assert_same_host,
                timeout=timeout,
                pool_timeout=pool_timeout,
                release_conn=release_conn,
                chunked=chunked,
                body_pos=body_pos,
                **response_kw
            )
    
        # Handle redirect?
        redirect_location = redirect and response.get_redirect_location()
        if redirect_location:
            if response.status == 303:
                method = &#34;GET&#34;
    
            try:
                retries = retries.increment(method, url, response=response, _pool=self)
            except MaxRetryError:
                if retries.raise_on_redirect:
                    response.drain_conn()
                    raise
                return response
    
            response.drain_conn()
            retries.sleep_for_retry(response)
            log.debug(&#34;Redirecting %s -&gt; %s&#34;, url, redirect_location)
            return self.urlopen(
                method,
                redirect_location,
                body,
                headers,
                retries=retries,
                redirect=redirect,
                assert_same_host=assert_same_host,
                timeout=timeout,
                pool_timeout=pool_timeout,
                release_conn=release_conn,
                chunked=chunked,
                body_pos=body_pos,
                **response_kw
            )
    
        # Check if we should retry the HTTP response.
        has_retry_after = bool(response.getheader(&#34;Retry-After&#34;))
        if retries.is_retry(method, response.status, has_retry_after):
            try:
&gt;               retries = retries.increment(method, url, response=response, _pool=self)

/usr/local/lib/python3.8/site-packages/urllib3/connectionpool.py:868: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Retry(total=0, connect=None, read=None, redirect=None, status=None)
method = &#39;GET&#39;
url = &#39;/api1/x3/erp/QAL/XSORDERW?representation=XSORDERW.%24query&amp;count=20&amp;orderBy=UPDDATTIM%20desc&#39;
response = &lt;urllib3.response.HTTPResponse object at 0x7f34bbaf29d0&gt;
error = None
_pool = &lt;urllib3.connectionpool.HTTPSConnectionPool object at 0x7f34bbf99c10&gt;
_stacktrace = None

    def increment(
        self,
        method=None,
        url=None,
        response=None,
        error=None,
        _pool=None,
        _stacktrace=None,
    ):
        &#34;&#34;&#34;Return a new Retry object with incremented retry counters.
    
        :param response: A response object, or None, if the server did not
            return a response.
        :type response: :class:`~urllib3.response.HTTPResponse`
        :param Exception error: An error encountered during the request, or
            None if the response was received successfully.
    
        :return: A new ``Retry`` object.
        &#34;&#34;&#34;
        if self.total is False and error:
            # Disabled, indicate to re-raise the error.
            raise six.reraise(type(error), error, _stacktrace)
    
        total = self.total
        if total is not None:
            total -= 1
    
        connect = self.connect
        read = self.read
        redirect = self.redirect
        status_count = self.status
        other = self.other
        cause = &#34;unknown&#34;
        status = None
        redirect_location = None
    
        if error and self._is_connection_error(error):
            # Connect retry?
            if connect is False:
                raise six.reraise(type(error), error, _stacktrace)
            elif connect is not None:
                connect -= 1
    
        elif error and self._is_read_error(error):
            # Read retry?
            if read is False or not self._is_method_retryable(method):
                raise six.reraise(type(error), error, _stacktrace)
            elif read is not None:
                read -= 1
    
        elif error:
            # Other retry?
            if other is not None:
                other -= 1
    
        elif response and response.get_redirect_location():
            # Redirect retry?
            if redirect is not None:
                redirect -= 1
            cause = &#34;too many redirects&#34;
            redirect_location = response.get_redirect_location()
            status = response.status
    
        else:
            # Incrementing because of a server error like a 500 in
            # status_forcelist and the given method is in the allowed_methods
            cause = ResponseError.GENERIC_ERROR
            if response and response.status:
                if status_count is not None:
                    status_count -= 1
                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)
                status = response.status
    
        history = self.history + (
            RequestHistory(method, url, error, status, redirect_location),
        )
    
        new_retry = self.new(
            total=total,
            connect=connect,
            read=read,
            redirect=redirect,
            status=status_count,
            other=other,
            history=history,
        )
    
        if new_retry.is_exhausted():
&gt;           raise MaxRetryError(_pool, url, error or ResponseError(cause))
E           urllib3.exceptions.MaxRetryError: HTTPSConnectionPool(host=&#39;sagex3-horsprod.covage.com&#39;, port=443): Max retries exceeded with url: /api1/x3/erp/QAL/XSORDERW?representation=XSORDERW.%24query&amp;count=20&amp;orderBy=UPDDATTIM%20desc (Caused by ResponseError(&#39;too many 502 error responses&#39;))

/usr/local/lib/python3.8/site-packages/urllib3/util/retry.py:592: MaxRetryError

During handling of the above exception, another exception occurred:

x3_client = &lt;x3_wrapper.rest_client.X3RestClient object at 0x7f34bbf99670&gt;

    @pytest.mark.livetest
    @pytest.mark.xfail
    @pytest.mark.read_data
    def test_x3_schema_query_contracts(x3_client):
        &#34;&#34;&#34;Validate contract schema representation `XSORDERW` query&#34;&#34;&#34;
&gt;       resp = x3_client.list(
            class_name=&#34;XSORDERW&#34;,
            representation=&#34;XSORDERW&#34;,
            count=20,
            **{&#34;orderBy&#34;: &#34;UPDDATTIM desc&#34;}
        )

app/api/live_tests/test_contracts/test_query_contract.py:12: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
app/x3_wrapper/rest_client.py:84: in list
    resp = self._cal_x3(&#34;GET&#34;, url, query_params)
app/x3_wrapper/rest_client.py:70: in _cal_x3
    resp = self.client.request(method, url, params=query_params)
/usr/local/lib/python3.8/site-packages/requests/sessions.py:587: in request
    resp = self.send(prep, **send_kwargs)
/usr/local/lib/python3.8/site-packages/requests/sessions.py:701: in send
    r = adapter.send(request, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;requests.adapters.HTTPAdapter object at 0x7f34bbf99dc0&gt;
request = &lt;PreparedRequest [GET]&gt;, stream = False
timeout = Timeout(connect=None, read=None, total=None), verify = True
cert = None
proxies = OrderedDict([(&#39;no&#39;, &#39;gitlab-runner-cache-01-prd.nut.covage.com&#39;), (&#39;http&#39;, &#39;http://squid.kosc.net:3128&#39;), (&#39;https&#39;, &#39;http://squid.kosc.net:3128&#39;)])

    def send(
        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None
    ):
        &#34;&#34;&#34;Sends PreparedRequest object. Returns Response object.
    
        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.
        :param stream: (optional) Whether to stream the request content.
        :param timeout: (optional) How long to wait for the server to send
            data before giving up, as a float, or a :ref:`(connect timeout,
            read timeout) &lt;timeouts&gt;` tuple.
        :type timeout: float or tuple or urllib3 Timeout object
        :param verify: (optional) Either a boolean, in which case it controls whether
            we verify the server&#39;s TLS certificate, or a string, in which case it
            must be a path to a CA bundle to use
        :param cert: (optional) Any user-provided SSL certificate to be trusted.
        :param proxies: (optional) The proxies dictionary to apply to the request.
        :rtype: requests.Response
        &#34;&#34;&#34;
    
        try:
            conn = self.get_connection(request.url, proxies)
        except LocationValueError as e:
            raise InvalidURL(e, request=request)
    
        self.cert_verify(conn, request.url, verify, cert)
        url = self.request_url(request, proxies)
        self.add_headers(
            request,
            stream=stream,
            timeout=timeout,
            verify=verify,
            cert=cert,
            proxies=proxies,
        )
    
        chunked = not (request.body is None or &#34;Content-Length&#34; in request.headers)
    
        if isinstance(timeout, tuple):
            try:
                connect, read = timeout
                timeout = TimeoutSauce(connect=connect, read=read)
            except ValueError:
                raise ValueError(
                    f&#34;Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, &#34;
                    f&#34;or a single float to set both timeouts to the same value.&#34;
                )
        elif isinstance(timeout, TimeoutSauce):
            pass
        else:
            timeout = TimeoutSauce(connect=timeout, read=timeout)
    
        try:
            if not chunked:
                resp = conn.urlopen(
                    method=request.method,
                    url=url,
                    body=request.body,
                    headers=request.headers,
                    redirect=False,
                    assert_same_host=False,
                    preload_content=False,
                    decode_content=False,
                    retries=self.max_retries,
                    timeout=timeout,
                )
    
            # Send the request.
            else:
                if hasattr(conn, &#34;proxy_pool&#34;):
                    conn = conn.proxy_pool
    
                low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)
    
                try:
                    skip_host = &#34;Host&#34; in request.headers
                    low_conn.putrequest(
                        request.method,
                        url,
                        skip_accept_encoding=True,
                        skip_host=skip_host,
                    )
    
                    for header, value in request.headers.items():
                        low_conn.putheader(header, value)
    
                    low_conn.endheaders()
    
                    for i in request.body:
                        low_conn.send(hex(len(i))[2:].encode(&#34;utf-8&#34;))
                        low_conn.send(b&#34;\r\n&#34;)
                        low_conn.send(i)
                        low_conn.send(b&#34;\r\n&#34;)
                    low_conn.send(b&#34;0\r\n\r\n&#34;)
    
                    # Receive the response from the server
                    r = low_conn.getresponse()
    
                    resp = HTTPResponse.from_httplib(
                        r,
                        pool=conn,
                        connection=low_conn,
                        preload_content=False,
                        decode_content=False,
                    )
                except Exception:
                    # If we hit any problems here, clean up the connection.
                    # Then, raise so that we can handle the actual exception.
                    low_conn.close()
                    raise
    
        except (ProtocolError, OSError) as err:
            raise ConnectionError(err, request=request)
    
        except MaxRetryError as e:
            if isinstance(e.reason, ConnectTimeoutError):
                # TODO: Remove this in 3.0.0: see #2811
                if not isinstance(e.reason, NewConnectionError):
                    raise ConnectTimeout(e, request=request)
    
            if isinstance(e.reason, ResponseError):
&gt;               raise RetryError(e, request=request)
E               requests.exceptions.RetryError: HTTPSConnectionPool(host=&#39;sagex3-horsprod.covage.com&#39;, port=443): Max retries exceeded with url: /api1/x3/erp/QAL/XSORDERW?representation=XSORDERW.%24query&amp;count=20&amp;orderBy=UPDDATTIM%20desc (Caused by ResponseError(&#39;too many 502 error responses&#39;))

/usr/local/lib/python3.8/site-packages/requests/adapters.py:556: RetryError</pre> </div> </div> </details> <details class="phase teardown "> <summary> <h4 class=title> <span class=phase-name>Teardown</span> </h4> </summary> <div class=content> </div> </details> </div> </div> </details> <details class="test xfailed"> <summary> <h3 class="title test-title"> <span class="status badge xfailed ">XFAIL</span> <span class=test-name> <span class=funcname>test_api_list_contracts</span> </span> <span class=duration>0:00:00.725482</span> </h3> </summary> <div class=content> <div class=documentation> <p>Validate api schema representation for route <cite>/contracts/</cite></p> <p>Validate pagination next_page</p> </div> <table class=metadata> <tr> <th>Started</th> <td>2023-06-30 01:14:49</td> </tr> <tr> <th>Ended</th> <td>2023-06-30 01:14:50</td> </tr> <tr> <th>Duration</th> <td>0:00:00.725482</td> </tr> <tr> <th>Markers</th> <td> <div class=marker> <span class="marker-name badge">read_data</span> <span class=marker-args> </span> </div> <div class=marker> <span class="marker-name badge">xfail</span> <span class=marker-args> </span> </div> <div class=marker> <span class="marker-name badge">livetest</span> <span class=marker-args> </span> </div> </td> </tr> <tr> <th>Fixtures</th> <td> <span class="badge fixturename"> django_test_environment </span> <span class="badge fixturename"> django_db_blocker </span> <span class="badge fixturename"> test_client </span> <span class="badge fixturename"> request </span> </td> </tr> </table> <div class=repr> <pre>AssertionError: b&#39;{&#34;detail&#34;:&#34;Server Error (500)&#34;,&#34;status_code&#34;:500}&#39;
assert 500 == 200
 +  where 500 = &lt;Response [500]&gt;.status_code</pre> </div> <div class=test-phases> <details class="phase setup "> <summary> <h4 class=title> <span class=phase-name>Setup</span> </h4> </summary> <div class=content> </div> </details> <details class="phase call xfailed" open> <summary> <h4 class=title> <span class="status  xfailed"></span> <span class=phase-name>Call</span> </h4> </summary> <div class=content> <div class=repr> <pre>test_client = &lt;conftest.LiveServerSession object at 0x7f34bbb861c0&gt;

    @pytest.mark.livetest
    @pytest.mark.xfail
    @pytest.mark.read_data
    def test_api_list_contracts(test_client):
        &#34;&#34;&#34;
        Validate api schema representation for route `/contracts/`\n
        Validate pagination next_page
        &#34;&#34;&#34;
        resp = test_client.get(&#34;/api/v0/contracts/&#34;)
&gt;       assert resp.status_code == 200, resp.content
E       AssertionError: b&#39;{&#34;detail&#34;:&#34;Server Error (500)&#34;,&#34;status_code&#34;:500}&#39;
E       assert 500 == 200
E        +  where 500 = &lt;Response [500]&gt;.status_code

app/api/live_tests/test_contracts/test_query_contract.py:30: AssertionError</pre> </div> </div> </details> <details class="phase teardown "> <summary> <h4 class=title> <span class=phase-name>Teardown</span> </h4> </summary> <div class=content> </div> </details> </div> </div> </details> </div> </details> <details class=file> <summary> <h2 class="title file-title"> <span class=fspath> app/api/live_tests/test_contracts/test_terminate_option_contract.py </span> <span class=counts> <span title="1 xfailed" class="count status badge xfailed ">1</span> </span> <span class=duration> 0:00:00.775069 </span> </h2> </summary> <div class="content box"> <details class="test xfailed"> <summary> <h3 class="title test-title"> <span class="status badge xfailed ">XFAIL</span> <span class=test-name> <span class=funcname>test_terminate_option_contract_adsl</span> </span> <span class=duration>0:00:00.775069</span> </h3> </summary> <div class=content> <table class=metadata> <tr> <th>Started</th> <td>2023-06-30 01:14:50</td> </tr> <tr> <th>Ended</th> <td>2023-06-30 01:14:51</td> </tr> <tr> <th>Duration</th> <td>0:00:00.775069</td> </tr> <tr> <th>Markers</th> <td> <div class=marker> <span class="marker-name badge">write_data</span> <span class=marker-args> </span> </div> <div class=marker> <span class="marker-name badge">xfail</span> <span class=marker-args> </span> </div> <div class=marker> <span class="marker-name badge">livetest</span> <span class=marker-args> </span> </div> </td> </tr> <tr> <th>Fixtures</th> <td> <span class="badge fixturename"> django_test_environment </span> <span class="badge fixturename"> django_db_blocker </span> <span class="badge fixturename"> test_client </span> <span class="badge fixturename"> request </span> </td> </tr> </table> <div class=repr> <pre>AssertionError: b&#39;{&#34;detail&#34;:&#34;Server Error (500)&#34;,&#34;status_code&#34;:500}&#39;
assert 500 == 201
 +  where 500 = &lt;Response [500]&gt;.status_code</pre> </div> <div class=test-phases> <details class="phase setup "> <summary> <h4 class=title> <span class=phase-name>Setup</span> </h4> </summary> <div class=content> </div> </details> <details class="phase call xfailed" open> <summary> <h4 class=title> <span class="status  xfailed"></span> <span class=phase-name>Call</span> </h4> </summary> <div class=content> <div class=repr> <pre>test_client = &lt;conftest.LiveServerSession object at 0x7f34c1294100&gt;

    @pytest.mark.livetest
    @pytest.mark.xfail
    @pytest.mark.write_data
    def test_terminate_option_contract_adsl(test_client):
        # Create ADSL contract not yet enabled (parent item 1286) and items
        # [ (1, normal), (206, normal), (245, normal), (915, variante), (186, option), (204, option multiple) ]
        payload = load_json(&#34;contracts/test_terminate_option_contract_adsl/payload.json&#34;)
        timestamp = datetime.datetime.now().strftime(&#34;%d%H%M%S&#34;)
        soh_num = f&#34;PyTest_{timestamp}&#34;
        logger.info(soh_num)
        payload[&#34;SOHNUM&#34;] = soh_num
        resp = test_client.post(&#34;/api/v0/contracts/&#34;, json=payload)
&gt;       assert resp.status_code == 201, resp.content
E       AssertionError: b&#39;{&#34;detail&#34;:&#34;Server Error (500)&#34;,&#34;status_code&#34;:500}&#39;
E       assert 500 == 201
E        +  where 500 = &lt;Response [500]&gt;.status_code

app/api/live_tests/test_contracts/test_terminate_option_contract.py:25: AssertionError</pre> </div> <div class=section> <h5 class=section-title>Captured log call</h5> <pre><samp>INFO     pytestDC:test_terminate_option_contract.py:22 PyTest_30011450</samp></pre> </div> </div> </details> <details class="phase teardown "> <summary> <h4 class=title> <span class=phase-name>Teardown</span> </h4> </summary> <div class=content> </div> </details> </div> </div> </details> </div> </details> <details class=file> <summary> <h2 class="title file-title"> <span class=fspath> app/api/live_tests/test_cpv/test_query_cpv.py </span> <span class=counts> <span title="2 xfailed" class="count status badge xfailed ">2</span> </span> <span class=duration> 0:00:01.405325 </span> </h2> </summary> <div class="content box"> <details class="test xfailed"> <summary> <h3 class="title test-title"> <span class="status badge xfailed ">XFAIL</span> <span class=test-name> <span class=funcname>test_x3_schema_query_cpv</span> </span> <span class=duration>0:00:00.675409</span> </h3> </summary> <div class=content> <div class=documentation> <p>Validate CPV schema representation <cite>XSORDERCPV</cite> query</p> </div> <table class=metadata> <tr> <th>Started</th> <td>2023-06-30 01:14:51</td> </tr> <tr> <th>Ended</th> <td>2023-06-30 01:14:52</td> </tr> <tr> <th>Duration</th> <td>0:00:00.675409</td> </tr> <tr> <th>Markers</th> <td> <div class=marker> <span class="marker-name badge">read_data</span> <span class=marker-args> </span> </div> <div class=marker> <span class="marker-name badge">xfail</span> <span class=marker-args> </span> </div> <div class=marker> <span class="marker-name badge">livetest</span> <span class=marker-args> </span> </div> </td> </tr> <tr> <th>Fixtures</th> <td> <span class="badge fixturename"> django_test_environment </span> <span class="badge fixturename"> django_db_blocker </span> <span class="badge fixturename"> x3_client </span> <span class="badge fixturename"> request </span> </td> </tr> </table> <div class=repr> <pre>requests.exceptions.RetryError: HTTPSConnectionPool(host=&#39;sagex3-horsprod.covage.com&#39;, port=443): Max retries exceeded with url: /api1/x3/erp/QAL/XSORDERCPV?representation=XSORDERCPV.%24query&amp;count=100&amp;where=YNATKM%20eq%204&amp;orderBy=UPDDATTIM%20desc (Caused by ResponseError(&#39;too many 502 error responses&#39;))</pre> </div> <div class=test-phases> <details class="phase setup "> <summary> <h4 class=title> <span class=phase-name>Setup</span> </h4> </summary> <div class=content> </div> </details> <details class="phase call xfailed" open> <summary> <h4 class=title> <span class="status  xfailed"></span> <span class=phase-name>Call</span> </h4> </summary> <div class=content> <div class=repr> <pre>self = &lt;requests.adapters.HTTPAdapter object at 0x7f34bbfa76a0&gt;
request = &lt;PreparedRequest [GET]&gt;, stream = False
timeout = Timeout(connect=None, read=None, total=None), verify = True
cert = None
proxies = OrderedDict([(&#39;no&#39;, &#39;gitlab-runner-cache-01-prd.nut.covage.com&#39;), (&#39;http&#39;, &#39;http://squid.kosc.net:3128&#39;), (&#39;https&#39;, &#39;http://squid.kosc.net:3128&#39;)])

    def send(
        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None
    ):
        &#34;&#34;&#34;Sends PreparedRequest object. Returns Response object.
    
        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.
        :param stream: (optional) Whether to stream the request content.
        :param timeout: (optional) How long to wait for the server to send
            data before giving up, as a float, or a :ref:`(connect timeout,
            read timeout) &lt;timeouts&gt;` tuple.
        :type timeout: float or tuple or urllib3 Timeout object
        :param verify: (optional) Either a boolean, in which case it controls whether
            we verify the server&#39;s TLS certificate, or a string, in which case it
            must be a path to a CA bundle to use
        :param cert: (optional) Any user-provided SSL certificate to be trusted.
        :param proxies: (optional) The proxies dictionary to apply to the request.
        :rtype: requests.Response
        &#34;&#34;&#34;
    
        try:
            conn = self.get_connection(request.url, proxies)
        except LocationValueError as e:
            raise InvalidURL(e, request=request)
    
        self.cert_verify(conn, request.url, verify, cert)
        url = self.request_url(request, proxies)
        self.add_headers(
            request,
            stream=stream,
            timeout=timeout,
            verify=verify,
            cert=cert,
            proxies=proxies,
        )
    
        chunked = not (request.body is None or &#34;Content-Length&#34; in request.headers)
    
        if isinstance(timeout, tuple):
            try:
                connect, read = timeout
                timeout = TimeoutSauce(connect=connect, read=read)
            except ValueError:
                raise ValueError(
                    f&#34;Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, &#34;
                    f&#34;or a single float to set both timeouts to the same value.&#34;
                )
        elif isinstance(timeout, TimeoutSauce):
            pass
        else:
            timeout = TimeoutSauce(connect=timeout, read=timeout)
    
        try:
            if not chunked:
&gt;               resp = conn.urlopen(
                    method=request.method,
                    url=url,
                    body=request.body,
                    headers=request.headers,
                    redirect=False,
                    assert_same_host=False,
                    preload_content=False,
                    decode_content=False,
                    retries=self.max_retries,
                    timeout=timeout,
                )

/usr/local/lib/python3.8/site-packages/requests/adapters.py:489: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connectionpool.HTTPSConnectionPool object at 0x7f34bbfa7460&gt;
method = &#39;GET&#39;
url = &#39;/api1/x3/erp/QAL/XSORDERCPV?representation=XSORDERCPV.%24query&amp;count=100&amp;where=YNATKM%20eq%204&amp;orderBy=UPDDATTIM%20desc&#39;
body = None
headers = {&#39;User-Agent&#39;: &#39;python-requests/2.28.1&#39;, &#39;Accept-Encoding&#39;: &#39;gzip, deflate&#39;, &#39;Accept&#39;: &#39;*/*&#39;, &#39;Connection&#39;: &#39;keep-alive&#39;, &#39;Content-Type&#39;: &#39;application/json&#39;, &#39;Authorization&#39;: &#39;Basic aW50cmFjbzpXYXNzaW1Db3ZhZ2VA&#39;}
retries = Retry(total=2, connect=None, read=None, redirect=None, status=None)
redirect = False, assert_same_host = False
timeout = Timeout(connect=None, read=None, total=None), pool_timeout = None
release_conn = False, chunked = False, body_pos = None
response_kw = {&#39;decode_content&#39;: False, &#39;preload_content&#39;: False, &#39;request_method&#39;: &#39;GET&#39;}
parsed_url = Url(scheme=None, auth=None, host=None, port=None, path=&#39;/api1/x3/erp/QAL/XSORDERCPV&#39;, query=&#39;representation=XSORDERCPV.%24query&amp;count=100&amp;where=YNATKM%20eq%204&amp;orderBy=UPDDATTIM%20desc&#39;, fragment=None)
destination_scheme = None
conn = &lt;urllib3.connection.HTTPSConnection object at 0x7f34bbfa78e0&gt;
release_this_conn = False, http_tunnel_required = True, err = None
clean_exit = True

    def urlopen(
        self,
        method,
        url,
        body=None,
        headers=None,
        retries=None,
        redirect=True,
        assert_same_host=True,
        timeout=_Default,
        pool_timeout=None,
        release_conn=None,
        chunked=False,
        body_pos=None,
        **response_kw
    ):
        &#34;&#34;&#34;
        Get a connection from the pool and perform an HTTP request. This is the
        lowest level call for making a request, so you&#39;ll need to specify all
        the raw details.
    
        .. note::
    
           More commonly, it&#39;s appropriate to use a convenience method provided
           by :class:`.RequestMethods`, such as :meth:`request`.
    
        .. note::
    
           `release_conn` will only behave as expected if
           `preload_content=False` because we want to make
           `preload_content=False` the default behaviour someday soon without
           breaking backwards compatibility.
    
        :param method:
            HTTP request method (such as GET, POST, PUT, etc.)
    
        :param url:
            The URL to perform the request on.
    
        :param body:
            Data to send in the request body, either :class:`str`, :class:`bytes`,
            an iterable of :class:`str`/:class:`bytes`, or a file-like object.
    
        :param headers:
            Dictionary of custom headers to send, such as User-Agent,
            If-None-Match, etc. If None, pool headers are used. If provided,
            these headers completely replace any pool-specific headers.
    
        :param retries:
            Configure the number of retries to allow before raising a
            :class:`~urllib3.exceptions.MaxRetryError` exception.
    
            Pass ``None`` to retry until you receive a response. Pass a
            :class:`~urllib3.util.retry.Retry` object for fine-grained control
            over different types of retries.
            Pass an integer number to retry connection errors that many times,
            but no other types of errors. Pass zero to never retry.
    
            If ``False``, then retries are disabled and any exception is raised
            immediately. Also, instead of raising a MaxRetryError on redirects,
            the redirect response will be returned.
    
        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.
    
        :param redirect:
            If True, automatically handle redirects (status codes 301, 302,
            303, 307, 308). Each redirect counts as a retry. Disabling retries
            will disable redirect, too.
    
        :param assert_same_host:
            If ``True``, will make sure that the host of the pool requests is
            consistent else will raise HostChangedError. When ``False``, you can
            use the pool on an HTTP proxy and request foreign hosts.
    
        :param timeout:
            If specified, overrides the default timeout for this one
            request. It may be a float (in seconds) or an instance of
            :class:`urllib3.util.Timeout`.
    
        :param pool_timeout:
            If set and the pool is set to block=True, then this method will
            block for ``pool_timeout`` seconds and raise EmptyPoolError if no
            connection is available within the time period.
    
        :param release_conn:
            If False, then the urlopen call will not release the connection
            back into the pool once a response is received (but will release if
            you read the entire contents of the response such as when
            `preload_content=True`). This is useful if you&#39;re not preloading
            the response&#39;s content immediately. You will need to call
            ``r.release_conn()`` on the response ``r`` to return the connection
            back into the pool. If None, it takes the value of
            ``response_kw.get(&#39;preload_content&#39;, True)``.
    
        :param chunked:
            If True, urllib3 will send the body using chunked transfer
            encoding. Otherwise, urllib3 will send the body using the standard
            content-length form. Defaults to False.
    
        :param int body_pos:
            Position to seek to in file-like body in the event of a retry or
            redirect. Typically this won&#39;t need to be set because urllib3 will
            auto-populate the value when needed.
    
        :param \\**response_kw:
            Additional parameters are passed to
            :meth:`urllib3.response.HTTPResponse.from_httplib`
        &#34;&#34;&#34;
    
        parsed_url = parse_url(url)
        destination_scheme = parsed_url.scheme
    
        if headers is None:
            headers = self.headers
    
        if not isinstance(retries, Retry):
            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)
    
        if release_conn is None:
            release_conn = response_kw.get(&#34;preload_content&#34;, True)
    
        # Check host
        if assert_same_host and not self.is_same_host(url):
            raise HostChangedError(self, url, retries)
    
        # Ensure that the URL we&#39;re connecting to is properly encoded
        if url.startswith(&#34;/&#34;):
            url = six.ensure_str(_encode_target(url))
        else:
            url = six.ensure_str(parsed_url.url)
    
        conn = None
    
        # Track whether `conn` needs to be released before
        # returning/raising/recursing. Update this variable if necessary, and
        # leave `release_conn` constant throughout the function. That way, if
        # the function recurses, the original value of `release_conn` will be
        # passed down into the recursive call, and its value will be respected.
        #
        # See issue #651 [1] for details.
        #
        # [1] &lt;https://github.com/urllib3/urllib3/issues/651&gt;
        release_this_conn = release_conn
    
        http_tunnel_required = connection_requires_http_tunnel(
            self.proxy, self.proxy_config, destination_scheme
        )
    
        # Merge the proxy headers. Only done when not using HTTP CONNECT. We
        # have to copy the headers dict so we can safely change it without those
        # changes being reflected in anyone else&#39;s copy.
        if not http_tunnel_required:
            headers = headers.copy()
            headers.update(self.proxy_headers)
    
        # Must keep the exception bound to a separate variable or else Python 3
        # complains about UnboundLocalError.
        err = None
    
        # Keep track of whether we cleanly exited the except block. This
        # ensures we do proper cleanup in finally.
        clean_exit = False
    
        # Rewind body position, if needed. Record current position
        # for future rewinds in the event of a redirect/retry.
        body_pos = set_file_position(body, body_pos)
    
        try:
            # Request a connection from the queue.
            timeout_obj = self._get_timeout(timeout)
            conn = self._get_conn(timeout=pool_timeout)
    
            conn.timeout = timeout_obj.connect_timeout
    
            is_new_proxy_conn = self.proxy is not None and not getattr(
                conn, &#34;sock&#34;, None
            )
            if is_new_proxy_conn and http_tunnel_required:
                self._prepare_proxy(conn)
    
            # Make the request on the httplib connection object.
            httplib_response = self._make_request(
                conn,
                method,
                url,
                timeout=timeout_obj,
                body=body,
                headers=headers,
                chunked=chunked,
            )
    
            # If we&#39;re going to release the connection in ``finally:``, then
            # the response doesn&#39;t need to know about the connection. Otherwise
            # it will also try to release it and we&#39;ll have a double-release
            # mess.
            response_conn = conn if not release_conn else None
    
            # Pass method to Response for length checking
            response_kw[&#34;request_method&#34;] = method
    
            # Import httplib&#39;s response into our own wrapper object
            response = self.ResponseCls.from_httplib(
                httplib_response,
                pool=self,
                connection=response_conn,
                retries=retries,
                **response_kw
            )
    
            # Everything went great!
            clean_exit = True
    
        except EmptyPoolError:
            # Didn&#39;t get a connection from the pool, no need to clean up
            clean_exit = True
            release_this_conn = False
            raise
    
        except (
            TimeoutError,
            HTTPException,
            SocketError,
            ProtocolError,
            BaseSSLError,
            SSLError,
            CertificateError,
        ) as e:
            # Discard the connection for these exceptions. It will be
            # replaced during the next _get_conn() call.
            clean_exit = False
    
            def _is_ssl_error_message_from_http_proxy(ssl_error):
                # We&#39;re trying to detect the message &#39;WRONG_VERSION_NUMBER&#39; but
                # SSLErrors are kinda all over the place when it comes to the message,
                # so we try to cover our bases here!
                message = &#34; &#34;.join(re.split(&#34;[^a-z]&#34;, str(ssl_error).lower()))
                return (
                    &#34;wrong version number&#34; in message or &#34;unknown protocol&#34; in message
                )
    
            # Try to detect a common user error with proxies which is to
            # set an HTTP proxy to be HTTPS when it should be &#39;http://&#39;
            # (ie {&#39;http&#39;: &#39;http://proxy&#39;, &#39;https&#39;: &#39;https://proxy&#39;})
            # Instead we add a nice error message and point to a URL.
            if (
                isinstance(e, BaseSSLError)
                and self.proxy
                and _is_ssl_error_message_from_http_proxy(e)
                and conn.proxy
                and conn.proxy.scheme == &#34;https&#34;
            ):
                e = ProxyError(
                    &#34;Your proxy appears to only use HTTP and not HTTPS, &#34;
                    &#34;try changing your proxy URL to be HTTP. See: &#34;
                    &#34;https://urllib3.readthedocs.io/en/1.26.x/advanced-usage.html&#34;
                    &#34;#https-proxy-error-http-proxy&#34;,
                    SSLError(e),
                )
            elif isinstance(e, (BaseSSLError, CertificateError)):
                e = SSLError(e)
            elif isinstance(e, (SocketError, NewConnectionError)) and self.proxy:
                e = ProxyError(&#34;Cannot connect to proxy.&#34;, e)
            elif isinstance(e, (SocketError, HTTPException)):
                e = ProtocolError(&#34;Connection aborted.&#34;, e)
    
            retries = retries.increment(
                method, url, error=e, _pool=self, _stacktrace=sys.exc_info()[2]
            )
            retries.sleep()
    
            # Keep track of the error for the retry warning.
            err = e
    
        finally:
            if not clean_exit:
                # We hit some kind of exception, handled or otherwise. We need
                # to throw the connection away unless explicitly told not to.
                # Close the connection, set the variable to None, and make sure
                # we put the None back in the pool to avoid leaking it.
                conn = conn and conn.close()
                release_this_conn = True
    
            if release_this_conn:
                # Put the connection back to be reused. If the connection is
                # expired then it will be None, which will get replaced with a
                # fresh connection during _get_conn.
                self._put_conn(conn)
    
        if not conn:
            # Try again
            log.warning(
                &#34;Retrying (%r) after connection broken by &#39;%r&#39;: %s&#34;, retries, err, url
            )
            return self.urlopen(
                method,
                url,
                body,
                headers,
                retries,
                redirect,
                assert_same_host,
                timeout=timeout,
                pool_timeout=pool_timeout,
                release_conn=release_conn,
                chunked=chunked,
                body_pos=body_pos,
                **response_kw
            )
    
        # Handle redirect?
        redirect_location = redirect and response.get_redirect_location()
        if redirect_location:
            if response.status == 303:
                method = &#34;GET&#34;
    
            try:
                retries = retries.increment(method, url, response=response, _pool=self)
            except MaxRetryError:
                if retries.raise_on_redirect:
                    response.drain_conn()
                    raise
                return response
    
            response.drain_conn()
            retries.sleep_for_retry(response)
            log.debug(&#34;Redirecting %s -&gt; %s&#34;, url, redirect_location)
            return self.urlopen(
                method,
                redirect_location,
                body,
                headers,
                retries=retries,
                redirect=redirect,
                assert_same_host=assert_same_host,
                timeout=timeout,
                pool_timeout=pool_timeout,
                release_conn=release_conn,
                chunked=chunked,
                body_pos=body_pos,
                **response_kw
            )
    
        # Check if we should retry the HTTP response.
        has_retry_after = bool(response.getheader(&#34;Retry-After&#34;))
        if retries.is_retry(method, response.status, has_retry_after):
            try:
                retries = retries.increment(method, url, response=response, _pool=self)
            except MaxRetryError:
                if retries.raise_on_status:
                    response.drain_conn()
                    raise
                return response
    
            response.drain_conn()
            retries.sleep(response)
            log.debug(&#34;Retry: %s&#34;, url)
&gt;           return self.urlopen(
                method,
                url,
                body,
                headers,
                retries=retries,
                redirect=redirect,
                assert_same_host=assert_same_host,
                timeout=timeout,
                pool_timeout=pool_timeout,
                release_conn=release_conn,
                chunked=chunked,
                body_pos=body_pos,
                **response_kw
            )

/usr/local/lib/python3.8/site-packages/urllib3/connectionpool.py:878: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connectionpool.HTTPSConnectionPool object at 0x7f34bbfa7460&gt;
method = &#39;GET&#39;
url = &#39;/api1/x3/erp/QAL/XSORDERCPV?representation=XSORDERCPV.%24query&amp;count=100&amp;where=YNATKM%20eq%204&amp;orderBy=UPDDATTIM%20desc&#39;
body = None
headers = {&#39;User-Agent&#39;: &#39;python-requests/2.28.1&#39;, &#39;Accept-Encoding&#39;: &#39;gzip, deflate&#39;, &#39;Accept&#39;: &#39;*/*&#39;, &#39;Connection&#39;: &#39;keep-alive&#39;, &#39;Content-Type&#39;: &#39;application/json&#39;, &#39;Authorization&#39;: &#39;Basic aW50cmFjbzpXYXNzaW1Db3ZhZ2VA&#39;}
retries = Retry(total=1, connect=None, read=None, redirect=None, status=None)
redirect = False, assert_same_host = False
timeout = Timeout(connect=None, read=None, total=None), pool_timeout = None
release_conn = False, chunked = False, body_pos = None
response_kw = {&#39;decode_content&#39;: False, &#39;preload_content&#39;: False, &#39;request_method&#39;: &#39;GET&#39;}
parsed_url = Url(scheme=None, auth=None, host=None, port=None, path=&#39;/api1/x3/erp/QAL/XSORDERCPV&#39;, query=&#39;representation=XSORDERCPV.%24query&amp;count=100&amp;where=YNATKM%20eq%204&amp;orderBy=UPDDATTIM%20desc&#39;, fragment=None)
destination_scheme = None
conn = &lt;urllib3.connection.HTTPSConnection object at 0x7f34bbfa78e0&gt;
release_this_conn = False, http_tunnel_required = True, err = None
clean_exit = True

    def urlopen(
        self,
        method,
        url,
        body=None,
        headers=None,
        retries=None,
        redirect=True,
        assert_same_host=True,
        timeout=_Default,
        pool_timeout=None,
        release_conn=None,
        chunked=False,
        body_pos=None,
        **response_kw
    ):
        &#34;&#34;&#34;
        Get a connection from the pool and perform an HTTP request. This is the
        lowest level call for making a request, so you&#39;ll need to specify all
        the raw details.
    
        .. note::
    
           More commonly, it&#39;s appropriate to use a convenience method provided
           by :class:`.RequestMethods`, such as :meth:`request`.
    
        .. note::
    
           `release_conn` will only behave as expected if
           `preload_content=False` because we want to make
           `preload_content=False` the default behaviour someday soon without
           breaking backwards compatibility.
    
        :param method:
            HTTP request method (such as GET, POST, PUT, etc.)
    
        :param url:
            The URL to perform the request on.
    
        :param body:
            Data to send in the request body, either :class:`str`, :class:`bytes`,
            an iterable of :class:`str`/:class:`bytes`, or a file-like object.
    
        :param headers:
            Dictionary of custom headers to send, such as User-Agent,
            If-None-Match, etc. If None, pool headers are used. If provided,
            these headers completely replace any pool-specific headers.
    
        :param retries:
            Configure the number of retries to allow before raising a
            :class:`~urllib3.exceptions.MaxRetryError` exception.
    
            Pass ``None`` to retry until you receive a response. Pass a
            :class:`~urllib3.util.retry.Retry` object for fine-grained control
            over different types of retries.
            Pass an integer number to retry connection errors that many times,
            but no other types of errors. Pass zero to never retry.
    
            If ``False``, then retries are disabled and any exception is raised
            immediately. Also, instead of raising a MaxRetryError on redirects,
            the redirect response will be returned.
    
        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.
    
        :param redirect:
            If True, automatically handle redirects (status codes 301, 302,
            303, 307, 308). Each redirect counts as a retry. Disabling retries
            will disable redirect, too.
    
        :param assert_same_host:
            If ``True``, will make sure that the host of the pool requests is
            consistent else will raise HostChangedError. When ``False``, you can
            use the pool on an HTTP proxy and request foreign hosts.
    
        :param timeout:
            If specified, overrides the default timeout for this one
            request. It may be a float (in seconds) or an instance of
            :class:`urllib3.util.Timeout`.
    
        :param pool_timeout:
            If set and the pool is set to block=True, then this method will
            block for ``pool_timeout`` seconds and raise EmptyPoolError if no
            connection is available within the time period.
    
        :param release_conn:
            If False, then the urlopen call will not release the connection
            back into the pool once a response is received (but will release if
            you read the entire contents of the response such as when
            `preload_content=True`). This is useful if you&#39;re not preloading
            the response&#39;s content immediately. You will need to call
            ``r.release_conn()`` on the response ``r`` to return the connection
            back into the pool. If None, it takes the value of
            ``response_kw.get(&#39;preload_content&#39;, True)``.
    
        :param chunked:
            If True, urllib3 will send the body using chunked transfer
            encoding. Otherwise, urllib3 will send the body using the standard
            content-length form. Defaults to False.
    
        :param int body_pos:
            Position to seek to in file-like body in the event of a retry or
            redirect. Typically this won&#39;t need to be set because urllib3 will
            auto-populate the value when needed.
    
        :param \\**response_kw:
            Additional parameters are passed to
            :meth:`urllib3.response.HTTPResponse.from_httplib`
        &#34;&#34;&#34;
    
        parsed_url = parse_url(url)
        destination_scheme = parsed_url.scheme
    
        if headers is None:
            headers = self.headers
    
        if not isinstance(retries, Retry):
            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)
    
        if release_conn is None:
            release_conn = response_kw.get(&#34;preload_content&#34;, True)
    
        # Check host
        if assert_same_host and not self.is_same_host(url):
            raise HostChangedError(self, url, retries)
    
        # Ensure that the URL we&#39;re connecting to is properly encoded
        if url.startswith(&#34;/&#34;):
            url = six.ensure_str(_encode_target(url))
        else:
            url = six.ensure_str(parsed_url.url)
    
        conn = None
    
        # Track whether `conn` needs to be released before
        # returning/raising/recursing. Update this variable if necessary, and
        # leave `release_conn` constant throughout the function. That way, if
        # the function recurses, the original value of `release_conn` will be
        # passed down into the recursive call, and its value will be respected.
        #
        # See issue #651 [1] for details.
        #
        # [1] &lt;https://github.com/urllib3/urllib3/issues/651&gt;
        release_this_conn = release_conn
    
        http_tunnel_required = connection_requires_http_tunnel(
            self.proxy, self.proxy_config, destination_scheme
        )
    
        # Merge the proxy headers. Only done when not using HTTP CONNECT. We
        # have to copy the headers dict so we can safely change it without those
        # changes being reflected in anyone else&#39;s copy.
        if not http_tunnel_required:
            headers = headers.copy()
            headers.update(self.proxy_headers)
    
        # Must keep the exception bound to a separate variable or else Python 3
        # complains about UnboundLocalError.
        err = None
    
        # Keep track of whether we cleanly exited the except block. This
        # ensures we do proper cleanup in finally.
        clean_exit = False
    
        # Rewind body position, if needed. Record current position
        # for future rewinds in the event of a redirect/retry.
        body_pos = set_file_position(body, body_pos)
    
        try:
            # Request a connection from the queue.
            timeout_obj = self._get_timeout(timeout)
            conn = self._get_conn(timeout=pool_timeout)
    
            conn.timeout = timeout_obj.connect_timeout
    
            is_new_proxy_conn = self.proxy is not None and not getattr(
                conn, &#34;sock&#34;, None
            )
            if is_new_proxy_conn and http_tunnel_required:
                self._prepare_proxy(conn)
    
            # Make the request on the httplib connection object.
            httplib_response = self._make_request(
                conn,
                method,
                url,
                timeout=timeout_obj,
                body=body,
                headers=headers,
                chunked=chunked,
            )
    
            # If we&#39;re going to release the connection in ``finally:``, then
            # the response doesn&#39;t need to know about the connection. Otherwise
            # it will also try to release it and we&#39;ll have a double-release
            # mess.
            response_conn = conn if not release_conn else None
    
            # Pass method to Response for length checking
            response_kw[&#34;request_method&#34;] = method
    
            # Import httplib&#39;s response into our own wrapper object
            response = self.ResponseCls.from_httplib(
                httplib_response,
                pool=self,
                connection=response_conn,
                retries=retries,
                **response_kw
            )
    
            # Everything went great!
            clean_exit = True
    
        except EmptyPoolError:
            # Didn&#39;t get a connection from the pool, no need to clean up
            clean_exit = True
            release_this_conn = False
            raise
    
        except (
            TimeoutError,
            HTTPException,
            SocketError,
            ProtocolError,
            BaseSSLError,
            SSLError,
            CertificateError,
        ) as e:
            # Discard the connection for these exceptions. It will be
            # replaced during the next _get_conn() call.
            clean_exit = False
    
            def _is_ssl_error_message_from_http_proxy(ssl_error):
                # We&#39;re trying to detect the message &#39;WRONG_VERSION_NUMBER&#39; but
                # SSLErrors are kinda all over the place when it comes to the message,
                # so we try to cover our bases here!
                message = &#34; &#34;.join(re.split(&#34;[^a-z]&#34;, str(ssl_error).lower()))
                return (
                    &#34;wrong version number&#34; in message or &#34;unknown protocol&#34; in message
                )
    
            # Try to detect a common user error with proxies which is to
            # set an HTTP proxy to be HTTPS when it should be &#39;http://&#39;
            # (ie {&#39;http&#39;: &#39;http://proxy&#39;, &#39;https&#39;: &#39;https://proxy&#39;})
            # Instead we add a nice error message and point to a URL.
            if (
                isinstance(e, BaseSSLError)
                and self.proxy
                and _is_ssl_error_message_from_http_proxy(e)
                and conn.proxy
                and conn.proxy.scheme == &#34;https&#34;
            ):
                e = ProxyError(
                    &#34;Your proxy appears to only use HTTP and not HTTPS, &#34;
                    &#34;try changing your proxy URL to be HTTP. See: &#34;
                    &#34;https://urllib3.readthedocs.io/en/1.26.x/advanced-usage.html&#34;
                    &#34;#https-proxy-error-http-proxy&#34;,
                    SSLError(e),
                )
            elif isinstance(e, (BaseSSLError, CertificateError)):
                e = SSLError(e)
            elif isinstance(e, (SocketError, NewConnectionError)) and self.proxy:
                e = ProxyError(&#34;Cannot connect to proxy.&#34;, e)
            elif isinstance(e, (SocketError, HTTPException)):
                e = ProtocolError(&#34;Connection aborted.&#34;, e)
    
            retries = retries.increment(
                method, url, error=e, _pool=self, _stacktrace=sys.exc_info()[2]
            )
            retries.sleep()
    
            # Keep track of the error for the retry warning.
            err = e
    
        finally:
            if not clean_exit:
                # We hit some kind of exception, handled or otherwise. We need
                # to throw the connection away unless explicitly told not to.
                # Close the connection, set the variable to None, and make sure
                # we put the None back in the pool to avoid leaking it.
                conn = conn and conn.close()
                release_this_conn = True
    
            if release_this_conn:
                # Put the connection back to be reused. If the connection is
                # expired then it will be None, which will get replaced with a
                # fresh connection during _get_conn.
                self._put_conn(conn)
    
        if not conn:
            # Try again
            log.warning(
                &#34;Retrying (%r) after connection broken by &#39;%r&#39;: %s&#34;, retries, err, url
            )
            return self.urlopen(
                method,
                url,
                body,
                headers,
                retries,
                redirect,
                assert_same_host,
                timeout=timeout,
                pool_timeout=pool_timeout,
                release_conn=release_conn,
                chunked=chunked,
                body_pos=body_pos,
                **response_kw
            )
    
        # Handle redirect?
        redirect_location = redirect and response.get_redirect_location()
        if redirect_location:
            if response.status == 303:
                method = &#34;GET&#34;
    
            try:
                retries = retries.increment(method, url, response=response, _pool=self)
            except MaxRetryError:
                if retries.raise_on_redirect:
                    response.drain_conn()
                    raise
                return response
    
            response.drain_conn()
            retries.sleep_for_retry(response)
            log.debug(&#34;Redirecting %s -&gt; %s&#34;, url, redirect_location)
            return self.urlopen(
                method,
                redirect_location,
                body,
                headers,
                retries=retries,
                redirect=redirect,
                assert_same_host=assert_same_host,
                timeout=timeout,
                pool_timeout=pool_timeout,
                release_conn=release_conn,
                chunked=chunked,
                body_pos=body_pos,
                **response_kw
            )
    
        # Check if we should retry the HTTP response.
        has_retry_after = bool(response.getheader(&#34;Retry-After&#34;))
        if retries.is_retry(method, response.status, has_retry_after):
            try:
                retries = retries.increment(method, url, response=response, _pool=self)
            except MaxRetryError:
                if retries.raise_on_status:
                    response.drain_conn()
                    raise
                return response
    
            response.drain_conn()
            retries.sleep(response)
            log.debug(&#34;Retry: %s&#34;, url)
&gt;           return self.urlopen(
                method,
                url,
                body,
                headers,
                retries=retries,
                redirect=redirect,
                assert_same_host=assert_same_host,
                timeout=timeout,
                pool_timeout=pool_timeout,
                release_conn=release_conn,
                chunked=chunked,
                body_pos=body_pos,
                **response_kw
            )

/usr/local/lib/python3.8/site-packages/urllib3/connectionpool.py:878: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connectionpool.HTTPSConnectionPool object at 0x7f34bbfa7460&gt;
method = &#39;GET&#39;
url = &#39;/api1/x3/erp/QAL/XSORDERCPV?representation=XSORDERCPV.%24query&amp;count=100&amp;where=YNATKM%20eq%204&amp;orderBy=UPDDATTIM%20desc&#39;
body = None
headers = {&#39;User-Agent&#39;: &#39;python-requests/2.28.1&#39;, &#39;Accept-Encoding&#39;: &#39;gzip, deflate&#39;, &#39;Accept&#39;: &#39;*/*&#39;, &#39;Connection&#39;: &#39;keep-alive&#39;, &#39;Content-Type&#39;: &#39;application/json&#39;, &#39;Authorization&#39;: &#39;Basic aW50cmFjbzpXYXNzaW1Db3ZhZ2VA&#39;}
retries = Retry(total=0, connect=None, read=None, redirect=None, status=None)
redirect = False, assert_same_host = False
timeout = Timeout(connect=None, read=None, total=None), pool_timeout = None
release_conn = False, chunked = False, body_pos = None
response_kw = {&#39;decode_content&#39;: False, &#39;preload_content&#39;: False, &#39;request_method&#39;: &#39;GET&#39;}
parsed_url = Url(scheme=None, auth=None, host=None, port=None, path=&#39;/api1/x3/erp/QAL/XSORDERCPV&#39;, query=&#39;representation=XSORDERCPV.%24query&amp;count=100&amp;where=YNATKM%20eq%204&amp;orderBy=UPDDATTIM%20desc&#39;, fragment=None)
destination_scheme = None
conn = &lt;urllib3.connection.HTTPSConnection object at 0x7f34bbfa78e0&gt;
release_this_conn = False, http_tunnel_required = True, err = None
clean_exit = True

    def urlopen(
        self,
        method,
        url,
        body=None,
        headers=None,
        retries=None,
        redirect=True,
        assert_same_host=True,
        timeout=_Default,
        pool_timeout=None,
        release_conn=None,
        chunked=False,
        body_pos=None,
        **response_kw
    ):
        &#34;&#34;&#34;
        Get a connection from the pool and perform an HTTP request. This is the
        lowest level call for making a request, so you&#39;ll need to specify all
        the raw details.
    
        .. note::
    
           More commonly, it&#39;s appropriate to use a convenience method provided
           by :class:`.RequestMethods`, such as :meth:`request`.
    
        .. note::
    
           `release_conn` will only behave as expected if
           `preload_content=False` because we want to make
           `preload_content=False` the default behaviour someday soon without
           breaking backwards compatibility.
    
        :param method:
            HTTP request method (such as GET, POST, PUT, etc.)
    
        :param url:
            The URL to perform the request on.
    
        :param body:
            Data to send in the request body, either :class:`str`, :class:`bytes`,
            an iterable of :class:`str`/:class:`bytes`, or a file-like object.
    
        :param headers:
            Dictionary of custom headers to send, such as User-Agent,
            If-None-Match, etc. If None, pool headers are used. If provided,
            these headers completely replace any pool-specific headers.
    
        :param retries:
            Configure the number of retries to allow before raising a
            :class:`~urllib3.exceptions.MaxRetryError` exception.
    
            Pass ``None`` to retry until you receive a response. Pass a
            :class:`~urllib3.util.retry.Retry` object for fine-grained control
            over different types of retries.
            Pass an integer number to retry connection errors that many times,
            but no other types of errors. Pass zero to never retry.
    
            If ``False``, then retries are disabled and any exception is raised
            immediately. Also, instead of raising a MaxRetryError on redirects,
            the redirect response will be returned.
    
        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.
    
        :param redirect:
            If True, automatically handle redirects (status codes 301, 302,
            303, 307, 308). Each redirect counts as a retry. Disabling retries
            will disable redirect, too.
    
        :param assert_same_host:
            If ``True``, will make sure that the host of the pool requests is
            consistent else will raise HostChangedError. When ``False``, you can
            use the pool on an HTTP proxy and request foreign hosts.
    
        :param timeout:
            If specified, overrides the default timeout for this one
            request. It may be a float (in seconds) or an instance of
            :class:`urllib3.util.Timeout`.
    
        :param pool_timeout:
            If set and the pool is set to block=True, then this method will
            block for ``pool_timeout`` seconds and raise EmptyPoolError if no
            connection is available within the time period.
    
        :param release_conn:
            If False, then the urlopen call will not release the connection
            back into the pool once a response is received (but will release if
            you read the entire contents of the response such as when
            `preload_content=True`). This is useful if you&#39;re not preloading
            the response&#39;s content immediately. You will need to call
            ``r.release_conn()`` on the response ``r`` to return the connection
            back into the pool. If None, it takes the value of
            ``response_kw.get(&#39;preload_content&#39;, True)``.
    
        :param chunked:
            If True, urllib3 will send the body using chunked transfer
            encoding. Otherwise, urllib3 will send the body using the standard
            content-length form. Defaults to False.
    
        :param int body_pos:
            Position to seek to in file-like body in the event of a retry or
            redirect. Typically this won&#39;t need to be set because urllib3 will
            auto-populate the value when needed.
    
        :param \\**response_kw:
            Additional parameters are passed to
            :meth:`urllib3.response.HTTPResponse.from_httplib`
        &#34;&#34;&#34;
    
        parsed_url = parse_url(url)
        destination_scheme = parsed_url.scheme
    
        if headers is None:
            headers = self.headers
    
        if not isinstance(retries, Retry):
            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)
    
        if release_conn is None:
            release_conn = response_kw.get(&#34;preload_content&#34;, True)
    
        # Check host
        if assert_same_host and not self.is_same_host(url):
            raise HostChangedError(self, url, retries)
    
        # Ensure that the URL we&#39;re connecting to is properly encoded
        if url.startswith(&#34;/&#34;):
            url = six.ensure_str(_encode_target(url))
        else:
            url = six.ensure_str(parsed_url.url)
    
        conn = None
    
        # Track whether `conn` needs to be released before
        # returning/raising/recursing. Update this variable if necessary, and
        # leave `release_conn` constant throughout the function. That way, if
        # the function recurses, the original value of `release_conn` will be
        # passed down into the recursive call, and its value will be respected.
        #
        # See issue #651 [1] for details.
        #
        # [1] &lt;https://github.com/urllib3/urllib3/issues/651&gt;
        release_this_conn = release_conn
    
        http_tunnel_required = connection_requires_http_tunnel(
            self.proxy, self.proxy_config, destination_scheme
        )
    
        # Merge the proxy headers. Only done when not using HTTP CONNECT. We
        # have to copy the headers dict so we can safely change it without those
        # changes being reflected in anyone else&#39;s copy.
        if not http_tunnel_required:
            headers = headers.copy()
            headers.update(self.proxy_headers)
    
        # Must keep the exception bound to a separate variable or else Python 3
        # complains about UnboundLocalError.
        err = None
    
        # Keep track of whether we cleanly exited the except block. This
        # ensures we do proper cleanup in finally.
        clean_exit = False
    
        # Rewind body position, if needed. Record current position
        # for future rewinds in the event of a redirect/retry.
        body_pos = set_file_position(body, body_pos)
    
        try:
            # Request a connection from the queue.
            timeout_obj = self._get_timeout(timeout)
            conn = self._get_conn(timeout=pool_timeout)
    
            conn.timeout = timeout_obj.connect_timeout
    
            is_new_proxy_conn = self.proxy is not None and not getattr(
                conn, &#34;sock&#34;, None
            )
            if is_new_proxy_conn and http_tunnel_required:
                self._prepare_proxy(conn)
    
            # Make the request on the httplib connection object.
            httplib_response = self._make_request(
                conn,
                method,
                url,
                timeout=timeout_obj,
                body=body,
                headers=headers,
                chunked=chunked,
            )
    
            # If we&#39;re going to release the connection in ``finally:``, then
            # the response doesn&#39;t need to know about the connection. Otherwise
            # it will also try to release it and we&#39;ll have a double-release
            # mess.
            response_conn = conn if not release_conn else None
    
            # Pass method to Response for length checking
            response_kw[&#34;request_method&#34;] = method
    
            # Import httplib&#39;s response into our own wrapper object
            response = self.ResponseCls.from_httplib(
                httplib_response,
                pool=self,
                connection=response_conn,
                retries=retries,
                **response_kw
            )
    
            # Everything went great!
            clean_exit = True
    
        except EmptyPoolError:
            # Didn&#39;t get a connection from the pool, no need to clean up
            clean_exit = True
            release_this_conn = False
            raise
    
        except (
            TimeoutError,
            HTTPException,
            SocketError,
            ProtocolError,
            BaseSSLError,
            SSLError,
            CertificateError,
        ) as e:
            # Discard the connection for these exceptions. It will be
            # replaced during the next _get_conn() call.
            clean_exit = False
    
            def _is_ssl_error_message_from_http_proxy(ssl_error):
                # We&#39;re trying to detect the message &#39;WRONG_VERSION_NUMBER&#39; but
                # SSLErrors are kinda all over the place when it comes to the message,
                # so we try to cover our bases here!
                message = &#34; &#34;.join(re.split(&#34;[^a-z]&#34;, str(ssl_error).lower()))
                return (
                    &#34;wrong version number&#34; in message or &#34;unknown protocol&#34; in message
                )
    
            # Try to detect a common user error with proxies which is to
            # set an HTTP proxy to be HTTPS when it should be &#39;http://&#39;
            # (ie {&#39;http&#39;: &#39;http://proxy&#39;, &#39;https&#39;: &#39;https://proxy&#39;})
            # Instead we add a nice error message and point to a URL.
            if (
                isinstance(e, BaseSSLError)
                and self.proxy
                and _is_ssl_error_message_from_http_proxy(e)
                and conn.proxy
                and conn.proxy.scheme == &#34;https&#34;
            ):
                e = ProxyError(
                    &#34;Your proxy appears to only use HTTP and not HTTPS, &#34;
                    &#34;try changing your proxy URL to be HTTP. See: &#34;
                    &#34;https://urllib3.readthedocs.io/en/1.26.x/advanced-usage.html&#34;
                    &#34;#https-proxy-error-http-proxy&#34;,
                    SSLError(e),
                )
            elif isinstance(e, (BaseSSLError, CertificateError)):
                e = SSLError(e)
            elif isinstance(e, (SocketError, NewConnectionError)) and self.proxy:
                e = ProxyError(&#34;Cannot connect to proxy.&#34;, e)
            elif isinstance(e, (SocketError, HTTPException)):
                e = ProtocolError(&#34;Connection aborted.&#34;, e)
    
            retries = retries.increment(
                method, url, error=e, _pool=self, _stacktrace=sys.exc_info()[2]
            )
            retries.sleep()
    
            # Keep track of the error for the retry warning.
            err = e
    
        finally:
            if not clean_exit:
                # We hit some kind of exception, handled or otherwise. We need
                # to throw the connection away unless explicitly told not to.
                # Close the connection, set the variable to None, and make sure
                # we put the None back in the pool to avoid leaking it.
                conn = conn and conn.close()
                release_this_conn = True
    
            if release_this_conn:
                # Put the connection back to be reused. If the connection is
                # expired then it will be None, which will get replaced with a
                # fresh connection during _get_conn.
                self._put_conn(conn)
    
        if not conn:
            # Try again
            log.warning(
                &#34;Retrying (%r) after connection broken by &#39;%r&#39;: %s&#34;, retries, err, url
            )
            return self.urlopen(
                method,
                url,
                body,
                headers,
                retries,
                redirect,
                assert_same_host,
                timeout=timeout,
                pool_timeout=pool_timeout,
                release_conn=release_conn,
                chunked=chunked,
                body_pos=body_pos,
                **response_kw
            )
    
        # Handle redirect?
        redirect_location = redirect and response.get_redirect_location()
        if redirect_location:
            if response.status == 303:
                method = &#34;GET&#34;
    
            try:
                retries = retries.increment(method, url, response=response, _pool=self)
            except MaxRetryError:
                if retries.raise_on_redirect:
                    response.drain_conn()
                    raise
                return response
    
            response.drain_conn()
            retries.sleep_for_retry(response)
            log.debug(&#34;Redirecting %s -&gt; %s&#34;, url, redirect_location)
            return self.urlopen(
                method,
                redirect_location,
                body,
                headers,
                retries=retries,
                redirect=redirect,
                assert_same_host=assert_same_host,
                timeout=timeout,
                pool_timeout=pool_timeout,
                release_conn=release_conn,
                chunked=chunked,
                body_pos=body_pos,
                **response_kw
            )
    
        # Check if we should retry the HTTP response.
        has_retry_after = bool(response.getheader(&#34;Retry-After&#34;))
        if retries.is_retry(method, response.status, has_retry_after):
            try:
                retries = retries.increment(method, url, response=response, _pool=self)
            except MaxRetryError:
                if retries.raise_on_status:
                    response.drain_conn()
                    raise
                return response
    
            response.drain_conn()
            retries.sleep(response)
            log.debug(&#34;Retry: %s&#34;, url)
&gt;           return self.urlopen(
                method,
                url,
                body,
                headers,
                retries=retries,
                redirect=redirect,
                assert_same_host=assert_same_host,
                timeout=timeout,
                pool_timeout=pool_timeout,
                release_conn=release_conn,
                chunked=chunked,
                body_pos=body_pos,
                **response_kw
            )

/usr/local/lib/python3.8/site-packages/urllib3/connectionpool.py:878: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connectionpool.HTTPSConnectionPool object at 0x7f34bbfa7460&gt;
method = &#39;GET&#39;
url = &#39;/api1/x3/erp/QAL/XSORDERCPV?representation=XSORDERCPV.%24query&amp;count=100&amp;where=YNATKM%20eq%204&amp;orderBy=UPDDATTIM%20desc&#39;
body = None
headers = {&#39;User-Agent&#39;: &#39;python-requests/2.28.1&#39;, &#39;Accept-Encoding&#39;: &#39;gzip, deflate&#39;, &#39;Accept&#39;: &#39;*/*&#39;, &#39;Connection&#39;: &#39;keep-alive&#39;, &#39;Content-Type&#39;: &#39;application/json&#39;, &#39;Authorization&#39;: &#39;Basic aW50cmFjbzpXYXNzaW1Db3ZhZ2VA&#39;}
retries = Retry(total=0, connect=None, read=None, redirect=None, status=None)
redirect = False, assert_same_host = False
timeout = Timeout(connect=None, read=None, total=None), pool_timeout = None
release_conn = False, chunked = False, body_pos = None
response_kw = {&#39;decode_content&#39;: False, &#39;preload_content&#39;: False, &#39;request_method&#39;: &#39;GET&#39;}
parsed_url = Url(scheme=None, auth=None, host=None, port=None, path=&#39;/api1/x3/erp/QAL/XSORDERCPV&#39;, query=&#39;representation=XSORDERCPV.%24query&amp;count=100&amp;where=YNATKM%20eq%204&amp;orderBy=UPDDATTIM%20desc&#39;, fragment=None)
destination_scheme = None
conn = &lt;urllib3.connection.HTTPSConnection object at 0x7f34bbfa78e0&gt;
release_this_conn = False, http_tunnel_required = True, err = None
clean_exit = True

    def urlopen(
        self,
        method,
        url,
        body=None,
        headers=None,
        retries=None,
        redirect=True,
        assert_same_host=True,
        timeout=_Default,
        pool_timeout=None,
        release_conn=None,
        chunked=False,
        body_pos=None,
        **response_kw
    ):
        &#34;&#34;&#34;
        Get a connection from the pool and perform an HTTP request. This is the
        lowest level call for making a request, so you&#39;ll need to specify all
        the raw details.
    
        .. note::
    
           More commonly, it&#39;s appropriate to use a convenience method provided
           by :class:`.RequestMethods`, such as :meth:`request`.
    
        .. note::
    
           `release_conn` will only behave as expected if
           `preload_content=False` because we want to make
           `preload_content=False` the default behaviour someday soon without
           breaking backwards compatibility.
    
        :param method:
            HTTP request method (such as GET, POST, PUT, etc.)
    
        :param url:
            The URL to perform the request on.
    
        :param body:
            Data to send in the request body, either :class:`str`, :class:`bytes`,
            an iterable of :class:`str`/:class:`bytes`, or a file-like object.
    
        :param headers:
            Dictionary of custom headers to send, such as User-Agent,
            If-None-Match, etc. If None, pool headers are used. If provided,
            these headers completely replace any pool-specific headers.
    
        :param retries:
            Configure the number of retries to allow before raising a
            :class:`~urllib3.exceptions.MaxRetryError` exception.
    
            Pass ``None`` to retry until you receive a response. Pass a
            :class:`~urllib3.util.retry.Retry` object for fine-grained control
            over different types of retries.
            Pass an integer number to retry connection errors that many times,
            but no other types of errors. Pass zero to never retry.
    
            If ``False``, then retries are disabled and any exception is raised
            immediately. Also, instead of raising a MaxRetryError on redirects,
            the redirect response will be returned.
    
        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.
    
        :param redirect:
            If True, automatically handle redirects (status codes 301, 302,
            303, 307, 308). Each redirect counts as a retry. Disabling retries
            will disable redirect, too.
    
        :param assert_same_host:
            If ``True``, will make sure that the host of the pool requests is
            consistent else will raise HostChangedError. When ``False``, you can
            use the pool on an HTTP proxy and request foreign hosts.
    
        :param timeout:
            If specified, overrides the default timeout for this one
            request. It may be a float (in seconds) or an instance of
            :class:`urllib3.util.Timeout`.
    
        :param pool_timeout:
            If set and the pool is set to block=True, then this method will
            block for ``pool_timeout`` seconds and raise EmptyPoolError if no
            connection is available within the time period.
    
        :param release_conn:
            If False, then the urlopen call will not release the connection
            back into the pool once a response is received (but will release if
            you read the entire contents of the response such as when
            `preload_content=True`). This is useful if you&#39;re not preloading
            the response&#39;s content immediately. You will need to call
            ``r.release_conn()`` on the response ``r`` to return the connection
            back into the pool. If None, it takes the value of
            ``response_kw.get(&#39;preload_content&#39;, True)``.
    
        :param chunked:
            If True, urllib3 will send the body using chunked transfer
            encoding. Otherwise, urllib3 will send the body using the standard
            content-length form. Defaults to False.
    
        :param int body_pos:
            Position to seek to in file-like body in the event of a retry or
            redirect. Typically this won&#39;t need to be set because urllib3 will
            auto-populate the value when needed.
    
        :param \\**response_kw:
            Additional parameters are passed to
            :meth:`urllib3.response.HTTPResponse.from_httplib`
        &#34;&#34;&#34;
    
        parsed_url = parse_url(url)
        destination_scheme = parsed_url.scheme
    
        if headers is None:
            headers = self.headers
    
        if not isinstance(retries, Retry):
            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)
    
        if release_conn is None:
            release_conn = response_kw.get(&#34;preload_content&#34;, True)
    
        # Check host
        if assert_same_host and not self.is_same_host(url):
            raise HostChangedError(self, url, retries)
    
        # Ensure that the URL we&#39;re connecting to is properly encoded
        if url.startswith(&#34;/&#34;):
            url = six.ensure_str(_encode_target(url))
        else:
            url = six.ensure_str(parsed_url.url)
    
        conn = None
    
        # Track whether `conn` needs to be released before
        # returning/raising/recursing. Update this variable if necessary, and
        # leave `release_conn` constant throughout the function. That way, if
        # the function recurses, the original value of `release_conn` will be
        # passed down into the recursive call, and its value will be respected.
        #
        # See issue #651 [1] for details.
        #
        # [1] &lt;https://github.com/urllib3/urllib3/issues/651&gt;
        release_this_conn = release_conn
    
        http_tunnel_required = connection_requires_http_tunnel(
            self.proxy, self.proxy_config, destination_scheme
        )
    
        # Merge the proxy headers. Only done when not using HTTP CONNECT. We
        # have to copy the headers dict so we can safely change it without those
        # changes being reflected in anyone else&#39;s copy.
        if not http_tunnel_required:
            headers = headers.copy()
            headers.update(self.proxy_headers)
    
        # Must keep the exception bound to a separate variable or else Python 3
        # complains about UnboundLocalError.
        err = None
    
        # Keep track of whether we cleanly exited the except block. This
        # ensures we do proper cleanup in finally.
        clean_exit = False
    
        # Rewind body position, if needed. Record current position
        # for future rewinds in the event of a redirect/retry.
        body_pos = set_file_position(body, body_pos)
    
        try:
            # Request a connection from the queue.
            timeout_obj = self._get_timeout(timeout)
            conn = self._get_conn(timeout=pool_timeout)
    
            conn.timeout = timeout_obj.connect_timeout
    
            is_new_proxy_conn = self.proxy is not None and not getattr(
                conn, &#34;sock&#34;, None
            )
            if is_new_proxy_conn and http_tunnel_required:
                self._prepare_proxy(conn)
    
            # Make the request on the httplib connection object.
            httplib_response = self._make_request(
                conn,
                method,
                url,
                timeout=timeout_obj,
                body=body,
                headers=headers,
                chunked=chunked,
            )
    
            # If we&#39;re going to release the connection in ``finally:``, then
            # the response doesn&#39;t need to know about the connection. Otherwise
            # it will also try to release it and we&#39;ll have a double-release
            # mess.
            response_conn = conn if not release_conn else None
    
            # Pass method to Response for length checking
            response_kw[&#34;request_method&#34;] = method
    
            # Import httplib&#39;s response into our own wrapper object
            response = self.ResponseCls.from_httplib(
                httplib_response,
                pool=self,
                connection=response_conn,
                retries=retries,
                **response_kw
            )
    
            # Everything went great!
            clean_exit = True
    
        except EmptyPoolError:
            # Didn&#39;t get a connection from the pool, no need to clean up
            clean_exit = True
            release_this_conn = False
            raise
    
        except (
            TimeoutError,
            HTTPException,
            SocketError,
            ProtocolError,
            BaseSSLError,
            SSLError,
            CertificateError,
        ) as e:
            # Discard the connection for these exceptions. It will be
            # replaced during the next _get_conn() call.
            clean_exit = False
    
            def _is_ssl_error_message_from_http_proxy(ssl_error):
                # We&#39;re trying to detect the message &#39;WRONG_VERSION_NUMBER&#39; but
                # SSLErrors are kinda all over the place when it comes to the message,
                # so we try to cover our bases here!
                message = &#34; &#34;.join(re.split(&#34;[^a-z]&#34;, str(ssl_error).lower()))
                return (
                    &#34;wrong version number&#34; in message or &#34;unknown protocol&#34; in message
                )
    
            # Try to detect a common user error with proxies which is to
            # set an HTTP proxy to be HTTPS when it should be &#39;http://&#39;
            # (ie {&#39;http&#39;: &#39;http://proxy&#39;, &#39;https&#39;: &#39;https://proxy&#39;})
            # Instead we add a nice error message and point to a URL.
            if (
                isinstance(e, BaseSSLError)
                and self.proxy
                and _is_ssl_error_message_from_http_proxy(e)
                and conn.proxy
                and conn.proxy.scheme == &#34;https&#34;
            ):
                e = ProxyError(
                    &#34;Your proxy appears to only use HTTP and not HTTPS, &#34;
                    &#34;try changing your proxy URL to be HTTP. See: &#34;
                    &#34;https://urllib3.readthedocs.io/en/1.26.x/advanced-usage.html&#34;
                    &#34;#https-proxy-error-http-proxy&#34;,
                    SSLError(e),
                )
            elif isinstance(e, (BaseSSLError, CertificateError)):
                e = SSLError(e)
            elif isinstance(e, (SocketError, NewConnectionError)) and self.proxy:
                e = ProxyError(&#34;Cannot connect to proxy.&#34;, e)
            elif isinstance(e, (SocketError, HTTPException)):
                e = ProtocolError(&#34;Connection aborted.&#34;, e)
    
            retries = retries.increment(
                method, url, error=e, _pool=self, _stacktrace=sys.exc_info()[2]
            )
            retries.sleep()
    
            # Keep track of the error for the retry warning.
            err = e
    
        finally:
            if not clean_exit:
                # We hit some kind of exception, handled or otherwise. We need
                # to throw the connection away unless explicitly told not to.
                # Close the connection, set the variable to None, and make sure
                # we put the None back in the pool to avoid leaking it.
                conn = conn and conn.close()
                release_this_conn = True
    
            if release_this_conn:
                # Put the connection back to be reused. If the connection is
                # expired then it will be None, which will get replaced with a
                # fresh connection during _get_conn.
                self._put_conn(conn)
    
        if not conn:
            # Try again
            log.warning(
                &#34;Retrying (%r) after connection broken by &#39;%r&#39;: %s&#34;, retries, err, url
            )
            return self.urlopen(
                method,
                url,
                body,
                headers,
                retries,
                redirect,
                assert_same_host,
                timeout=timeout,
                pool_timeout=pool_timeout,
                release_conn=release_conn,
                chunked=chunked,
                body_pos=body_pos,
                **response_kw
            )
    
        # Handle redirect?
        redirect_location = redirect and response.get_redirect_location()
        if redirect_location:
            if response.status == 303:
                method = &#34;GET&#34;
    
            try:
                retries = retries.increment(method, url, response=response, _pool=self)
            except MaxRetryError:
                if retries.raise_on_redirect:
                    response.drain_conn()
                    raise
                return response
    
            response.drain_conn()
            retries.sleep_for_retry(response)
            log.debug(&#34;Redirecting %s -&gt; %s&#34;, url, redirect_location)
            return self.urlopen(
                method,
                redirect_location,
                body,
                headers,
                retries=retries,
                redirect=redirect,
                assert_same_host=assert_same_host,
                timeout=timeout,
                pool_timeout=pool_timeout,
                release_conn=release_conn,
                chunked=chunked,
                body_pos=body_pos,
                **response_kw
            )
    
        # Check if we should retry the HTTP response.
        has_retry_after = bool(response.getheader(&#34;Retry-After&#34;))
        if retries.is_retry(method, response.status, has_retry_after):
            try:
&gt;               retries = retries.increment(method, url, response=response, _pool=self)

/usr/local/lib/python3.8/site-packages/urllib3/connectionpool.py:868: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Retry(total=0, connect=None, read=None, redirect=None, status=None)
method = &#39;GET&#39;
url = &#39;/api1/x3/erp/QAL/XSORDERCPV?representation=XSORDERCPV.%24query&amp;count=100&amp;where=YNATKM%20eq%204&amp;orderBy=UPDDATTIM%20desc&#39;
response = &lt;urllib3.response.HTTPResponse object at 0x7f34bbc8f400&gt;
error = None
_pool = &lt;urllib3.connectionpool.HTTPSConnectionPool object at 0x7f34bbfa7460&gt;
_stacktrace = None

    def increment(
        self,
        method=None,
        url=None,
        response=None,
        error=None,
        _pool=None,
        _stacktrace=None,
    ):
        &#34;&#34;&#34;Return a new Retry object with incremented retry counters.
    
        :param response: A response object, or None, if the server did not
            return a response.
        :type response: :class:`~urllib3.response.HTTPResponse`
        :param Exception error: An error encountered during the request, or
            None if the response was received successfully.
    
        :return: A new ``Retry`` object.
        &#34;&#34;&#34;
        if self.total is False and error:
            # Disabled, indicate to re-raise the error.
            raise six.reraise(type(error), error, _stacktrace)
    
        total = self.total
        if total is not None:
            total -= 1
    
        connect = self.connect
        read = self.read
        redirect = self.redirect
        status_count = self.status
        other = self.other
        cause = &#34;unknown&#34;
        status = None
        redirect_location = None
    
        if error and self._is_connection_error(error):
            # Connect retry?
            if connect is False:
                raise six.reraise(type(error), error, _stacktrace)
            elif connect is not None:
                connect -= 1
    
        elif error and self._is_read_error(error):
            # Read retry?
            if read is False or not self._is_method_retryable(method):
                raise six.reraise(type(error), error, _stacktrace)
            elif read is not None:
                read -= 1
    
        elif error:
            # Other retry?
            if other is not None:
                other -= 1
    
        elif response and response.get_redirect_location():
            # Redirect retry?
            if redirect is not None:
                redirect -= 1
            cause = &#34;too many redirects&#34;
            redirect_location = response.get_redirect_location()
            status = response.status
    
        else:
            # Incrementing because of a server error like a 500 in
            # status_forcelist and the given method is in the allowed_methods
            cause = ResponseError.GENERIC_ERROR
            if response and response.status:
                if status_count is not None:
                    status_count -= 1
                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)
                status = response.status
    
        history = self.history + (
            RequestHistory(method, url, error, status, redirect_location),
        )
    
        new_retry = self.new(
            total=total,
            connect=connect,
            read=read,
            redirect=redirect,
            status=status_count,
            other=other,
            history=history,
        )
    
        if new_retry.is_exhausted():
&gt;           raise MaxRetryError(_pool, url, error or ResponseError(cause))
E           urllib3.exceptions.MaxRetryError: HTTPSConnectionPool(host=&#39;sagex3-horsprod.covage.com&#39;, port=443): Max retries exceeded with url: /api1/x3/erp/QAL/XSORDERCPV?representation=XSORDERCPV.%24query&amp;count=100&amp;where=YNATKM%20eq%204&amp;orderBy=UPDDATTIM%20desc (Caused by ResponseError(&#39;too many 502 error responses&#39;))

/usr/local/lib/python3.8/site-packages/urllib3/util/retry.py:592: MaxRetryError

During handling of the above exception, another exception occurred:

x3_client = &lt;x3_wrapper.rest_client.X3RestClient object at 0x7f34bbd67580&gt;

    @pytest.mark.livetest
    @pytest.mark.xfail
    @pytest.mark.read_data
    def test_x3_schema_query_cpv(x3_client):
        &#34;&#34;&#34;
        Validate CPV schema representation `XSORDERCPV` query
        &#34;&#34;&#34;
        params = {&#34;where&#34;: &#34;YNATKM eq 4&#34;, &#34;orderBy&#34;: &#34;UPDDATTIM desc&#34;}  # Filter only CPV
&gt;       resp = x3_client.list(
            class_name=&#34;XSORDERCPV&#34;, representation=&#34;XSORDERCPV&#34;, count=100, **params
        )

app/api/live_tests/test_cpv/test_query_cpv.py:15: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
app/x3_wrapper/rest_client.py:84: in list
    resp = self._cal_x3(&#34;GET&#34;, url, query_params)
app/x3_wrapper/rest_client.py:70: in _cal_x3
    resp = self.client.request(method, url, params=query_params)
/usr/local/lib/python3.8/site-packages/requests/sessions.py:587: in request
    resp = self.send(prep, **send_kwargs)
/usr/local/lib/python3.8/site-packages/requests/sessions.py:701: in send
    r = adapter.send(request, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;requests.adapters.HTTPAdapter object at 0x7f34bbfa76a0&gt;
request = &lt;PreparedRequest [GET]&gt;, stream = False
timeout = Timeout(connect=None, read=None, total=None), verify = True
cert = None
proxies = OrderedDict([(&#39;no&#39;, &#39;gitlab-runner-cache-01-prd.nut.covage.com&#39;), (&#39;http&#39;, &#39;http://squid.kosc.net:3128&#39;), (&#39;https&#39;, &#39;http://squid.kosc.net:3128&#39;)])

    def send(
        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None
    ):
        &#34;&#34;&#34;Sends PreparedRequest object. Returns Response object.
    
        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.
        :param stream: (optional) Whether to stream the request content.
        :param timeout: (optional) How long to wait for the server to send
            data before giving up, as a float, or a :ref:`(connect timeout,
            read timeout) &lt;timeouts&gt;` tuple.
        :type timeout: float or tuple or urllib3 Timeout object
        :param verify: (optional) Either a boolean, in which case it controls whether
            we verify the server&#39;s TLS certificate, or a string, in which case it
            must be a path to a CA bundle to use
        :param cert: (optional) Any user-provided SSL certificate to be trusted.
        :param proxies: (optional) The proxies dictionary to apply to the request.
        :rtype: requests.Response
        &#34;&#34;&#34;
    
        try:
            conn = self.get_connection(request.url, proxies)
        except LocationValueError as e:
            raise InvalidURL(e, request=request)
    
        self.cert_verify(conn, request.url, verify, cert)
        url = self.request_url(request, proxies)
        self.add_headers(
            request,
            stream=stream,
            timeout=timeout,
            verify=verify,
            cert=cert,
            proxies=proxies,
        )
    
        chunked = not (request.body is None or &#34;Content-Length&#34; in request.headers)
    
        if isinstance(timeout, tuple):
            try:
                connect, read = timeout
                timeout = TimeoutSauce(connect=connect, read=read)
            except ValueError:
                raise ValueError(
                    f&#34;Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, &#34;
                    f&#34;or a single float to set both timeouts to the same value.&#34;
                )
        elif isinstance(timeout, TimeoutSauce):
            pass
        else:
            timeout = TimeoutSauce(connect=timeout, read=timeout)
    
        try:
            if not chunked:
                resp = conn.urlopen(
                    method=request.method,
                    url=url,
                    body=request.body,
                    headers=request.headers,
                    redirect=False,
                    assert_same_host=False,
                    preload_content=False,
                    decode_content=False,
                    retries=self.max_retries,
                    timeout=timeout,
                )
    
            # Send the request.
            else:
                if hasattr(conn, &#34;proxy_pool&#34;):
                    conn = conn.proxy_pool
    
                low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)
    
                try:
                    skip_host = &#34;Host&#34; in request.headers
                    low_conn.putrequest(
                        request.method,
                        url,
                        skip_accept_encoding=True,
                        skip_host=skip_host,
                    )
    
                    for header, value in request.headers.items():
                        low_conn.putheader(header, value)
    
                    low_conn.endheaders()
    
                    for i in request.body:
                        low_conn.send(hex(len(i))[2:].encode(&#34;utf-8&#34;))
                        low_conn.send(b&#34;\r\n&#34;)
                        low_conn.send(i)
                        low_conn.send(b&#34;\r\n&#34;)
                    low_conn.send(b&#34;0\r\n\r\n&#34;)
    
                    # Receive the response from the server
                    r = low_conn.getresponse()
    
                    resp = HTTPResponse.from_httplib(
                        r,
                        pool=conn,
                        connection=low_conn,
                        preload_content=False,
                        decode_content=False,
                    )
                except Exception:
                    # If we hit any problems here, clean up the connection.
                    # Then, raise so that we can handle the actual exception.
                    low_conn.close()
                    raise
    
        except (ProtocolError, OSError) as err:
            raise ConnectionError(err, request=request)
    
        except MaxRetryError as e:
            if isinstance(e.reason, ConnectTimeoutError):
                # TODO: Remove this in 3.0.0: see #2811
                if not isinstance(e.reason, NewConnectionError):
                    raise ConnectTimeout(e, request=request)
    
            if isinstance(e.reason, ResponseError):
&gt;               raise RetryError(e, request=request)
E               requests.exceptions.RetryError: HTTPSConnectionPool(host=&#39;sagex3-horsprod.covage.com&#39;, port=443): Max retries exceeded with url: /api1/x3/erp/QAL/XSORDERCPV?representation=XSORDERCPV.%24query&amp;count=100&amp;where=YNATKM%20eq%204&amp;orderBy=UPDDATTIM%20desc (Caused by ResponseError(&#39;too many 502 error responses&#39;))

/usr/local/lib/python3.8/site-packages/requests/adapters.py:556: RetryError</pre> </div> </div> </details> <details class="phase teardown "> <summary> <h4 class=title> <span class=phase-name>Teardown</span> </h4> </summary> <div class=content> </div> </details> </div> </div> </details> <details class="test xfailed"> <summary> <h3 class="title test-title"> <span class="status badge xfailed ">XFAIL</span> <span class=test-name> <span class=funcname>test_api_schema_list_cpv</span> </span> <span class=duration>0:00:00.729916</span> </h3> </summary> <div class=content> <div class=documentation> <p>Test api route <cite>/api/v0/cpv/</cite> + pagination + filters</p> </div> <table class=metadata> <tr> <th>Started</th> <td>2023-06-30 01:14:52</td> </tr> <tr> <th>Ended</th> <td>2023-06-30 01:14:52</td> </tr> <tr> <th>Duration</th> <td>0:00:00.729916</td> </tr> <tr> <th>Markers</th> <td> <div class=marker> <span class="marker-name badge">read_data</span> <span class=marker-args> </span> </div> <div class=marker> <span class="marker-name badge">xfail</span> <span class=marker-args> </span> </div> <div class=marker> <span class="marker-name badge">livetest</span> <span class=marker-args> </span> </div> </td> </tr> <tr> <th>Fixtures</th> <td> <span class="badge fixturename"> django_test_environment </span> <span class="badge fixturename"> django_db_blocker </span> <span class="badge fixturename"> test_client </span> <span class="badge fixturename"> request </span> </td> </tr> </table> <div class=repr> <pre>AssertionError: b&#39;{&#34;detail&#34;:&#34;Server Error (500)&#34;,&#34;status_code&#34;:500}&#39;
assert 500 == 200
 +  where 500 = &lt;Response [500]&gt;.status_code</pre> </div> <div class=test-phases> <details class="phase setup "> <summary> <h4 class=title> <span class=phase-name>Setup</span> </h4> </summary> <div class=content> </div> </details> <details class="phase call xfailed" open> <summary> <h4 class=title> <span class="status  xfailed"></span> <span class=phase-name>Call</span> </h4> </summary> <div class=content> <div class=repr> <pre>test_client = &lt;conftest.LiveServerSession object at 0x7f34bba6ba30&gt;

    @pytest.mark.livetest
    @pytest.mark.xfail
    @pytest.mark.read_data
    def test_api_schema_list_cpv(test_client):
        &#34;&#34;&#34;Test api route `/api/v0/cpv/` + pagination + filters&#34;&#34;&#34;
        # test list cpv
        resp_1 = test_client.get(&#34;/api/v0/cpv/&#34;, params={&#34;order_by&#34;: &#34;UPDDATTIM desc&#34;})
&gt;       assert resp_1.status_code == 200, resp_1.content
E       AssertionError: b&#39;{&#34;detail&#34;:&#34;Server Error (500)&#34;,&#34;status_code&#34;:500}&#39;
E       assert 500 == 200
E        +  where 500 = &lt;Response [500]&gt;.status_code

app/api/live_tests/test_cpv/test_query_cpv.py:28: AssertionError</pre> </div> </div> </details> <details class="phase teardown "> <summary> <h4 class=title> <span class=phase-name>Teardown</span> </h4> </summary> <div class=content> </div> </details> </div> </div> </details> </div> </details> <details class=file> <summary> <h2 class="title file-title"> <span class=fspath> app/api/live_tests/test_customer/test_detail_customer.py </span> <span class=counts> <span title="2 xfailed" class="count status badge xfailed ">2</span> </span> <span class=duration> 0:00:01.459243 </span> </h2> </summary> <div class="content box"> <details class="test xfailed"> <summary> <h3 class="title test-title"> <span class="status badge xfailed ">XFAIL</span> <span class=test-name> <span class=funcname>test_x3_schema_detail_customer</span> </span> <span class=duration>0:00:00.730107</span> </h3> </summary> <div class=content> <div class=documentation> <p>Validate X3 catalog schema representation <cite>XBPCUSTOMER</cite> details</p> </div> <table class=metadata> <tr> <th>Started</th> <td>2023-06-30 01:14:52</td> </tr> <tr> <th>Ended</th> <td>2023-06-30 01:14:53</td> </tr> <tr> <th>Duration</th> <td>0:00:00.730107</td> </tr> <tr> <th>Markers</th> <td> <div class=marker> <span class="marker-name badge">read_data</span> <span class=marker-args> </span> </div> <div class=marker> <span class="marker-name badge">xfail</span> <span class=marker-args> </span> </div> <div class=marker> <span class="marker-name badge">livetest</span> <span class=marker-args> </span> </div> </td> </tr> <tr> <th>Fixtures</th> <td> <span class="badge fixturename"> django_test_environment </span> <span class="badge fixturename"> django_db_blocker </span> <span class="badge fixturename"> test_client </span> <span class="badge fixturename"> x3_client </span> <span class="badge fixturename"> request </span> </td> </tr> </table> <div class=repr> <pre>AssertionError: b&#39;{&#34;detail&#34;:&#34;Server Error (500)&#34;,&#34;status_code&#34;:500}&#39;
assert 500 == 200
 +  where 500 = &lt;Response [500]&gt;.status_code</pre> </div> <div class=test-phases> <details class="phase setup "> <summary> <h4 class=title> <span class=phase-name>Setup</span> </h4> </summary> <div class=content> </div> </details> <details class="phase call xfailed" open> <summary> <h4 class=title> <span class="status  xfailed"></span> <span class=phase-name>Call</span> </h4> </summary> <div class=content> <div class=repr> <pre>test_client = &lt;conftest.LiveServerSession object at 0x7f34c0478940&gt;
x3_client = &lt;x3_wrapper.rest_client.X3RestClient object at 0x7f34c04851f0&gt;

    @pytest.mark.livetest
    @pytest.mark.xfail
    @pytest.mark.read_data
    def test_x3_schema_detail_customer(test_client, x3_client):
        &#34;&#34;&#34;Validate X3 catalog schema representation `XBPCUSTOMER` details&#34;&#34;&#34;
&gt;       bpc_num = get_random_customer_ref(test_client)

app/api/live_tests/test_customer/test_detail_customer.py:26: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

test_client = &lt;conftest.LiveServerSession object at 0x7f34c0478940&gt;

    def get_random_customer_ref(test_client):
        params = {
            &#34;order_by&#34;: &#34;UPDDATTIM desc&#34;,
        }
        resp = test_client.get(&#34;/api/v0/customers/&#34;, params=params)
&gt;       assert resp.status_code == 200, resp.content
E       AssertionError: b&#39;{&#34;detail&#34;:&#34;Server Error (500)&#34;,&#34;status_code&#34;:500}&#39;
E       assert 500 == 200
E        +  where 500 = &lt;Response [500]&gt;.status_code

app/api/live_tests/test_customer/test_detail_customer.py:17: AssertionError</pre> </div> </div> </details> <details class="phase teardown "> <summary> <h4 class=title> <span class=phase-name>Teardown</span> </h4> </summary> <div class=content> </div> </details> </div> </div> </details> <details class="test xfailed"> <summary> <h3 class="title test-title"> <span class="status badge xfailed ">XFAIL</span> <span class=test-name> <span class=funcname>test_api_schema_details_customer</span> </span> <span class=duration>0:00:00.729137</span> </h3> </summary> <div class=content> <div class=documentation> <p>Validate api response schema for route <cite>/customers/:bpc_num</cite></p> </div> <table class=metadata> <tr> <th>Started</th> <td>2023-06-30 01:14:53</td> </tr> <tr> <th>Ended</th> <td>2023-06-30 01:14:54</td> </tr> <tr> <th>Duration</th> <td>0:00:00.729137</td> </tr> <tr> <th>Markers</th> <td> <div class=marker> <span class="marker-name badge">read_data</span> <span class=marker-args> </span> </div> <div class=marker> <span class="marker-name badge">xfail</span> <span class=marker-args> </span> </div> <div class=marker> <span class="marker-name badge">livetest</span> <span class=marker-args> </span> </div> </td> </tr> <tr> <th>Fixtures</th> <td> <span class="badge fixturename"> django_test_environment </span> <span class="badge fixturename"> django_db_blocker </span> <span class="badge fixturename"> test_client </span> <span class="badge fixturename"> request </span> </td> </tr> </table> <div class=repr> <pre>AssertionError: b&#39;{&#34;detail&#34;:&#34;Server Error (500)&#34;,&#34;status_code&#34;:500}&#39;
assert 500 == 200
 +  where 500 = &lt;Response [500]&gt;.status_code</pre> </div> <div class=test-phases> <details class="phase setup "> <summary> <h4 class=title> <span class=phase-name>Setup</span> </h4> </summary> <div class=content> </div> </details> <details class="phase call xfailed" open> <summary> <h4 class=title> <span class="status  xfailed"></span> <span class=phase-name>Call</span> </h4> </summary> <div class=content> <div class=repr> <pre>test_client = &lt;conftest.LiveServerSession object at 0x7f34c0e65220&gt;

    @pytest.mark.livetest
    @pytest.mark.xfail
    @pytest.mark.read_data
    def test_api_schema_details_customer(test_client):
        &#34;&#34;&#34;Validate api response schema for route `/customers/:bpc_num`&#34;&#34;&#34;
&gt;       bpc_num = get_random_customer_ref(test_client)

app/api/live_tests/test_customer/test_detail_customer.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

test_client = &lt;conftest.LiveServerSession object at 0x7f34c0e65220&gt;

    def get_random_customer_ref(test_client):
        params = {
            &#34;order_by&#34;: &#34;UPDDATTIM desc&#34;,
        }
        resp = test_client.get(&#34;/api/v0/customers/&#34;, params=params)
&gt;       assert resp.status_code == 200, resp.content
E       AssertionError: b&#39;{&#34;detail&#34;:&#34;Server Error (500)&#34;,&#34;status_code&#34;:500}&#39;
E       assert 500 == 200
E        +  where 500 = &lt;Response [500]&gt;.status_code

app/api/live_tests/test_customer/test_detail_customer.py:17: AssertionError</pre> </div> </div> </details> <details class="phase teardown "> <summary> <h4 class=title> <span class=phase-name>Teardown</span> </h4> </summary> <div class=content> </div> </details> </div> </div> </details> </div> </details> <details class=file> <summary> <h2 class="title file-title"> <span class=fspath> app/api/live_tests/test_customer/test_query_customer.py </span> <span class=counts> <span title="2 xfailed" class="count status badge xfailed ">2</span> </span> <span class=duration> 0:00:01.395443 </span> </h2> </summary> <div class="content box"> <details class="test xfailed"> <summary> <h3 class="title test-title"> <span class="status badge xfailed ">XFAIL</span> <span class=test-name> <span class=funcname>test_x3_schema_query_customer</span> </span> <span class=duration>0:00:00.669741</span> </h3> </summary> <div class=content> <div class=documentation> <p>Validate customer schema representation <cite>XBPCUSTOMER</cite> query</p> </div> <table class=metadata> <tr> <th>Started</th> <td>2023-06-30 01:14:54</td> </tr> <tr> <th>Ended</th> <td>2023-06-30 01:14:55</td> </tr> <tr> <th>Duration</th> <td>0:00:00.669741</td> </tr> <tr> <th>Markers</th> <td> <div class=marker> <span class="marker-name badge">read_data</span> <span class=marker-args> </span> </div> <div class=marker> <span class="marker-name badge">xfail</span> <span class=marker-args> </span> </div> <div class=marker> <span class="marker-name badge">livetest</span> <span class=marker-args> </span> </div> </td> </tr> <tr> <th>Fixtures</th> <td> <span class="badge fixturename"> django_test_environment </span> <span class="badge fixturename"> django_db_blocker </span> <span class="badge fixturename"> x3_client </span> <span class="badge fixturename"> request </span> </td> </tr> </table> <div class=repr> <pre>requests.exceptions.RetryError: HTTPSConnectionPool(host=&#39;sagex3-horsprod.covage.com&#39;, port=443): Max retries exceeded with url: /api1/x3/erp/QAL/BPCUSTOMER?representation=XBPCUSTOMER.%24query&amp;count=20 (Caused by ResponseError(&#39;too many 502 error responses&#39;))</pre> </div> <div class=test-phases> <details class="phase setup "> <summary> <h4 class=title> <span class=phase-name>Setup</span> </h4> </summary> <div class=content> </div> </details> <details class="phase call xfailed" open> <summary> <h4 class=title> <span class="status  xfailed"></span> <span class=phase-name>Call</span> </h4> </summary> <div class=content> <div class=repr> <pre>self = &lt;requests.adapters.HTTPAdapter object at 0x7f34bbe3b160&gt;
request = &lt;PreparedRequest [GET]&gt;, stream = False
timeout = Timeout(connect=None, read=None, total=None), verify = True
cert = None
proxies = OrderedDict([(&#39;no&#39;, &#39;gitlab-runner-cache-01-prd.nut.covage.com&#39;), (&#39;http&#39;, &#39;http://squid.kosc.net:3128&#39;), (&#39;https&#39;, &#39;http://squid.kosc.net:3128&#39;)])

    def send(
        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None
    ):
        &#34;&#34;&#34;Sends PreparedRequest object. Returns Response object.
    
        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.
        :param stream: (optional) Whether to stream the request content.
        :param timeout: (optional) How long to wait for the server to send
            data before giving up, as a float, or a :ref:`(connect timeout,
            read timeout) &lt;timeouts&gt;` tuple.
        :type timeout: float or tuple or urllib3 Timeout object
        :param verify: (optional) Either a boolean, in which case it controls whether
            we verify the server&#39;s TLS certificate, or a string, in which case it
            must be a path to a CA bundle to use
        :param cert: (optional) Any user-provided SSL certificate to be trusted.
        :param proxies: (optional) The proxies dictionary to apply to the request.
        :rtype: requests.Response
        &#34;&#34;&#34;
    
        try:
            conn = self.get_connection(request.url, proxies)
        except LocationValueError as e:
            raise InvalidURL(e, request=request)
    
        self.cert_verify(conn, request.url, verify, cert)
        url = self.request_url(request, proxies)
        self.add_headers(
            request,
            stream=stream,
            timeout=timeout,
            verify=verify,
            cert=cert,
            proxies=proxies,
        )
    
        chunked = not (request.body is None or &#34;Content-Length&#34; in request.headers)
    
        if isinstance(timeout, tuple):
            try:
                connect, read = timeout
                timeout = TimeoutSauce(connect=connect, read=read)
            except ValueError:
                raise ValueError(
                    f&#34;Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, &#34;
                    f&#34;or a single float to set both timeouts to the same value.&#34;
                )
        elif isinstance(timeout, TimeoutSauce):
            pass
        else:
            timeout = TimeoutSauce(connect=timeout, read=timeout)
    
        try:
            if not chunked:
&gt;               resp = conn.urlopen(
                    method=request.method,
                    url=url,
                    body=request.body,
                    headers=request.headers,
                    redirect=False,
                    assert_same_host=False,
                    preload_content=False,
                    decode_content=False,
                    retries=self.max_retries,
                    timeout=timeout,
                )

/usr/local/lib/python3.8/site-packages/requests/adapters.py:489: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connectionpool.HTTPSConnectionPool object at 0x7f34bbe3b070&gt;
method = &#39;GET&#39;
url = &#39;/api1/x3/erp/QAL/BPCUSTOMER?representation=XBPCUSTOMER.%24query&amp;count=20&#39;
body = None
headers = {&#39;User-Agent&#39;: &#39;python-requests/2.28.1&#39;, &#39;Accept-Encoding&#39;: &#39;gzip, deflate&#39;, &#39;Accept&#39;: &#39;*/*&#39;, &#39;Connection&#39;: &#39;keep-alive&#39;, &#39;Content-Type&#39;: &#39;application/json&#39;, &#39;Authorization&#39;: &#39;Basic aW50cmFjbzpXYXNzaW1Db3ZhZ2VA&#39;}
retries = Retry(total=2, connect=None, read=None, redirect=None, status=None)
redirect = False, assert_same_host = False
timeout = Timeout(connect=None, read=None, total=None), pool_timeout = None
release_conn = False, chunked = False, body_pos = None
response_kw = {&#39;decode_content&#39;: False, &#39;preload_content&#39;: False, &#39;request_method&#39;: &#39;GET&#39;}
parsed_url = Url(scheme=None, auth=None, host=None, port=None, path=&#39;/api1/x3/erp/QAL/BPCUSTOMER&#39;, query=&#39;representation=XBPCUSTOMER.%24query&amp;count=20&#39;, fragment=None)
destination_scheme = None
conn = &lt;urllib3.connection.HTTPSConnection object at 0x7f34c0474f40&gt;
release_this_conn = False, http_tunnel_required = True, err = None
clean_exit = True

    def urlopen(
        self,
        method,
        url,
        body=None,
        headers=None,
        retries=None,
        redirect=True,
        assert_same_host=True,
        timeout=_Default,
        pool_timeout=None,
        release_conn=None,
        chunked=False,
        body_pos=None,
        **response_kw
    ):
        &#34;&#34;&#34;
        Get a connection from the pool and perform an HTTP request. This is the
        lowest level call for making a request, so you&#39;ll need to specify all
        the raw details.
    
        .. note::
    
           More commonly, it&#39;s appropriate to use a convenience method provided
           by :class:`.RequestMethods`, such as :meth:`request`.
    
        .. note::
    
           `release_conn` will only behave as expected if
           `preload_content=False` because we want to make
           `preload_content=False` the default behaviour someday soon without
           breaking backwards compatibility.
    
        :param method:
            HTTP request method (such as GET, POST, PUT, etc.)
    
        :param url:
            The URL to perform the request on.
    
        :param body:
            Data to send in the request body, either :class:`str`, :class:`bytes`,
            an iterable of :class:`str`/:class:`bytes`, or a file-like object.
    
        :param headers:
            Dictionary of custom headers to send, such as User-Agent,
            If-None-Match, etc. If None, pool headers are used. If provided,
            these headers completely replace any pool-specific headers.
    
        :param retries:
            Configure the number of retries to allow before raising a
            :class:`~urllib3.exceptions.MaxRetryError` exception.
    
            Pass ``None`` to retry until you receive a response. Pass a
            :class:`~urllib3.util.retry.Retry` object for fine-grained control
            over different types of retries.
            Pass an integer number to retry connection errors that many times,
            but no other types of errors. Pass zero to never retry.
    
            If ``False``, then retries are disabled and any exception is raised
            immediately. Also, instead of raising a MaxRetryError on redirects,
            the redirect response will be returned.
    
        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.
    
        :param redirect:
            If True, automatically handle redirects (status codes 301, 302,
            303, 307, 308). Each redirect counts as a retry. Disabling retries
            will disable redirect, too.
    
        :param assert_same_host:
            If ``True``, will make sure that the host of the pool requests is
            consistent else will raise HostChangedError. When ``False``, you can
            use the pool on an HTTP proxy and request foreign hosts.
    
        :param timeout:
            If specified, overrides the default timeout for this one
            request. It may be a float (in seconds) or an instance of
            :class:`urllib3.util.Timeout`.
    
        :param pool_timeout:
            If set and the pool is set to block=True, then this method will
            block for ``pool_timeout`` seconds and raise EmptyPoolError if no
            connection is available within the time period.
    
        :param release_conn:
            If False, then the urlopen call will not release the connection
            back into the pool once a response is received (but will release if
            you read the entire contents of the response such as when
            `preload_content=True`). This is useful if you&#39;re not preloading
            the response&#39;s content immediately. You will need to call
            ``r.release_conn()`` on the response ``r`` to return the connection
            back into the pool. If None, it takes the value of
            ``response_kw.get(&#39;preload_content&#39;, True)``.
    
        :param chunked:
            If True, urllib3 will send the body using chunked transfer
            encoding. Otherwise, urllib3 will send the body using the standard
            content-length form. Defaults to False.
    
        :param int body_pos:
            Position to seek to in file-like body in the event of a retry or
            redirect. Typically this won&#39;t need to be set because urllib3 will
            auto-populate the value when needed.
    
        :param \\**response_kw:
            Additional parameters are passed to
            :meth:`urllib3.response.HTTPResponse.from_httplib`
        &#34;&#34;&#34;
    
        parsed_url = parse_url(url)
        destination_scheme = parsed_url.scheme
    
        if headers is None:
            headers = self.headers
    
        if not isinstance(retries, Retry):
            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)
    
        if release_conn is None:
            release_conn = response_kw.get(&#34;preload_content&#34;, True)
    
        # Check host
        if assert_same_host and not self.is_same_host(url):
            raise HostChangedError(self, url, retries)
    
        # Ensure that the URL we&#39;re connecting to is properly encoded
        if url.startswith(&#34;/&#34;):
            url = six.ensure_str(_encode_target(url))
        else:
            url = six.ensure_str(parsed_url.url)
    
        conn = None
    
        # Track whether `conn` needs to be released before
        # returning/raising/recursing. Update this variable if necessary, and
        # leave `release_conn` constant throughout the function. That way, if
        # the function recurses, the original value of `release_conn` will be
        # passed down into the recursive call, and its value will be respected.
        #
        # See issue #651 [1] for details.
        #
        # [1] &lt;https://github.com/urllib3/urllib3/issues/651&gt;
        release_this_conn = release_conn
    
        http_tunnel_required = connection_requires_http_tunnel(
            self.proxy, self.proxy_config, destination_scheme
        )
    
        # Merge the proxy headers. Only done when not using HTTP CONNECT. We
        # have to copy the headers dict so we can safely change it without those
        # changes being reflected in anyone else&#39;s copy.
        if not http_tunnel_required:
            headers = headers.copy()
            headers.update(self.proxy_headers)
    
        # Must keep the exception bound to a separate variable or else Python 3
        # complains about UnboundLocalError.
        err = None
    
        # Keep track of whether we cleanly exited the except block. This
        # ensures we do proper cleanup in finally.
        clean_exit = False
    
        # Rewind body position, if needed. Record current position
        # for future rewinds in the event of a redirect/retry.
        body_pos = set_file_position(body, body_pos)
    
        try:
            # Request a connection from the queue.
            timeout_obj = self._get_timeout(timeout)
            conn = self._get_conn(timeout=pool_timeout)
    
            conn.timeout = timeout_obj.connect_timeout
    
            is_new_proxy_conn = self.proxy is not None and not getattr(
                conn, &#34;sock&#34;, None
            )
            if is_new_proxy_conn and http_tunnel_required:
                self._prepare_proxy(conn)
    
            # Make the request on the httplib connection object.
            httplib_response = self._make_request(
                conn,
                method,
                url,
                timeout=timeout_obj,
                body=body,
                headers=headers,
                chunked=chunked,
            )
    
            # If we&#39;re going to release the connection in ``finally:``, then
            # the response doesn&#39;t need to know about the connection. Otherwise
            # it will also try to release it and we&#39;ll have a double-release
            # mess.
            response_conn = conn if not release_conn else None
    
            # Pass method to Response for length checking
            response_kw[&#34;request_method&#34;] = method
    
            # Import httplib&#39;s response into our own wrapper object
            response = self.ResponseCls.from_httplib(
                httplib_response,
                pool=self,
                connection=response_conn,
                retries=retries,
                **response_kw
            )
    
            # Everything went great!
            clean_exit = True
    
        except EmptyPoolError:
            # Didn&#39;t get a connection from the pool, no need to clean up
            clean_exit = True
            release_this_conn = False
            raise
    
        except (
            TimeoutError,
            HTTPException,
            SocketError,
            ProtocolError,
            BaseSSLError,
            SSLError,
            CertificateError,
        ) as e:
            # Discard the connection for these exceptions. It will be
            # replaced during the next _get_conn() call.
            clean_exit = False
    
            def _is_ssl_error_message_from_http_proxy(ssl_error):
                # We&#39;re trying to detect the message &#39;WRONG_VERSION_NUMBER&#39; but
                # SSLErrors are kinda all over the place when it comes to the message,
                # so we try to cover our bases here!
                message = &#34; &#34;.join(re.split(&#34;[^a-z]&#34;, str(ssl_error).lower()))
                return (
                    &#34;wrong version number&#34; in message or &#34;unknown protocol&#34; in message
                )
    
            # Try to detect a common user error with proxies which is to
            # set an HTTP proxy to be HTTPS when it should be &#39;http://&#39;
            # (ie {&#39;http&#39;: &#39;http://proxy&#39;, &#39;https&#39;: &#39;https://proxy&#39;})
            # Instead we add a nice error message and point to a URL.
            if (
                isinstance(e, BaseSSLError)
                and self.proxy
                and _is_ssl_error_message_from_http_proxy(e)
                and conn.proxy
                and conn.proxy.scheme == &#34;https&#34;
            ):
                e = ProxyError(
                    &#34;Your proxy appears to only use HTTP and not HTTPS, &#34;
                    &#34;try changing your proxy URL to be HTTP. See: &#34;
                    &#34;https://urllib3.readthedocs.io/en/1.26.x/advanced-usage.html&#34;
                    &#34;#https-proxy-error-http-proxy&#34;,
                    SSLError(e),
                )
            elif isinstance(e, (BaseSSLError, CertificateError)):
                e = SSLError(e)
            elif isinstance(e, (SocketError, NewConnectionError)) and self.proxy:
                e = ProxyError(&#34;Cannot connect to proxy.&#34;, e)
            elif isinstance(e, (SocketError, HTTPException)):
                e = ProtocolError(&#34;Connection aborted.&#34;, e)
    
            retries = retries.increment(
                method, url, error=e, _pool=self, _stacktrace=sys.exc_info()[2]
            )
            retries.sleep()
    
            # Keep track of the error for the retry warning.
            err = e
    
        finally:
            if not clean_exit:
                # We hit some kind of exception, handled or otherwise. We need
                # to throw the connection away unless explicitly told not to.
                # Close the connection, set the variable to None, and make sure
                # we put the None back in the pool to avoid leaking it.
                conn = conn and conn.close()
                release_this_conn = True
    
            if release_this_conn:
                # Put the connection back to be reused. If the connection is
                # expired then it will be None, which will get replaced with a
                # fresh connection during _get_conn.
                self._put_conn(conn)
    
        if not conn:
            # Try again
            log.warning(
                &#34;Retrying (%r) after connection broken by &#39;%r&#39;: %s&#34;, retries, err, url
            )
            return self.urlopen(
                method,
                url,
                body,
                headers,
                retries,
                redirect,
                assert_same_host,
                timeout=timeout,
                pool_timeout=pool_timeout,
                release_conn=release_conn,
                chunked=chunked,
                body_pos=body_pos,
                **response_kw
            )
    
        # Handle redirect?
        redirect_location = redirect and response.get_redirect_location()
        if redirect_location:
            if response.status == 303:
                method = &#34;GET&#34;
    
            try:
                retries = retries.increment(method, url, response=response, _pool=self)
            except MaxRetryError:
                if retries.raise_on_redirect:
                    response.drain_conn()
                    raise
                return response
    
            response.drain_conn()
            retries.sleep_for_retry(response)
            log.debug(&#34;Redirecting %s -&gt; %s&#34;, url, redirect_location)
            return self.urlopen(
                method,
                redirect_location,
                body,
                headers,
                retries=retries,
                redirect=redirect,
                assert_same_host=assert_same_host,
                timeout=timeout,
                pool_timeout=pool_timeout,
                release_conn=release_conn,
                chunked=chunked,
                body_pos=body_pos,
                **response_kw
            )
    
        # Check if we should retry the HTTP response.
        has_retry_after = bool(response.getheader(&#34;Retry-After&#34;))
        if retries.is_retry(method, response.status, has_retry_after):
            try:
                retries = retries.increment(method, url, response=response, _pool=self)
            except MaxRetryError:
                if retries.raise_on_status:
                    response.drain_conn()
                    raise
                return response
    
            response.drain_conn()
            retries.sleep(response)
            log.debug(&#34;Retry: %s&#34;, url)
&gt;           return self.urlopen(
                method,
                url,
                body,
                headers,
                retries=retries,
                redirect=redirect,
                assert_same_host=assert_same_host,
                timeout=timeout,
                pool_timeout=pool_timeout,
                release_conn=release_conn,
                chunked=chunked,
                body_pos=body_pos,
                **response_kw
            )

/usr/local/lib/python3.8/site-packages/urllib3/connectionpool.py:878: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connectionpool.HTTPSConnectionPool object at 0x7f34bbe3b070&gt;
method = &#39;GET&#39;
url = &#39;/api1/x3/erp/QAL/BPCUSTOMER?representation=XBPCUSTOMER.%24query&amp;count=20&#39;
body = None
headers = {&#39;User-Agent&#39;: &#39;python-requests/2.28.1&#39;, &#39;Accept-Encoding&#39;: &#39;gzip, deflate&#39;, &#39;Accept&#39;: &#39;*/*&#39;, &#39;Connection&#39;: &#39;keep-alive&#39;, &#39;Content-Type&#39;: &#39;application/json&#39;, &#39;Authorization&#39;: &#39;Basic aW50cmFjbzpXYXNzaW1Db3ZhZ2VA&#39;}
retries = Retry(total=1, connect=None, read=None, redirect=None, status=None)
redirect = False, assert_same_host = False
timeout = Timeout(connect=None, read=None, total=None), pool_timeout = None
release_conn = False, chunked = False, body_pos = None
response_kw = {&#39;decode_content&#39;: False, &#39;preload_content&#39;: False, &#39;request_method&#39;: &#39;GET&#39;}
parsed_url = Url(scheme=None, auth=None, host=None, port=None, path=&#39;/api1/x3/erp/QAL/BPCUSTOMER&#39;, query=&#39;representation=XBPCUSTOMER.%24query&amp;count=20&#39;, fragment=None)
destination_scheme = None
conn = &lt;urllib3.connection.HTTPSConnection object at 0x7f34c0474f40&gt;
release_this_conn = False, http_tunnel_required = True, err = None
clean_exit = True

    def urlopen(
        self,
        method,
        url,
        body=None,
        headers=None,
        retries=None,
        redirect=True,
        assert_same_host=True,
        timeout=_Default,
        pool_timeout=None,
        release_conn=None,
        chunked=False,
        body_pos=None,
        **response_kw
    ):
        &#34;&#34;&#34;
        Get a connection from the pool and perform an HTTP request. This is the
        lowest level call for making a request, so you&#39;ll need to specify all
        the raw details.
    
        .. note::
    
           More commonly, it&#39;s appropriate to use a convenience method provided
           by :class:`.RequestMethods`, such as :meth:`request`.
    
        .. note::
    
           `release_conn` will only behave as expected if
           `preload_content=False` because we want to make
           `preload_content=False` the default behaviour someday soon without
           breaking backwards compatibility.
    
        :param method:
            HTTP request method (such as GET, POST, PUT, etc.)
    
        :param url:
            The URL to perform the request on.
    
        :param body:
            Data to send in the request body, either :class:`str`, :class:`bytes`,
            an iterable of :class:`str`/:class:`bytes`, or a file-like object.
    
        :param headers:
            Dictionary of custom headers to send, such as User-Agent,
            If-None-Match, etc. If None, pool headers are used. If provided,
            these headers completely replace any pool-specific headers.
    
        :param retries:
            Configure the number of retries to allow before raising a
            :class:`~urllib3.exceptions.MaxRetryError` exception.
    
            Pass ``None`` to retry until you receive a response. Pass a
            :class:`~urllib3.util.retry.Retry` object for fine-grained control
            over different types of retries.
            Pass an integer number to retry connection errors that many times,
            but no other types of errors. Pass zero to never retry.
    
            If ``False``, then retries are disabled and any exception is raised
            immediately. Also, instead of raising a MaxRetryError on redirects,
            the redirect response will be returned.
    
        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.
    
        :param redirect:
            If True, automatically handle redirects (status codes 301, 302,
            303, 307, 308). Each redirect counts as a retry. Disabling retries
            will disable redirect, too.
    
        :param assert_same_host:
            If ``True``, will make sure that the host of the pool requests is
            consistent else will raise HostChangedError. When ``False``, you can
            use the pool on an HTTP proxy and request foreign hosts.
    
        :param timeout:
            If specified, overrides the default timeout for this one
            request. It may be a float (in seconds) or an instance of
            :class:`urllib3.util.Timeout`.
    
        :param pool_timeout:
            If set and the pool is set to block=True, then this method will
            block for ``pool_timeout`` seconds and raise EmptyPoolError if no
            connection is available within the time period.
    
        :param release_conn:
            If False, then the urlopen call will not release the connection
            back into the pool once a response is received (but will release if
            you read the entire contents of the response such as when
            `preload_content=True`). This is useful if you&#39;re not preloading
            the response&#39;s content immediately. You will need to call
            ``r.release_conn()`` on the response ``r`` to return the connection
            back into the pool. If None, it takes the value of
            ``response_kw.get(&#39;preload_content&#39;, True)``.
    
        :param chunked:
            If True, urllib3 will send the body using chunked transfer
            encoding. Otherwise, urllib3 will send the body using the standard
            content-length form. Defaults to False.
    
        :param int body_pos:
            Position to seek to in file-like body in the event of a retry or
            redirect. Typically this won&#39;t need to be set because urllib3 will
            auto-populate the value when needed.
    
        :param \\**response_kw:
            Additional parameters are passed to
            :meth:`urllib3.response.HTTPResponse.from_httplib`
        &#34;&#34;&#34;
    
        parsed_url = parse_url(url)
        destination_scheme = parsed_url.scheme
    
        if headers is None:
            headers = self.headers
    
        if not isinstance(retries, Retry):
            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)
    
        if release_conn is None:
            release_conn = response_kw.get(&#34;preload_content&#34;, True)
    
        # Check host
        if assert_same_host and not self.is_same_host(url):
            raise HostChangedError(self, url, retries)
    
        # Ensure that the URL we&#39;re connecting to is properly encoded
        if url.startswith(&#34;/&#34;):
            url = six.ensure_str(_encode_target(url))
        else:
            url = six.ensure_str(parsed_url.url)
    
        conn = None
    
        # Track whether `conn` needs to be released before
        # returning/raising/recursing. Update this variable if necessary, and
        # leave `release_conn` constant throughout the function. That way, if
        # the function recurses, the original value of `release_conn` will be
        # passed down into the recursive call, and its value will be respected.
        #
        # See issue #651 [1] for details.
        #
        # [1] &lt;https://github.com/urllib3/urllib3/issues/651&gt;
        release_this_conn = release_conn
    
        http_tunnel_required = connection_requires_http_tunnel(
            self.proxy, self.proxy_config, destination_scheme
        )
    
        # Merge the proxy headers. Only done when not using HTTP CONNECT. We
        # have to copy the headers dict so we can safely change it without those
        # changes being reflected in anyone else&#39;s copy.
        if not http_tunnel_required:
            headers = headers.copy()
            headers.update(self.proxy_headers)
    
        # Must keep the exception bound to a separate variable or else Python 3
        # complains about UnboundLocalError.
        err = None
    
        # Keep track of whether we cleanly exited the except block. This
        # ensures we do proper cleanup in finally.
        clean_exit = False
    
        # Rewind body position, if needed. Record current position
        # for future rewinds in the event of a redirect/retry.
        body_pos = set_file_position(body, body_pos)
    
        try:
            # Request a connection from the queue.
            timeout_obj = self._get_timeout(timeout)
            conn = self._get_conn(timeout=pool_timeout)
    
            conn.timeout = timeout_obj.connect_timeout
    
            is_new_proxy_conn = self.proxy is not None and not getattr(
                conn, &#34;sock&#34;, None
            )
            if is_new_proxy_conn and http_tunnel_required:
                self._prepare_proxy(conn)
    
            # Make the request on the httplib connection object.
            httplib_response = self._make_request(
                conn,
                method,
                url,
                timeout=timeout_obj,
                body=body,
                headers=headers,
                chunked=chunked,
            )
    
            # If we&#39;re going to release the connection in ``finally:``, then
            # the response doesn&#39;t need to know about the connection. Otherwise
            # it will also try to release it and we&#39;ll have a double-release
            # mess.
            response_conn = conn if not release_conn else None
    
            # Pass method to Response for length checking
            response_kw[&#34;request_method&#34;] = method
    
            # Import httplib&#39;s response into our own wrapper object
            response = self.ResponseCls.from_httplib(
                httplib_response,
                pool=self,
                connection=response_conn,
                retries=retries,
                **response_kw
            )
    
            # Everything went great!
            clean_exit = True
    
        except EmptyPoolError:
            # Didn&#39;t get a connection from the pool, no need to clean up
            clean_exit = True
            release_this_conn = False
            raise
    
        except (
            TimeoutError,
            HTTPException,
            SocketError,
            ProtocolError,
            BaseSSLError,
            SSLError,
            CertificateError,
        ) as e:
            # Discard the connection for these exceptions. It will be
            # replaced during the next _get_conn() call.
            clean_exit = False
    
            def _is_ssl_error_message_from_http_proxy(ssl_error):
                # We&#39;re trying to detect the message &#39;WRONG_VERSION_NUMBER&#39; but
                # SSLErrors are kinda all over the place when it comes to the message,
                # so we try to cover our bases here!
                message = &#34; &#34;.join(re.split(&#34;[^a-z]&#34;, str(ssl_error).lower()))
                return (
                    &#34;wrong version number&#34; in message or &#34;unknown protocol&#34; in message
                )
    
            # Try to detect a common user error with proxies which is to
            # set an HTTP proxy to be HTTPS when it should be &#39;http://&#39;
            # (ie {&#39;http&#39;: &#39;http://proxy&#39;, &#39;https&#39;: &#39;https://proxy&#39;})
            # Instead we add a nice error message and point to a URL.
            if (
                isinstance(e, BaseSSLError)
                and self.proxy
                and _is_ssl_error_message_from_http_proxy(e)
                and conn.proxy
                and conn.proxy.scheme == &#34;https&#34;
            ):
                e = ProxyError(
                    &#34;Your proxy appears to only use HTTP and not HTTPS, &#34;
                    &#34;try changing your proxy URL to be HTTP. See: &#34;
                    &#34;https://urllib3.readthedocs.io/en/1.26.x/advanced-usage.html&#34;
                    &#34;#https-proxy-error-http-proxy&#34;,
                    SSLError(e),
                )
            elif isinstance(e, (BaseSSLError, CertificateError)):
                e = SSLError(e)
            elif isinstance(e, (SocketError, NewConnectionError)) and self.proxy:
                e = ProxyError(&#34;Cannot connect to proxy.&#34;, e)
            elif isinstance(e, (SocketError, HTTPException)):
                e = ProtocolError(&#34;Connection aborted.&#34;, e)
    
            retries = retries.increment(
                method, url, error=e, _pool=self, _stacktrace=sys.exc_info()[2]
            )
            retries.sleep()
    
            # Keep track of the error for the retry warning.
            err = e
    
        finally:
            if not clean_exit:
                # We hit some kind of exception, handled or otherwise. We need
                # to throw the connection away unless explicitly told not to.
                # Close the connection, set the variable to None, and make sure
                # we put the None back in the pool to avoid leaking it.
                conn = conn and conn.close()
                release_this_conn = True
    
            if release_this_conn:
                # Put the connection back to be reused. If the connection is
                # expired then it will be None, which will get replaced with a
                # fresh connection during _get_conn.
                self._put_conn(conn)
    
        if not conn:
            # Try again
            log.warning(
                &#34;Retrying (%r) after connection broken by &#39;%r&#39;: %s&#34;, retries, err, url
            )
            return self.urlopen(
                method,
                url,
                body,
                headers,
                retries,
                redirect,
                assert_same_host,
                timeout=timeout,
                pool_timeout=pool_timeout,
                release_conn=release_conn,
                chunked=chunked,
                body_pos=body_pos,
                **response_kw
            )
    
        # Handle redirect?
        redirect_location = redirect and response.get_redirect_location()
        if redirect_location:
            if response.status == 303:
                method = &#34;GET&#34;
    
            try:
                retries = retries.increment(method, url, response=response, _pool=self)
            except MaxRetryError:
                if retries.raise_on_redirect:
                    response.drain_conn()
                    raise
                return response
    
            response.drain_conn()
            retries.sleep_for_retry(response)
            log.debug(&#34;Redirecting %s -&gt; %s&#34;, url, redirect_location)
            return self.urlopen(
                method,
                redirect_location,
                body,
                headers,
                retries=retries,
                redirect=redirect,
                assert_same_host=assert_same_host,
                timeout=timeout,
                pool_timeout=pool_timeout,
                release_conn=release_conn,
                chunked=chunked,
                body_pos=body_pos,
                **response_kw
            )
    
        # Check if we should retry the HTTP response.
        has_retry_after = bool(response.getheader(&#34;Retry-After&#34;))
        if retries.is_retry(method, response.status, has_retry_after):
            try:
                retries = retries.increment(method, url, response=response, _pool=self)
            except MaxRetryError:
                if retries.raise_on_status:
                    response.drain_conn()
                    raise
                return response
    
            response.drain_conn()
            retries.sleep(response)
            log.debug(&#34;Retry: %s&#34;, url)
&gt;           return self.urlopen(
                method,
                url,
                body,
                headers,
                retries=retries,
                redirect=redirect,
                assert_same_host=assert_same_host,
                timeout=timeout,
                pool_timeout=pool_timeout,
                release_conn=release_conn,
                chunked=chunked,
                body_pos=body_pos,
                **response_kw
            )

/usr/local/lib/python3.8/site-packages/urllib3/connectionpool.py:878: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connectionpool.HTTPSConnectionPool object at 0x7f34bbe3b070&gt;
method = &#39;GET&#39;
url = &#39;/api1/x3/erp/QAL/BPCUSTOMER?representation=XBPCUSTOMER.%24query&amp;count=20&#39;
body = None
headers = {&#39;User-Agent&#39;: &#39;python-requests/2.28.1&#39;, &#39;Accept-Encoding&#39;: &#39;gzip, deflate&#39;, &#39;Accept&#39;: &#39;*/*&#39;, &#39;Connection&#39;: &#39;keep-alive&#39;, &#39;Content-Type&#39;: &#39;application/json&#39;, &#39;Authorization&#39;: &#39;Basic aW50cmFjbzpXYXNzaW1Db3ZhZ2VA&#39;}
retries = Retry(total=0, connect=None, read=None, redirect=None, status=None)
redirect = False, assert_same_host = False
timeout = Timeout(connect=None, read=None, total=None), pool_timeout = None
release_conn = False, chunked = False, body_pos = None
response_kw = {&#39;decode_content&#39;: False, &#39;preload_content&#39;: False, &#39;request_method&#39;: &#39;GET&#39;}
parsed_url = Url(scheme=None, auth=None, host=None, port=None, path=&#39;/api1/x3/erp/QAL/BPCUSTOMER&#39;, query=&#39;representation=XBPCUSTOMER.%24query&amp;count=20&#39;, fragment=None)
destination_scheme = None
conn = &lt;urllib3.connection.HTTPSConnection object at 0x7f34c0474f40&gt;
release_this_conn = False, http_tunnel_required = True, err = None
clean_exit = True

    def urlopen(
        self,
        method,
        url,
        body=None,
        headers=None,
        retries=None,
        redirect=True,
        assert_same_host=True,
        timeout=_Default,
        pool_timeout=None,
        release_conn=None,
        chunked=False,
        body_pos=None,
        **response_kw
    ):
        &#34;&#34;&#34;
        Get a connection from the pool and perform an HTTP request. This is the
        lowest level call for making a request, so you&#39;ll need to specify all
        the raw details.
    
        .. note::
    
           More commonly, it&#39;s appropriate to use a convenience method provided
           by :class:`.RequestMethods`, such as :meth:`request`.
    
        .. note::
    
           `release_conn` will only behave as expected if
           `preload_content=False` because we want to make
           `preload_content=False` the default behaviour someday soon without
           breaking backwards compatibility.
    
        :param method:
            HTTP request method (such as GET, POST, PUT, etc.)
    
        :param url:
            The URL to perform the request on.
    
        :param body:
            Data to send in the request body, either :class:`str`, :class:`bytes`,
            an iterable of :class:`str`/:class:`bytes`, or a file-like object.
    
        :param headers:
            Dictionary of custom headers to send, such as User-Agent,
            If-None-Match, etc. If None, pool headers are used. If provided,
            these headers completely replace any pool-specific headers.
    
        :param retries:
            Configure the number of retries to allow before raising a
            :class:`~urllib3.exceptions.MaxRetryError` exception.
    
            Pass ``None`` to retry until you receive a response. Pass a
            :class:`~urllib3.util.retry.Retry` object for fine-grained control
            over different types of retries.
            Pass an integer number to retry connection errors that many times,
            but no other types of errors. Pass zero to never retry.
    
            If ``False``, then retries are disabled and any exception is raised
            immediately. Also, instead of raising a MaxRetryError on redirects,
            the redirect response will be returned.
    
        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.
    
        :param redirect:
            If True, automatically handle redirects (status codes 301, 302,
            303, 307, 308). Each redirect counts as a retry. Disabling retries
            will disable redirect, too.
    
        :param assert_same_host:
            If ``True``, will make sure that the host of the pool requests is
            consistent else will raise HostChangedError. When ``False``, you can
            use the pool on an HTTP proxy and request foreign hosts.
    
        :param timeout:
            If specified, overrides the default timeout for this one
            request. It may be a float (in seconds) or an instance of
            :class:`urllib3.util.Timeout`.
    
        :param pool_timeout:
            If set and the pool is set to block=True, then this method will
            block for ``pool_timeout`` seconds and raise EmptyPoolError if no
            connection is available within the time period.
    
        :param release_conn:
            If False, then the urlopen call will not release the connection
            back into the pool once a response is received (but will release if
            you read the entire contents of the response such as when
            `preload_content=True`). This is useful if you&#39;re not preloading
            the response&#39;s content immediately. You will need to call
            ``r.release_conn()`` on the response ``r`` to return the connection
            back into the pool. If None, it takes the value of
            ``response_kw.get(&#39;preload_content&#39;, True)``.
    
        :param chunked:
            If True, urllib3 will send the body using chunked transfer
            encoding. Otherwise, urllib3 will send the body using the standard
            content-length form. Defaults to False.
    
        :param int body_pos:
            Position to seek to in file-like body in the event of a retry or
            redirect. Typically this won&#39;t need to be set because urllib3 will
            auto-populate the value when needed.
    
        :param \\**response_kw:
            Additional parameters are passed to
            :meth:`urllib3.response.HTTPResponse.from_httplib`
        &#34;&#34;&#34;
    
        parsed_url = parse_url(url)
        destination_scheme = parsed_url.scheme
    
        if headers is None:
            headers = self.headers
    
        if not isinstance(retries, Retry):
            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)
    
        if release_conn is None:
            release_conn = response_kw.get(&#34;preload_content&#34;, True)
    
        # Check host
        if assert_same_host and not self.is_same_host(url):
            raise HostChangedError(self, url, retries)
    
        # Ensure that the URL we&#39;re connecting to is properly encoded
        if url.startswith(&#34;/&#34;):
            url = six.ensure_str(_encode_target(url))
        else:
            url = six.ensure_str(parsed_url.url)
    
        conn = None
    
        # Track whether `conn` needs to be released before
        # returning/raising/recursing. Update this variable if necessary, and
        # leave `release_conn` constant throughout the function. That way, if
        # the function recurses, the original value of `release_conn` will be
        # passed down into the recursive call, and its value will be respected.
        #
        # See issue #651 [1] for details.
        #
        # [1] &lt;https://github.com/urllib3/urllib3/issues/651&gt;
        release_this_conn = release_conn
    
        http_tunnel_required = connection_requires_http_tunnel(
            self.proxy, self.proxy_config, destination_scheme
        )
    
        # Merge the proxy headers. Only done when not using HTTP CONNECT. We
        # have to copy the headers dict so we can safely change it without those
        # changes being reflected in anyone else&#39;s copy.
        if not http_tunnel_required:
            headers = headers.copy()
            headers.update(self.proxy_headers)
    
        # Must keep the exception bound to a separate variable or else Python 3
        # complains about UnboundLocalError.
        err = None
    
        # Keep track of whether we cleanly exited the except block. This
        # ensures we do proper cleanup in finally.
        clean_exit = False
    
        # Rewind body position, if needed. Record current position
        # for future rewinds in the event of a redirect/retry.
        body_pos = set_file_position(body, body_pos)
    
        try:
            # Request a connection from the queue.
            timeout_obj = self._get_timeout(timeout)
            conn = self._get_conn(timeout=pool_timeout)
    
            conn.timeout = timeout_obj.connect_timeout
    
            is_new_proxy_conn = self.proxy is not None and not getattr(
                conn, &#34;sock&#34;, None
            )
            if is_new_proxy_conn and http_tunnel_required:
                self._prepare_proxy(conn)
    
            # Make the request on the httplib connection object.
            httplib_response = self._make_request(
                conn,
                method,
                url,
                timeout=timeout_obj,
                body=body,
                headers=headers,
                chunked=chunked,
            )
    
            # If we&#39;re going to release the connection in ``finally:``, then
            # the response doesn&#39;t need to know about the connection. Otherwise
            # it will also try to release it and we&#39;ll have a double-release
            # mess.
            response_conn = conn if not release_conn else None
    
            # Pass method to Response for length checking
            response_kw[&#34;request_method&#34;] = method
    
            # Import httplib&#39;s response into our own wrapper object
            response = self.ResponseCls.from_httplib(
                httplib_response,
                pool=self,
                connection=response_conn,
                retries=retries,
                **response_kw
            )
    
            # Everything went great!
            clean_exit = True
    
        except EmptyPoolError:
            # Didn&#39;t get a connection from the pool, no need to clean up
            clean_exit = True
            release_this_conn = False
            raise
    
        except (
            TimeoutError,
            HTTPException,
            SocketError,
            ProtocolError,
            BaseSSLError,
            SSLError,
            CertificateError,
        ) as e:
            # Discard the connection for these exceptions. It will be
            # replaced during the next _get_conn() call.
            clean_exit = False
    
            def _is_ssl_error_message_from_http_proxy(ssl_error):
                # We&#39;re trying to detect the message &#39;WRONG_VERSION_NUMBER&#39; but
                # SSLErrors are kinda all over the place when it comes to the message,
                # so we try to cover our bases here!
                message = &#34; &#34;.join(re.split(&#34;[^a-z]&#34;, str(ssl_error).lower()))
                return (
                    &#34;wrong version number&#34; in message or &#34;unknown protocol&#34; in message
                )
    
            # Try to detect a common user error with proxies which is to
            # set an HTTP proxy to be HTTPS when it should be &#39;http://&#39;
            # (ie {&#39;http&#39;: &#39;http://proxy&#39;, &#39;https&#39;: &#39;https://proxy&#39;})
            # Instead we add a nice error message and point to a URL.
            if (
                isinstance(e, BaseSSLError)
                and self.proxy
                and _is_ssl_error_message_from_http_proxy(e)
                and conn.proxy
                and conn.proxy.scheme == &#34;https&#34;
            ):
                e = ProxyError(
                    &#34;Your proxy appears to only use HTTP and not HTTPS, &#34;
                    &#34;try changing your proxy URL to be HTTP. See: &#34;
                    &#34;https://urllib3.readthedocs.io/en/1.26.x/advanced-usage.html&#34;
                    &#34;#https-proxy-error-http-proxy&#34;,
                    SSLError(e),
                )
            elif isinstance(e, (BaseSSLError, CertificateError)):
                e = SSLError(e)
            elif isinstance(e, (SocketError, NewConnectionError)) and self.proxy:
                e = ProxyError(&#34;Cannot connect to proxy.&#34;, e)
            elif isinstance(e, (SocketError, HTTPException)):
                e = ProtocolError(&#34;Connection aborted.&#34;, e)
    
            retries = retries.increment(
                method, url, error=e, _pool=self, _stacktrace=sys.exc_info()[2]
            )
            retries.sleep()
    
            # Keep track of the error for the retry warning.
            err = e
    
        finally:
            if not clean_exit:
                # We hit some kind of exception, handled or otherwise. We need
                # to throw the connection away unless explicitly told not to.
                # Close the connection, set the variable to None, and make sure
                # we put the None back in the pool to avoid leaking it.
                conn = conn and conn.close()
                release_this_conn = True
    
            if release_this_conn:
                # Put the connection back to be reused. If the connection is
                # expired then it will be None, which will get replaced with a
                # fresh connection during _get_conn.
                self._put_conn(conn)
    
        if not conn:
            # Try again
            log.warning(
                &#34;Retrying (%r) after connection broken by &#39;%r&#39;: %s&#34;, retries, err, url
            )
            return self.urlopen(
                method,
                url,
                body,
                headers,
                retries,
                redirect,
                assert_same_host,
                timeout=timeout,
                pool_timeout=pool_timeout,
                release_conn=release_conn,
                chunked=chunked,
                body_pos=body_pos,
                **response_kw
            )
    
        # Handle redirect?
        redirect_location = redirect and response.get_redirect_location()
        if redirect_location:
            if response.status == 303:
                method = &#34;GET&#34;
    
            try:
                retries = retries.increment(method, url, response=response, _pool=self)
            except MaxRetryError:
                if retries.raise_on_redirect:
                    response.drain_conn()
                    raise
                return response
    
            response.drain_conn()
            retries.sleep_for_retry(response)
            log.debug(&#34;Redirecting %s -&gt; %s&#34;, url, redirect_location)
            return self.urlopen(
                method,
                redirect_location,
                body,
                headers,
                retries=retries,
                redirect=redirect,
                assert_same_host=assert_same_host,
                timeout=timeout,
                pool_timeout=pool_timeout,
                release_conn=release_conn,
                chunked=chunked,
                body_pos=body_pos,
                **response_kw
            )
    
        # Check if we should retry the HTTP response.
        has_retry_after = bool(response.getheader(&#34;Retry-After&#34;))
        if retries.is_retry(method, response.status, has_retry_after):
            try:
                retries = retries.increment(method, url, response=response, _pool=self)
            except MaxRetryError:
                if retries.raise_on_status:
                    response.drain_conn()
                    raise
                return response
    
            response.drain_conn()
            retries.sleep(response)
            log.debug(&#34;Retry: %s&#34;, url)
&gt;           return self.urlopen(
                method,
                url,
                body,
                headers,
                retries=retries,
                redirect=redirect,
                assert_same_host=assert_same_host,
                timeout=timeout,
                pool_timeout=pool_timeout,
                release_conn=release_conn,
                chunked=chunked,
                body_pos=body_pos,
                **response_kw
            )

/usr/local/lib/python3.8/site-packages/urllib3/connectionpool.py:878: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connectionpool.HTTPSConnectionPool object at 0x7f34bbe3b070&gt;
method = &#39;GET&#39;
url = &#39;/api1/x3/erp/QAL/BPCUSTOMER?representation=XBPCUSTOMER.%24query&amp;count=20&#39;
body = None
headers = {&#39;User-Agent&#39;: &#39;python-requests/2.28.1&#39;, &#39;Accept-Encoding&#39;: &#39;gzip, deflate&#39;, &#39;Accept&#39;: &#39;*/*&#39;, &#39;Connection&#39;: &#39;keep-alive&#39;, &#39;Content-Type&#39;: &#39;application/json&#39;, &#39;Authorization&#39;: &#39;Basic aW50cmFjbzpXYXNzaW1Db3ZhZ2VA&#39;}
retries = Retry(total=0, connect=None, read=None, redirect=None, status=None)
redirect = False, assert_same_host = False
timeout = Timeout(connect=None, read=None, total=None), pool_timeout = None
release_conn = False, chunked = False, body_pos = None
response_kw = {&#39;decode_content&#39;: False, &#39;preload_content&#39;: False, &#39;request_method&#39;: &#39;GET&#39;}
parsed_url = Url(scheme=None, auth=None, host=None, port=None, path=&#39;/api1/x3/erp/QAL/BPCUSTOMER&#39;, query=&#39;representation=XBPCUSTOMER.%24query&amp;count=20&#39;, fragment=None)
destination_scheme = None
conn = &lt;urllib3.connection.HTTPSConnection object at 0x7f34c0474f40&gt;
release_this_conn = False, http_tunnel_required = True, err = None
clean_exit = True

    def urlopen(
        self,
        method,
        url,
        body=None,
        headers=None,
        retries=None,
        redirect=True,
        assert_same_host=True,
        timeout=_Default,
        pool_timeout=None,
        release_conn=None,
        chunked=False,
        body_pos=None,
        **response_kw
    ):
        &#34;&#34;&#34;
        Get a connection from the pool and perform an HTTP request. This is the
        lowest level call for making a request, so you&#39;ll need to specify all
        the raw details.
    
        .. note::
    
           More commonly, it&#39;s appropriate to use a convenience method provided
           by :class:`.RequestMethods`, such as :meth:`request`.
    
        .. note::
    
           `release_conn` will only behave as expected if
           `preload_content=False` because we want to make
           `preload_content=False` the default behaviour someday soon without
           breaking backwards compatibility.
    
        :param method:
            HTTP request method (such as GET, POST, PUT, etc.)
    
        :param url:
            The URL to perform the request on.
    
        :param body:
            Data to send in the request body, either :class:`str`, :class:`bytes`,
            an iterable of :class:`str`/:class:`bytes`, or a file-like object.
    
        :param headers:
            Dictionary of custom headers to send, such as User-Agent,
            If-None-Match, etc. If None, pool headers are used. If provided,
            these headers completely replace any pool-specific headers.
    
        :param retries:
            Configure the number of retries to allow before raising a
            :class:`~urllib3.exceptions.MaxRetryError` exception.
    
            Pass ``None`` to retry until you receive a response. Pass a
            :class:`~urllib3.util.retry.Retry` object for fine-grained control
            over different types of retries.
            Pass an integer number to retry connection errors that many times,
            but no other types of errors. Pass zero to never retry.
    
            If ``False``, then retries are disabled and any exception is raised
            immediately. Also, instead of raising a MaxRetryError on redirects,
            the redirect response will be returned.
    
        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.
    
        :param redirect:
            If True, automatically handle redirects (status codes 301, 302,
            303, 307, 308). Each redirect counts as a retry. Disabling retries
            will disable redirect, too.
    
        :param assert_same_host:
            If ``True``, will make sure that the host of the pool requests is
            consistent else will raise HostChangedError. When ``False``, you can
            use the pool on an HTTP proxy and request foreign hosts.
    
        :param timeout:
            If specified, overrides the default timeout for this one
            request. It may be a float (in seconds) or an instance of
            :class:`urllib3.util.Timeout`.
    
        :param pool_timeout:
            If set and the pool is set to block=True, then this method will
            block for ``pool_timeout`` seconds and raise EmptyPoolError if no
            connection is available within the time period.
    
        :param release_conn:
            If False, then the urlopen call will not release the connection
            back into the pool once a response is received (but will release if
            you read the entire contents of the response such as when
            `preload_content=True`). This is useful if you&#39;re not preloading
            the response&#39;s content immediately. You will need to call
            ``r.release_conn()`` on the response ``r`` to return the connection
            back into the pool. If None, it takes the value of
            ``response_kw.get(&#39;preload_content&#39;, True)``.
    
        :param chunked:
            If True, urllib3 will send the body using chunked transfer
            encoding. Otherwise, urllib3 will send the body using the standard
            content-length form. Defaults to False.
    
        :param int body_pos:
            Position to seek to in file-like body in the event of a retry or
            redirect. Typically this won&#39;t need to be set because urllib3 will
            auto-populate the value when needed.
    
        :param \\**response_kw:
            Additional parameters are passed to
            :meth:`urllib3.response.HTTPResponse.from_httplib`
        &#34;&#34;&#34;
    
        parsed_url = parse_url(url)
        destination_scheme = parsed_url.scheme
    
        if headers is None:
            headers = self.headers
    
        if not isinstance(retries, Retry):
            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)
    
        if release_conn is None:
            release_conn = response_kw.get(&#34;preload_content&#34;, True)
    
        # Check host
        if assert_same_host and not self.is_same_host(url):
            raise HostChangedError(self, url, retries)
    
        # Ensure that the URL we&#39;re connecting to is properly encoded
        if url.startswith(&#34;/&#34;):
            url = six.ensure_str(_encode_target(url))
        else:
            url = six.ensure_str(parsed_url.url)
    
        conn = None
    
        # Track whether `conn` needs to be released before
        # returning/raising/recursing. Update this variable if necessary, and
        # leave `release_conn` constant throughout the function. That way, if
        # the function recurses, the original value of `release_conn` will be
        # passed down into the recursive call, and its value will be respected.
        #
        # See issue #651 [1] for details.
        #
        # [1] &lt;https://github.com/urllib3/urllib3/issues/651&gt;
        release_this_conn = release_conn
    
        http_tunnel_required = connection_requires_http_tunnel(
            self.proxy, self.proxy_config, destination_scheme
        )
    
        # Merge the proxy headers. Only done when not using HTTP CONNECT. We
        # have to copy the headers dict so we can safely change it without those
        # changes being reflected in anyone else&#39;s copy.
        if not http_tunnel_required:
            headers = headers.copy()
            headers.update(self.proxy_headers)
    
        # Must keep the exception bound to a separate variable or else Python 3
        # complains about UnboundLocalError.
        err = None
    
        # Keep track of whether we cleanly exited the except block. This
        # ensures we do proper cleanup in finally.
        clean_exit = False
    
        # Rewind body position, if needed. Record current position
        # for future rewinds in the event of a redirect/retry.
        body_pos = set_file_position(body, body_pos)
    
        try:
            # Request a connection from the queue.
            timeout_obj = self._get_timeout(timeout)
            conn = self._get_conn(timeout=pool_timeout)
    
            conn.timeout = timeout_obj.connect_timeout
    
            is_new_proxy_conn = self.proxy is not None and not getattr(
                conn, &#34;sock&#34;, None
            )
            if is_new_proxy_conn and http_tunnel_required:
                self._prepare_proxy(conn)
    
            # Make the request on the httplib connection object.
            httplib_response = self._make_request(
                conn,
                method,
                url,
                timeout=timeout_obj,
                body=body,
                headers=headers,
                chunked=chunked,
            )
    
            # If we&#39;re going to release the connection in ``finally:``, then
            # the response doesn&#39;t need to know about the connection. Otherwise
            # it will also try to release it and we&#39;ll have a double-release
            # mess.
            response_conn = conn if not release_conn else None
    
            # Pass method to Response for length checking
            response_kw[&#34;request_method&#34;] = method
    
            # Import httplib&#39;s response into our own wrapper object
            response = self.ResponseCls.from_httplib(
                httplib_response,
                pool=self,
                connection=response_conn,
                retries=retries,
                **response_kw
            )
    
            # Everything went great!
            clean_exit = True
    
        except EmptyPoolError:
            # Didn&#39;t get a connection from the pool, no need to clean up
            clean_exit = True
            release_this_conn = False
            raise
    
        except (
            TimeoutError,
            HTTPException,
            SocketError,
            ProtocolError,
            BaseSSLError,
            SSLError,
            CertificateError,
        ) as e:
            # Discard the connection for these exceptions. It will be
            # replaced during the next _get_conn() call.
            clean_exit = False
    
            def _is_ssl_error_message_from_http_proxy(ssl_error):
                # We&#39;re trying to detect the message &#39;WRONG_VERSION_NUMBER&#39; but
                # SSLErrors are kinda all over the place when it comes to the message,
                # so we try to cover our bases here!
                message = &#34; &#34;.join(re.split(&#34;[^a-z]&#34;, str(ssl_error).lower()))
                return (
                    &#34;wrong version number&#34; in message or &#34;unknown protocol&#34; in message
                )
    
            # Try to detect a common user error with proxies which is to
            # set an HTTP proxy to be HTTPS when it should be &#39;http://&#39;
            # (ie {&#39;http&#39;: &#39;http://proxy&#39;, &#39;https&#39;: &#39;https://proxy&#39;})
            # Instead we add a nice error message and point to a URL.
            if (
                isinstance(e, BaseSSLError)
                and self.proxy
                and _is_ssl_error_message_from_http_proxy(e)
                and conn.proxy
                and conn.proxy.scheme == &#34;https&#34;
            ):
                e = ProxyError(
                    &#34;Your proxy appears to only use HTTP and not HTTPS, &#34;
                    &#34;try changing your proxy URL to be HTTP. See: &#34;
                    &#34;https://urllib3.readthedocs.io/en/1.26.x/advanced-usage.html&#34;
                    &#34;#https-proxy-error-http-proxy&#34;,
                    SSLError(e),
                )
            elif isinstance(e, (BaseSSLError, CertificateError)):
                e = SSLError(e)
            elif isinstance(e, (SocketError, NewConnectionError)) and self.proxy:
                e = ProxyError(&#34;Cannot connect to proxy.&#34;, e)
            elif isinstance(e, (SocketError, HTTPException)):
                e = ProtocolError(&#34;Connection aborted.&#34;, e)
    
            retries = retries.increment(
                method, url, error=e, _pool=self, _stacktrace=sys.exc_info()[2]
            )
            retries.sleep()
    
            # Keep track of the error for the retry warning.
            err = e
    
        finally:
            if not clean_exit:
                # We hit some kind of exception, handled or otherwise. We need
                # to throw the connection away unless explicitly told not to.
                # Close the connection, set the variable to None, and make sure
                # we put the None back in the pool to avoid leaking it.
                conn = conn and conn.close()
                release_this_conn = True
    
            if release_this_conn:
                # Put the connection back to be reused. If the connection is
                # expired then it will be None, which will get replaced with a
                # fresh connection during _get_conn.
                self._put_conn(conn)
    
        if not conn:
            # Try again
            log.warning(
                &#34;Retrying (%r) after connection broken by &#39;%r&#39;: %s&#34;, retries, err, url
            )
            return self.urlopen(
                method,
                url,
                body,
                headers,
                retries,
                redirect,
                assert_same_host,
                timeout=timeout,
                pool_timeout=pool_timeout,
                release_conn=release_conn,
                chunked=chunked,
                body_pos=body_pos,
                **response_kw
            )
    
        # Handle redirect?
        redirect_location = redirect and response.get_redirect_location()
        if redirect_location:
            if response.status == 303:
                method = &#34;GET&#34;
    
            try:
                retries = retries.increment(method, url, response=response, _pool=self)
            except MaxRetryError:
                if retries.raise_on_redirect:
                    response.drain_conn()
                    raise
                return response
    
            response.drain_conn()
            retries.sleep_for_retry(response)
            log.debug(&#34;Redirecting %s -&gt; %s&#34;, url, redirect_location)
            return self.urlopen(
                method,
                redirect_location,
                body,
                headers,
                retries=retries,
                redirect=redirect,
                assert_same_host=assert_same_host,
                timeout=timeout,
                pool_timeout=pool_timeout,
                release_conn=release_conn,
                chunked=chunked,
                body_pos=body_pos,
                **response_kw
            )
    
        # Check if we should retry the HTTP response.
        has_retry_after = bool(response.getheader(&#34;Retry-After&#34;))
        if retries.is_retry(method, response.status, has_retry_after):
            try:
&gt;               retries = retries.increment(method, url, response=response, _pool=self)

/usr/local/lib/python3.8/site-packages/urllib3/connectionpool.py:868: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Retry(total=0, connect=None, read=None, redirect=None, status=None)
method = &#39;GET&#39;
url = &#39;/api1/x3/erp/QAL/BPCUSTOMER?representation=XBPCUSTOMER.%24query&amp;count=20&#39;
response = &lt;urllib3.response.HTTPResponse object at 0x7f34bbdba100&gt;
error = None
_pool = &lt;urllib3.connectionpool.HTTPSConnectionPool object at 0x7f34bbe3b070&gt;
_stacktrace = None

    def increment(
        self,
        method=None,
        url=None,
        response=None,
        error=None,
        _pool=None,
        _stacktrace=None,
    ):
        &#34;&#34;&#34;Return a new Retry object with incremented retry counters.
    
        :param response: A response object, or None, if the server did not
            return a response.
        :type response: :class:`~urllib3.response.HTTPResponse`
        :param Exception error: An error encountered during the request, or
            None if the response was received successfully.
    
        :return: A new ``Retry`` object.
        &#34;&#34;&#34;
        if self.total is False and error:
            # Disabled, indicate to re-raise the error.
            raise six.reraise(type(error), error, _stacktrace)
    
        total = self.total
        if total is not None:
            total -= 1
    
        connect = self.connect
        read = self.read
        redirect = self.redirect
        status_count = self.status
        other = self.other
        cause = &#34;unknown&#34;
        status = None
        redirect_location = None
    
        if error and self._is_connection_error(error):
            # Connect retry?
            if connect is False:
                raise six.reraise(type(error), error, _stacktrace)
            elif connect is not None:
                connect -= 1
    
        elif error and self._is_read_error(error):
            # Read retry?
            if read is False or not self._is_method_retryable(method):
                raise six.reraise(type(error), error, _stacktrace)
            elif read is not None:
                read -= 1
    
        elif error:
            # Other retry?
            if other is not None:
                other -= 1
    
        elif response and response.get_redirect_location():
            # Redirect retry?
            if redirect is not None:
                redirect -= 1
            cause = &#34;too many redirects&#34;
            redirect_location = response.get_redirect_location()
            status = response.status
    
        else:
            # Incrementing because of a server error like a 500 in
            # status_forcelist and the given method is in the allowed_methods
            cause = ResponseError.GENERIC_ERROR
            if response and response.status:
                if status_count is not None:
                    status_count -= 1
                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)
                status = response.status
    
        history = self.history + (
            RequestHistory(method, url, error, status, redirect_location),
        )
    
        new_retry = self.new(
            total=total,
            connect=connect,
            read=read,
            redirect=redirect,
            status=status_count,
            other=other,
            history=history,
        )
    
        if new_retry.is_exhausted():
&gt;           raise MaxRetryError(_pool, url, error or ResponseError(cause))
E           urllib3.exceptions.MaxRetryError: HTTPSConnectionPool(host=&#39;sagex3-horsprod.covage.com&#39;, port=443): Max retries exceeded with url: /api1/x3/erp/QAL/BPCUSTOMER?representation=XBPCUSTOMER.%24query&amp;count=20 (Caused by ResponseError(&#39;too many 502 error responses&#39;))

/usr/local/lib/python3.8/site-packages/urllib3/util/retry.py:592: MaxRetryError

During handling of the above exception, another exception occurred:

x3_client = &lt;x3_wrapper.rest_client.X3RestClient object at 0x7f34bbe3b4f0&gt;

    @pytest.mark.livetest
    @pytest.mark.xfail
    @pytest.mark.read_data
    def test_x3_schema_query_customer(x3_client):
        &#34;&#34;&#34;Validate customer schema representation `XBPCUSTOMER` query&#34;&#34;&#34;
&gt;       resp = x3_client.list(
            class_name=&#34;BPCUSTOMER&#34;,
            representation=&#34;XBPCUSTOMER&#34;,
            count=20,
        )

app/api/live_tests/test_customer/test_query_customer.py:12: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
app/x3_wrapper/rest_client.py:84: in list
    resp = self._cal_x3(&#34;GET&#34;, url, query_params)
app/x3_wrapper/rest_client.py:70: in _cal_x3
    resp = self.client.request(method, url, params=query_params)
/usr/local/lib/python3.8/site-packages/requests/sessions.py:587: in request
    resp = self.send(prep, **send_kwargs)
/usr/local/lib/python3.8/site-packages/requests/sessions.py:701: in send
    r = adapter.send(request, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;requests.adapters.HTTPAdapter object at 0x7f34bbe3b160&gt;
request = &lt;PreparedRequest [GET]&gt;, stream = False
timeout = Timeout(connect=None, read=None, total=None), verify = True
cert = None
proxies = OrderedDict([(&#39;no&#39;, &#39;gitlab-runner-cache-01-prd.nut.covage.com&#39;), (&#39;http&#39;, &#39;http://squid.kosc.net:3128&#39;), (&#39;https&#39;, &#39;http://squid.kosc.net:3128&#39;)])

    def send(
        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None
    ):
        &#34;&#34;&#34;Sends PreparedRequest object. Returns Response object.
    
        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.
        :param stream: (optional) Whether to stream the request content.
        :param timeout: (optional) How long to wait for the server to send
            data before giving up, as a float, or a :ref:`(connect timeout,
            read timeout) &lt;timeouts&gt;` tuple.
        :type timeout: float or tuple or urllib3 Timeout object
        :param verify: (optional) Either a boolean, in which case it controls whether
            we verify the server&#39;s TLS certificate, or a string, in which case it
            must be a path to a CA bundle to use
        :param cert: (optional) Any user-provided SSL certificate to be trusted.
        :param proxies: (optional) The proxies dictionary to apply to the request.
        :rtype: requests.Response
        &#34;&#34;&#34;
    
        try:
            conn = self.get_connection(request.url, proxies)
        except LocationValueError as e:
            raise InvalidURL(e, request=request)
    
        self.cert_verify(conn, request.url, verify, cert)
        url = self.request_url(request, proxies)
        self.add_headers(
            request,
            stream=stream,
            timeout=timeout,
            verify=verify,
            cert=cert,
            proxies=proxies,
        )
    
        chunked = not (request.body is None or &#34;Content-Length&#34; in request.headers)
    
        if isinstance(timeout, tuple):
            try:
                connect, read = timeout
                timeout = TimeoutSauce(connect=connect, read=read)
            except ValueError:
                raise ValueError(
                    f&#34;Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, &#34;
                    f&#34;or a single float to set both timeouts to the same value.&#34;
                )
        elif isinstance(timeout, TimeoutSauce):
            pass
        else:
            timeout = TimeoutSauce(connect=timeout, read=timeout)
    
        try:
            if not chunked:
                resp = conn.urlopen(
                    method=request.method,
                    url=url,
                    body=request.body,
                    headers=request.headers,
                    redirect=False,
                    assert_same_host=False,
                    preload_content=False,
                    decode_content=False,
                    retries=self.max_retries,
                    timeout=timeout,
                )
    
            # Send the request.
            else:
                if hasattr(conn, &#34;proxy_pool&#34;):
                    conn = conn.proxy_pool
    
                low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)
    
                try:
                    skip_host = &#34;Host&#34; in request.headers
                    low_conn.putrequest(
                        request.method,
                        url,
                        skip_accept_encoding=True,
                        skip_host=skip_host,
                    )
    
                    for header, value in request.headers.items():
                        low_conn.putheader(header, value)
    
                    low_conn.endheaders()
    
                    for i in request.body:
                        low_conn.send(hex(len(i))[2:].encode(&#34;utf-8&#34;))
                        low_conn.send(b&#34;\r\n&#34;)
                        low_conn.send(i)
                        low_conn.send(b&#34;\r\n&#34;)
                    low_conn.send(b&#34;0\r\n\r\n&#34;)
    
                    # Receive the response from the server
                    r = low_conn.getresponse()
    
                    resp = HTTPResponse.from_httplib(
                        r,
                        pool=conn,
                        connection=low_conn,
                        preload_content=False,
                        decode_content=False,
                    )
                except Exception:
                    # If we hit any problems here, clean up the connection.
                    # Then, raise so that we can handle the actual exception.
                    low_conn.close()
                    raise
    
        except (ProtocolError, OSError) as err:
            raise ConnectionError(err, request=request)
    
        except MaxRetryError as e:
            if isinstance(e.reason, ConnectTimeoutError):
                # TODO: Remove this in 3.0.0: see #2811
                if not isinstance(e.reason, NewConnectionError):
                    raise ConnectTimeout(e, request=request)
    
            if isinstance(e.reason, ResponseError):
&gt;               raise RetryError(e, request=request)
E               requests.exceptions.RetryError: HTTPSConnectionPool(host=&#39;sagex3-horsprod.covage.com&#39;, port=443): Max retries exceeded with url: /api1/x3/erp/QAL/BPCUSTOMER?representation=XBPCUSTOMER.%24query&amp;count=20 (Caused by ResponseError(&#39;too many 502 error responses&#39;))

/usr/local/lib/python3.8/site-packages/requests/adapters.py:556: RetryError</pre> </div> </div> </details> <details class="phase teardown "> <summary> <h4 class=title> <span class=phase-name>Teardown</span> </h4> </summary> <div class=content> </div> </details> </div> </div> </details> <details class="test xfailed"> <summary> <h3 class="title test-title"> <span class="status badge xfailed ">XFAIL</span> <span class=test-name> <span class=funcname>test_api_schema_list_customers</span> </span> <span class=duration>0:00:00.725702</span> </h3> </summary> <div class=content> <div class=documentation> <p>Validate api response schema for route <cite>/customers/</cite></p> </div> <table class=metadata> <tr> <th>Started</th> <td>2023-06-30 01:14:55</td> </tr> <tr> <th>Ended</th> <td>2023-06-30 01:14:55</td> </tr> <tr> <th>Duration</th> <td>0:00:00.725702</td> </tr> <tr> <th>Markers</th> <td> <div class=marker> <span class="marker-name badge">read_data</span> <span class=marker-args> </span> </div> <div class=marker> <span class="marker-name badge">xfail</span> <span class=marker-args> </span> </div> <div class=marker> <span class="marker-name badge">livetest</span> <span class=marker-args> </span> </div> </td> </tr> <tr> <th>Fixtures</th> <td> <span class="badge fixturename"> django_test_environment </span> <span class="badge fixturename"> django_db_blocker </span> <span class="badge fixturename"> test_client </span> <span class="badge fixturename"> request </span> </td> </tr> </table> <div class=repr> <pre>AssertionError: b&#39;{&#34;detail&#34;:&#34;Server Error (500)&#34;,&#34;status_code&#34;:500}&#39;
assert 500 == 200
 +  where 500 = &lt;Response [500]&gt;.status_code</pre> </div> <div class=test-phases> <details class="phase setup "> <summary> <h4 class=title> <span class=phase-name>Setup</span> </h4> </summary> <div class=content> </div> </details> <details class="phase call xfailed" open> <summary> <h4 class=title> <span class="status  xfailed"></span> <span class=phase-name>Call</span> </h4> </summary> <div class=content> <div class=repr> <pre>test_client = &lt;conftest.LiveServerSession object at 0x7f34bb8948b0&gt;

    @pytest.mark.livetest
    @pytest.mark.xfail
    @pytest.mark.read_data
    def test_api_schema_list_customers(test_client):
        &#34;&#34;&#34;Validate api response schema for route `/customers/`&#34;&#34;&#34;
        resp = test_client.get(&#34;/api/v0/customers/&#34;, params={&#34;order_by&#34;: &#34;UPDDATTIM desc&#34;})
&gt;       assert resp.status_code == 200, resp.content
E       AssertionError: b&#39;{&#34;detail&#34;:&#34;Server Error (500)&#34;,&#34;status_code&#34;:500}&#39;
E       assert 500 == 200
E        +  where 500 = &lt;Response [500]&gt;.status_code

app/api/live_tests/test_customer/test_query_customer.py:26: AssertionError</pre> </div> </div> </details> <details class="phase teardown "> <summary> <h4 class=title> <span class=phase-name>Teardown</span> </h4> </summary> <div class=content> </div> </details> </div> </div> </details> </div> </details> <details class=file> <summary> <h2 class="title file-title"> <span class=fspath> app/api/live_tests/test_facility/test_query_facility.py </span> <span class=counts> <span title="2 xfailed" class="count status badge xfailed ">2</span> </span> <span class=duration> 0:00:01.394328 </span> </h2> </summary> <div class="content box"> <details class="test xfailed"> <summary> <h3 class="title test-title"> <span class="status badge xfailed ">XFAIL</span> <span class=test-name> <span class=funcname>test_x3_schema_query_facility</span> </span> <span class=duration>0:00:00.670533</span> </h3> </summary> <div class=content> <div class=documentation> <p>Validate X3 facility schema representation <cite>XFACILITY</cite> query</p> </div> <table class=metadata> <tr> <th>Started</th> <td>2023-06-30 01:14:55</td> </tr> <tr> <th>Ended</th> <td>2023-06-30 01:14:56</td> </tr> <tr> <th>Duration</th> <td>0:00:00.670533</td> </tr> <tr> <th>Markers</th> <td> <div class=marker> <span class="marker-name badge">read_data</span> <span class=marker-args> </span> </div> <div class=marker> <span class="marker-name badge">xfail</span> <span class=marker-args> </span> </div> <div class=marker> <span class="marker-name badge">livetest</span> <span class=marker-args> </span> </div> </td> </tr> <tr> <th>Fixtures</th> <td> <span class="badge fixturename"> django_test_environment </span> <span class="badge fixturename"> django_db_blocker </span> <span class="badge fixturename"> x3_client </span> <span class="badge fixturename"> request </span> </td> </tr> </table> <div class=repr> <pre>requests.exceptions.RetryError: HTTPSConnectionPool(host=&#39;sagex3-horsprod.covage.com&#39;, port=443): Max retries exceeded with url: /api1/x3/erp/QAL/XFACILITY?representation=XFACILITY.%24query&amp;count=50&amp;orderBy=UPDDATTIM%20desc (Caused by ResponseError(&#39;too many 502 error responses&#39;))</pre> </div> <div class=test-phases> <details class="phase setup "> <summary> <h4 class=title> <span class=phase-name>Setup</span> </h4> </summary> <div class=content> </div> </details> <details class="phase call xfailed" open> <summary> <h4 class=title> <span class="status  xfailed"></span> <span class=phase-name>Call</span> </h4> </summary> <div class=content> <div class=repr> <pre>self = &lt;requests.adapters.HTTPAdapter object at 0x7f34c006a3a0&gt;
request = &lt;PreparedRequest [GET]&gt;, stream = False
timeout = Timeout(connect=None, read=None, total=None), verify = True
cert = None
proxies = OrderedDict([(&#39;no&#39;, &#39;gitlab-runner-cache-01-prd.nut.covage.com&#39;), (&#39;http&#39;, &#39;http://squid.kosc.net:3128&#39;), (&#39;https&#39;, &#39;http://squid.kosc.net:3128&#39;)])

    def send(
        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None
    ):
        &#34;&#34;&#34;Sends PreparedRequest object. Returns Response object.
    
        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.
        :param stream: (optional) Whether to stream the request content.
        :param timeout: (optional) How long to wait for the server to send
            data before giving up, as a float, or a :ref:`(connect timeout,
            read timeout) &lt;timeouts&gt;` tuple.
        :type timeout: float or tuple or urllib3 Timeout object
        :param verify: (optional) Either a boolean, in which case it controls whether
            we verify the server&#39;s TLS certificate, or a string, in which case it
            must be a path to a CA bundle to use
        :param cert: (optional) Any user-provided SSL certificate to be trusted.
        :param proxies: (optional) The proxies dictionary to apply to the request.
        :rtype: requests.Response
        &#34;&#34;&#34;
    
        try:
            conn = self.get_connection(request.url, proxies)
        except LocationValueError as e:
            raise InvalidURL(e, request=request)
    
        self.cert_verify(conn, request.url, verify, cert)
        url = self.request_url(request, proxies)
        self.add_headers(
            request,
            stream=stream,
            timeout=timeout,
            verify=verify,
            cert=cert,
            proxies=proxies,
        )
    
        chunked = not (request.body is None or &#34;Content-Length&#34; in request.headers)
    
        if isinstance(timeout, tuple):
            try:
                connect, read = timeout
                timeout = TimeoutSauce(connect=connect, read=read)
            except ValueError:
                raise ValueError(
                    f&#34;Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, &#34;
                    f&#34;or a single float to set both timeouts to the same value.&#34;
                )
        elif isinstance(timeout, TimeoutSauce):
            pass
        else:
            timeout = TimeoutSauce(connect=timeout, read=timeout)
    
        try:
            if not chunked:
&gt;               resp = conn.urlopen(
                    method=request.method,
                    url=url,
                    body=request.body,
                    headers=request.headers,
                    redirect=False,
                    assert_same_host=False,
                    preload_content=False,
                    decode_content=False,
                    retries=self.max_retries,
                    timeout=timeout,
                )

/usr/local/lib/python3.8/site-packages/requests/adapters.py:489: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connectionpool.HTTPSConnectionPool object at 0x7f34c006af40&gt;
method = &#39;GET&#39;
url = &#39;/api1/x3/erp/QAL/XFACILITY?representation=XFACILITY.%24query&amp;count=50&amp;orderBy=UPDDATTIM%20desc&#39;
body = None
headers = {&#39;User-Agent&#39;: &#39;python-requests/2.28.1&#39;, &#39;Accept-Encoding&#39;: &#39;gzip, deflate&#39;, &#39;Accept&#39;: &#39;*/*&#39;, &#39;Connection&#39;: &#39;keep-alive&#39;, &#39;Content-Type&#39;: &#39;application/json&#39;, &#39;Authorization&#39;: &#39;Basic aW50cmFjbzpXYXNzaW1Db3ZhZ2VA&#39;}
retries = Retry(total=2, connect=None, read=None, redirect=None, status=None)
redirect = False, assert_same_host = False
timeout = Timeout(connect=None, read=None, total=None), pool_timeout = None
release_conn = False, chunked = False, body_pos = None
response_kw = {&#39;decode_content&#39;: False, &#39;preload_content&#39;: False, &#39;request_method&#39;: &#39;GET&#39;}
parsed_url = Url(scheme=None, auth=None, host=None, port=None, path=&#39;/api1/x3/erp/QAL/XFACILITY&#39;, query=&#39;representation=XFACILITY.%24query&amp;count=50&amp;orderBy=UPDDATTIM%20desc&#39;, fragment=None)
destination_scheme = None
conn = &lt;urllib3.connection.HTTPSConnection object at 0x7f34bbd0eeb0&gt;
release_this_conn = False, http_tunnel_required = True, err = None
clean_exit = True

    def urlopen(
        self,
        method,
        url,
        body=None,
        headers=None,
        retries=None,
        redirect=True,
        assert_same_host=True,
        timeout=_Default,
        pool_timeout=None,
        release_conn=None,
        chunked=False,
        body_pos=None,
        **response_kw
    ):
        &#34;&#34;&#34;
        Get a connection from the pool and perform an HTTP request. This is the
        lowest level call for making a request, so you&#39;ll need to specify all
        the raw details.
    
        .. note::
    
           More commonly, it&#39;s appropriate to use a convenience method provided
           by :class:`.RequestMethods`, such as :meth:`request`.
    
        .. note::
    
           `release_conn` will only behave as expected if
           `preload_content=False` because we want to make
           `preload_content=False` the default behaviour someday soon without
           breaking backwards compatibility.
    
        :param method:
            HTTP request method (such as GET, POST, PUT, etc.)
    
        :param url:
            The URL to perform the request on.
    
        :param body:
            Data to send in the request body, either :class:`str`, :class:`bytes`,
            an iterable of :class:`str`/:class:`bytes`, or a file-like object.
    
        :param headers:
            Dictionary of custom headers to send, such as User-Agent,
            If-None-Match, etc. If None, pool headers are used. If provided,
            these headers completely replace any pool-specific headers.
    
        :param retries:
            Configure the number of retries to allow before raising a
            :class:`~urllib3.exceptions.MaxRetryError` exception.
    
            Pass ``None`` to retry until you receive a response. Pass a
            :class:`~urllib3.util.retry.Retry` object for fine-grained control
            over different types of retries.
            Pass an integer number to retry connection errors that many times,
            but no other types of errors. Pass zero to never retry.
    
            If ``False``, then retries are disabled and any exception is raised
            immediately. Also, instead of raising a MaxRetryError on redirects,
            the redirect response will be returned.
    
        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.
    
        :param redirect:
            If True, automatically handle redirects (status codes 301, 302,
            303, 307, 308). Each redirect counts as a retry. Disabling retries
            will disable redirect, too.
    
        :param assert_same_host:
            If ``True``, will make sure that the host of the pool requests is
            consistent else will raise HostChangedError. When ``False``, you can
            use the pool on an HTTP proxy and request foreign hosts.
    
        :param timeout:
            If specified, overrides the default timeout for this one
            request. It may be a float (in seconds) or an instance of
            :class:`urllib3.util.Timeout`.
    
        :param pool_timeout:
            If set and the pool is set to block=True, then this method will
            block for ``pool_timeout`` seconds and raise EmptyPoolError if no
            connection is available within the time period.
    
        :param release_conn:
            If False, then the urlopen call will not release the connection
            back into the pool once a response is received (but will release if
            you read the entire contents of the response such as when
            `preload_content=True`). This is useful if you&#39;re not preloading
            the response&#39;s content immediately. You will need to call
            ``r.release_conn()`` on the response ``r`` to return the connection
            back into the pool. If None, it takes the value of
            ``response_kw.get(&#39;preload_content&#39;, True)``.
    
        :param chunked:
            If True, urllib3 will send the body using chunked transfer
            encoding. Otherwise, urllib3 will send the body using the standard
            content-length form. Defaults to False.
    
        :param int body_pos:
            Position to seek to in file-like body in the event of a retry or
            redirect. Typically this won&#39;t need to be set because urllib3 will
            auto-populate the value when needed.
    
        :param \\**response_kw:
            Additional parameters are passed to
            :meth:`urllib3.response.HTTPResponse.from_httplib`
        &#34;&#34;&#34;
    
        parsed_url = parse_url(url)
        destination_scheme = parsed_url.scheme
    
        if headers is None:
            headers = self.headers
    
        if not isinstance(retries, Retry):
            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)
    
        if release_conn is None:
            release_conn = response_kw.get(&#34;preload_content&#34;, True)
    
        # Check host
        if assert_same_host and not self.is_same_host(url):
            raise HostChangedError(self, url, retries)
    
        # Ensure that the URL we&#39;re connecting to is properly encoded
        if url.startswith(&#34;/&#34;):
            url = six.ensure_str(_encode_target(url))
        else:
            url = six.ensure_str(parsed_url.url)
    
        conn = None
    
        # Track whether `conn` needs to be released before
        # returning/raising/recursing. Update this variable if necessary, and
        # leave `release_conn` constant throughout the function. That way, if
        # the function recurses, the original value of `release_conn` will be
        # passed down into the recursive call, and its value will be respected.
        #
        # See issue #651 [1] for details.
        #
        # [1] &lt;https://github.com/urllib3/urllib3/issues/651&gt;
        release_this_conn = release_conn
    
        http_tunnel_required = connection_requires_http_tunnel(
            self.proxy, self.proxy_config, destination_scheme
        )
    
        # Merge the proxy headers. Only done when not using HTTP CONNECT. We
        # have to copy the headers dict so we can safely change it without those
        # changes being reflected in anyone else&#39;s copy.
        if not http_tunnel_required:
            headers = headers.copy()
            headers.update(self.proxy_headers)
    
        # Must keep the exception bound to a separate variable or else Python 3
        # complains about UnboundLocalError.
        err = None
    
        # Keep track of whether we cleanly exited the except block. This
        # ensures we do proper cleanup in finally.
        clean_exit = False
    
        # Rewind body position, if needed. Record current position
        # for future rewinds in the event of a redirect/retry.
        body_pos = set_file_position(body, body_pos)
    
        try:
            # Request a connection from the queue.
            timeout_obj = self._get_timeout(timeout)
            conn = self._get_conn(timeout=pool_timeout)
    
            conn.timeout = timeout_obj.connect_timeout
    
            is_new_proxy_conn = self.proxy is not None and not getattr(
                conn, &#34;sock&#34;, None
            )
            if is_new_proxy_conn and http_tunnel_required:
                self._prepare_proxy(conn)
    
            # Make the request on the httplib connection object.
            httplib_response = self._make_request(
                conn,
                method,
                url,
                timeout=timeout_obj,
                body=body,
                headers=headers,
                chunked=chunked,
            )
    
            # If we&#39;re going to release the connection in ``finally:``, then
            # the response doesn&#39;t need to know about the connection. Otherwise
            # it will also try to release it and we&#39;ll have a double-release
            # mess.
            response_conn = conn if not release_conn else None
    
            # Pass method to Response for length checking
            response_kw[&#34;request_method&#34;] = method
    
            # Import httplib&#39;s response into our own wrapper object
            response = self.ResponseCls.from_httplib(
                httplib_response,
                pool=self,
                connection=response_conn,
                retries=retries,
                **response_kw
            )
    
            # Everything went great!
            clean_exit = True
    
        except EmptyPoolError:
            # Didn&#39;t get a connection from the pool, no need to clean up
            clean_exit = True
            release_this_conn = False
            raise
    
        except (
            TimeoutError,
            HTTPException,
            SocketError,
            ProtocolError,
            BaseSSLError,
            SSLError,
            CertificateError,
        ) as e:
            # Discard the connection for these exceptions. It will be
            # replaced during the next _get_conn() call.
            clean_exit = False
    
            def _is_ssl_error_message_from_http_proxy(ssl_error):
                # We&#39;re trying to detect the message &#39;WRONG_VERSION_NUMBER&#39; but
                # SSLErrors are kinda all over the place when it comes to the message,
                # so we try to cover our bases here!
                message = &#34; &#34;.join(re.split(&#34;[^a-z]&#34;, str(ssl_error).lower()))
                return (
                    &#34;wrong version number&#34; in message or &#34;unknown protocol&#34; in message
                )
    
            # Try to detect a common user error with proxies which is to
            # set an HTTP proxy to be HTTPS when it should be &#39;http://&#39;
            # (ie {&#39;http&#39;: &#39;http://proxy&#39;, &#39;https&#39;: &#39;https://proxy&#39;})
            # Instead we add a nice error message and point to a URL.
            if (
                isinstance(e, BaseSSLError)
                and self.proxy
                and _is_ssl_error_message_from_http_proxy(e)
                and conn.proxy
                and conn.proxy.scheme == &#34;https&#34;
            ):
                e = ProxyError(
                    &#34;Your proxy appears to only use HTTP and not HTTPS, &#34;
                    &#34;try changing your proxy URL to be HTTP. See: &#34;
                    &#34;https://urllib3.readthedocs.io/en/1.26.x/advanced-usage.html&#34;
                    &#34;#https-proxy-error-http-proxy&#34;,
                    SSLError(e),
                )
            elif isinstance(e, (BaseSSLError, CertificateError)):
                e = SSLError(e)
            elif isinstance(e, (SocketError, NewConnectionError)) and self.proxy:
                e = ProxyError(&#34;Cannot connect to proxy.&#34;, e)
            elif isinstance(e, (SocketError, HTTPException)):
                e = ProtocolError(&#34;Connection aborted.&#34;, e)
    
            retries = retries.increment(
                method, url, error=e, _pool=self, _stacktrace=sys.exc_info()[2]
            )
            retries.sleep()
    
            # Keep track of the error for the retry warning.
            err = e
    
        finally:
            if not clean_exit:
                # We hit some kind of exception, handled or otherwise. We need
                # to throw the connection away unless explicitly told not to.
                # Close the connection, set the variable to None, and make sure
                # we put the None back in the pool to avoid leaking it.
                conn = conn and conn.close()
                release_this_conn = True
    
            if release_this_conn:
                # Put the connection back to be reused. If the connection is
                # expired then it will be None, which will get replaced with a
                # fresh connection during _get_conn.
                self._put_conn(conn)
    
        if not conn:
            # Try again
            log.warning(
                &#34;Retrying (%r) after connection broken by &#39;%r&#39;: %s&#34;, retries, err, url
            )
            return self.urlopen(
                method,
                url,
                body,
                headers,
                retries,
                redirect,
                assert_same_host,
                timeout=timeout,
                pool_timeout=pool_timeout,
                release_conn=release_conn,
                chunked=chunked,
                body_pos=body_pos,
                **response_kw
            )
    
        # Handle redirect?
        redirect_location = redirect and response.get_redirect_location()
        if redirect_location:
            if response.status == 303:
                method = &#34;GET&#34;
    
            try:
                retries = retries.increment(method, url, response=response, _pool=self)
            except MaxRetryError:
                if retries.raise_on_redirect:
                    response.drain_conn()
                    raise
                return response
    
            response.drain_conn()
            retries.sleep_for_retry(response)
            log.debug(&#34;Redirecting %s -&gt; %s&#34;, url, redirect_location)
            return self.urlopen(
                method,
                redirect_location,
                body,
                headers,
                retries=retries,
                redirect=redirect,
                assert_same_host=assert_same_host,
                timeout=timeout,
                pool_timeout=pool_timeout,
                release_conn=release_conn,
                chunked=chunked,
                body_pos=body_pos,
                **response_kw
            )
    
        # Check if we should retry the HTTP response.
        has_retry_after = bool(response.getheader(&#34;Retry-After&#34;))
        if retries.is_retry(method, response.status, has_retry_after):
            try:
                retries = retries.increment(method, url, response=response, _pool=self)
            except MaxRetryError:
                if retries.raise_on_status:
                    response.drain_conn()
                    raise
                return response
    
            response.drain_conn()
            retries.sleep(response)
            log.debug(&#34;Retry: %s&#34;, url)
&gt;           return self.urlopen(
                method,
                url,
                body,
                headers,
                retries=retries,
                redirect=redirect,
                assert_same_host=assert_same_host,
                timeout=timeout,
                pool_timeout=pool_timeout,
                release_conn=release_conn,
                chunked=chunked,
                body_pos=body_pos,
                **response_kw
            )

/usr/local/lib/python3.8/site-packages/urllib3/connectionpool.py:878: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connectionpool.HTTPSConnectionPool object at 0x7f34c006af40&gt;
method = &#39;GET&#39;
url = &#39;/api1/x3/erp/QAL/XFACILITY?representation=XFACILITY.%24query&amp;count=50&amp;orderBy=UPDDATTIM%20desc&#39;
body = None
headers = {&#39;User-Agent&#39;: &#39;python-requests/2.28.1&#39;, &#39;Accept-Encoding&#39;: &#39;gzip, deflate&#39;, &#39;Accept&#39;: &#39;*/*&#39;, &#39;Connection&#39;: &#39;keep-alive&#39;, &#39;Content-Type&#39;: &#39;application/json&#39;, &#39;Authorization&#39;: &#39;Basic aW50cmFjbzpXYXNzaW1Db3ZhZ2VA&#39;}
retries = Retry(total=1, connect=None, read=None, redirect=None, status=None)
redirect = False, assert_same_host = False
timeout = Timeout(connect=None, read=None, total=None), pool_timeout = None
release_conn = False, chunked = False, body_pos = None
response_kw = {&#39;decode_content&#39;: False, &#39;preload_content&#39;: False, &#39;request_method&#39;: &#39;GET&#39;}
parsed_url = Url(scheme=None, auth=None, host=None, port=None, path=&#39;/api1/x3/erp/QAL/XFACILITY&#39;, query=&#39;representation=XFACILITY.%24query&amp;count=50&amp;orderBy=UPDDATTIM%20desc&#39;, fragment=None)
destination_scheme = None
conn = &lt;urllib3.connection.HTTPSConnection object at 0x7f34bbd0eeb0&gt;
release_this_conn = False, http_tunnel_required = True, err = None
clean_exit = True

    def urlopen(
        self,
        method,
        url,
        body=None,
        headers=None,
        retries=None,
        redirect=True,
        assert_same_host=True,
        timeout=_Default,
        pool_timeout=None,
        release_conn=None,
        chunked=False,
        body_pos=None,
        **response_kw
    ):
        &#34;&#34;&#34;
        Get a connection from the pool and perform an HTTP request. This is the
        lowest level call for making a request, so you&#39;ll need to specify all
        the raw details.
    
        .. note::
    
           More commonly, it&#39;s appropriate to use a convenience method provided
           by :class:`.RequestMethods`, such as :meth:`request`.
    
        .. note::
    
           `release_conn` will only behave as expected if
           `preload_content=False` because we want to make
           `preload_content=False` the default behaviour someday soon without
           breaking backwards compatibility.
    
        :param method:
            HTTP request method (such as GET, POST, PUT, etc.)
    
        :param url:
            The URL to perform the request on.
    
        :param body:
            Data to send in the request body, either :class:`str`, :class:`bytes`,
            an iterable of :class:`str`/:class:`bytes`, or a file-like object.
    
        :param headers:
            Dictionary of custom headers to send, such as User-Agent,
            If-None-Match, etc. If None, pool headers are used. If provided,
            these headers completely replace any pool-specific headers.
    
        :param retries:
            Configure the number of retries to allow before raising a
            :class:`~urllib3.exceptions.MaxRetryError` exception.
    
            Pass ``None`` to retry until you receive a response. Pass a
            :class:`~urllib3.util.retry.Retry` object for fine-grained control
            over different types of retries.
            Pass an integer number to retry connection errors that many times,
            but no other types of errors. Pass zero to never retry.
    
            If ``False``, then retries are disabled and any exception is raised
            immediately. Also, instead of raising a MaxRetryError on redirects,
            the redirect response will be returned.
    
        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.
    
        :param redirect:
            If True, automatically handle redirects (status codes 301, 302,
            303, 307, 308). Each redirect counts as a retry. Disabling retries
            will disable redirect, too.
    
        :param assert_same_host:
            If ``True``, will make sure that the host of the pool requests is
            consistent else will raise HostChangedError. When ``False``, you can
            use the pool on an HTTP proxy and request foreign hosts.
    
        :param timeout:
            If specified, overrides the default timeout for this one
            request. It may be a float (in seconds) or an instance of
            :class:`urllib3.util.Timeout`.
    
        :param pool_timeout:
            If set and the pool is set to block=True, then this method will
            block for ``pool_timeout`` seconds and raise EmptyPoolError if no
            connection is available within the time period.
    
        :param release_conn:
            If False, then the urlopen call will not release the connection
            back into the pool once a response is received (but will release if
            you read the entire contents of the response such as when
            `preload_content=True`). This is useful if you&#39;re not preloading
            the response&#39;s content immediately. You will need to call
            ``r.release_conn()`` on the response ``r`` to return the connection
            back into the pool. If None, it takes the value of
            ``response_kw.get(&#39;preload_content&#39;, True)``.
    
        :param chunked:
            If True, urllib3 will send the body using chunked transfer
            encoding. Otherwise, urllib3 will send the body using the standard
            content-length form. Defaults to False.
    
        :param int body_pos:
            Position to seek to in file-like body in the event of a retry or
            redirect. Typically this won&#39;t need to be set because urllib3 will
            auto-populate the value when needed.
    
        :param \\**response_kw:
            Additional parameters are passed to
            :meth:`urllib3.response.HTTPResponse.from_httplib`
        &#34;&#34;&#34;
    
        parsed_url = parse_url(url)
        destination_scheme = parsed_url.scheme
    
        if headers is None:
            headers = self.headers
    
        if not isinstance(retries, Retry):
            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)
    
        if release_conn is None:
            release_conn = response_kw.get(&#34;preload_content&#34;, True)
    
        # Check host
        if assert_same_host and not self.is_same_host(url):
            raise HostChangedError(self, url, retries)
    
        # Ensure that the URL we&#39;re connecting to is properly encoded
        if url.startswith(&#34;/&#34;):
            url = six.ensure_str(_encode_target(url))
        else:
            url = six.ensure_str(parsed_url.url)
    
        conn = None
    
        # Track whether `conn` needs to be released before
        # returning/raising/recursing. Update this variable if necessary, and
        # leave `release_conn` constant throughout the function. That way, if
        # the function recurses, the original value of `release_conn` will be
        # passed down into the recursive call, and its value will be respected.
        #
        # See issue #651 [1] for details.
        #
        # [1] &lt;https://github.com/urllib3/urllib3/issues/651&gt;
        release_this_conn = release_conn
    
        http_tunnel_required = connection_requires_http_tunnel(
            self.proxy, self.proxy_config, destination_scheme
        )
    
        # Merge the proxy headers. Only done when not using HTTP CONNECT. We
        # have to copy the headers dict so we can safely change it without those
        # changes being reflected in anyone else&#39;s copy.
        if not http_tunnel_required:
            headers = headers.copy()
            headers.update(self.proxy_headers)
    
        # Must keep the exception bound to a separate variable or else Python 3
        # complains about UnboundLocalError.
        err = None
    
        # Keep track of whether we cleanly exited the except block. This
        # ensures we do proper cleanup in finally.
        clean_exit = False
    
        # Rewind body position, if needed. Record current position
        # for future rewinds in the event of a redirect/retry.
        body_pos = set_file_position(body, body_pos)
    
        try:
            # Request a connection from the queue.
            timeout_obj = self._get_timeout(timeout)
            conn = self._get_conn(timeout=pool_timeout)
    
            conn.timeout = timeout_obj.connect_timeout
    
            is_new_proxy_conn = self.proxy is not None and not getattr(
                conn, &#34;sock&#34;, None
            )
            if is_new_proxy_conn and http_tunnel_required:
                self._prepare_proxy(conn)
    
            # Make the request on the httplib connection object.
            httplib_response = self._make_request(
                conn,
                method,
                url,
                timeout=timeout_obj,
                body=body,
                headers=headers,
                chunked=chunked,
            )
    
            # If we&#39;re going to release the connection in ``finally:``, then
            # the response doesn&#39;t need to know about the connection. Otherwise
            # it will also try to release it and we&#39;ll have a double-release
            # mess.
            response_conn = conn if not release_conn else None
    
            # Pass method to Response for length checking
            response_kw[&#34;request_method&#34;] = method
    
            # Import httplib&#39;s response into our own wrapper object
            response = self.ResponseCls.from_httplib(
                httplib_response,
                pool=self,
                connection=response_conn,
                retries=retries,
                **response_kw
            )
    
            # Everything went great!
            clean_exit = True
    
        except EmptyPoolError:
            # Didn&#39;t get a connection from the pool, no need to clean up
            clean_exit = True
            release_this_conn = False
            raise
    
        except (
            TimeoutError,
            HTTPException,
            SocketError,
            ProtocolError,
            BaseSSLError,
            SSLError,
            CertificateError,
        ) as e:
            # Discard the connection for these exceptions. It will be
            # replaced during the next _get_conn() call.
            clean_exit = False
    
            def _is_ssl_error_message_from_http_proxy(ssl_error):
                # We&#39;re trying to detect the message &#39;WRONG_VERSION_NUMBER&#39; but
                # SSLErrors are kinda all over the place when it comes to the message,
                # so we try to cover our bases here!
                message = &#34; &#34;.join(re.split(&#34;[^a-z]&#34;, str(ssl_error).lower()))
                return (
                    &#34;wrong version number&#34; in message or &#34;unknown protocol&#34; in message
                )
    
            # Try to detect a common user error with proxies which is to
            # set an HTTP proxy to be HTTPS when it should be &#39;http://&#39;
            # (ie {&#39;http&#39;: &#39;http://proxy&#39;, &#39;https&#39;: &#39;https://proxy&#39;})
            # Instead we add a nice error message and point to a URL.
            if (
                isinstance(e, BaseSSLError)
                and self.proxy
                and _is_ssl_error_message_from_http_proxy(e)
                and conn.proxy
                and conn.proxy.scheme == &#34;https&#34;
            ):
                e = ProxyError(
                    &#34;Your proxy appears to only use HTTP and not HTTPS, &#34;
                    &#34;try changing your proxy URL to be HTTP. See: &#34;
                    &#34;https://urllib3.readthedocs.io/en/1.26.x/advanced-usage.html&#34;
                    &#34;#https-proxy-error-http-proxy&#34;,
                    SSLError(e),
                )
            elif isinstance(e, (BaseSSLError, CertificateError)):
                e = SSLError(e)
            elif isinstance(e, (SocketError, NewConnectionError)) and self.proxy:
                e = ProxyError(&#34;Cannot connect to proxy.&#34;, e)
            elif isinstance(e, (SocketError, HTTPException)):
                e = ProtocolError(&#34;Connection aborted.&#34;, e)
    
            retries = retries.increment(
                method, url, error=e, _pool=self, _stacktrace=sys.exc_info()[2]
            )
            retries.sleep()
    
            # Keep track of the error for the retry warning.
            err = e
    
        finally:
            if not clean_exit:
                # We hit some kind of exception, handled or otherwise. We need
                # to throw the connection away unless explicitly told not to.
                # Close the connection, set the variable to None, and make sure
                # we put the None back in the pool to avoid leaking it.
                conn = conn and conn.close()
                release_this_conn = True
    
            if release_this_conn:
                # Put the connection back to be reused. If the connection is
                # expired then it will be None, which will get replaced with a
                # fresh connection during _get_conn.
                self._put_conn(conn)
    
        if not conn:
            # Try again
            log.warning(
                &#34;Retrying (%r) after connection broken by &#39;%r&#39;: %s&#34;, retries, err, url
            )
            return self.urlopen(
                method,
                url,
                body,
                headers,
                retries,
                redirect,
                assert_same_host,
                timeout=timeout,
                pool_timeout=pool_timeout,
                release_conn=release_conn,
                chunked=chunked,
                body_pos=body_pos,
                **response_kw
            )
    
        # Handle redirect?
        redirect_location = redirect and response.get_redirect_location()
        if redirect_location:
            if response.status == 303:
                method = &#34;GET&#34;
    
            try:
                retries = retries.increment(method, url, response=response, _pool=self)
            except MaxRetryError:
                if retries.raise_on_redirect:
                    response.drain_conn()
                    raise
                return response
    
            response.drain_conn()
            retries.sleep_for_retry(response)
            log.debug(&#34;Redirecting %s -&gt; %s&#34;, url, redirect_location)
            return self.urlopen(
                method,
                redirect_location,
                body,
                headers,
                retries=retries,
                redirect=redirect,
                assert_same_host=assert_same_host,
                timeout=timeout,
                pool_timeout=pool_timeout,
                release_conn=release_conn,
                chunked=chunked,
                body_pos=body_pos,
                **response_kw
            )
    
        # Check if we should retry the HTTP response.
        has_retry_after = bool(response.getheader(&#34;Retry-After&#34;))
        if retries.is_retry(method, response.status, has_retry_after):
            try:
                retries = retries.increment(method, url, response=response, _pool=self)
            except MaxRetryError:
                if retries.raise_on_status:
                    response.drain_conn()
                    raise
                return response
    
            response.drain_conn()
            retries.sleep(response)
            log.debug(&#34;Retry: %s&#34;, url)
&gt;           return self.urlopen(
                method,
                url,
                body,
                headers,
                retries=retries,
                redirect=redirect,
                assert_same_host=assert_same_host,
                timeout=timeout,
                pool_timeout=pool_timeout,
                release_conn=release_conn,
                chunked=chunked,
                body_pos=body_pos,
                **response_kw
            )

/usr/local/lib/python3.8/site-packages/urllib3/connectionpool.py:878: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connectionpool.HTTPSConnectionPool object at 0x7f34c006af40&gt;
method = &#39;GET&#39;
url = &#39;/api1/x3/erp/QAL/XFACILITY?representation=XFACILITY.%24query&amp;count=50&amp;orderBy=UPDDATTIM%20desc&#39;
body = None
headers = {&#39;User-Agent&#39;: &#39;python-requests/2.28.1&#39;, &#39;Accept-Encoding&#39;: &#39;gzip, deflate&#39;, &#39;Accept&#39;: &#39;*/*&#39;, &#39;Connection&#39;: &#39;keep-alive&#39;, &#39;Content-Type&#39;: &#39;application/json&#39;, &#39;Authorization&#39;: &#39;Basic aW50cmFjbzpXYXNzaW1Db3ZhZ2VA&#39;}
retries = Retry(total=0, connect=None, read=None, redirect=None, status=None)
redirect = False, assert_same_host = False
timeout = Timeout(connect=None, read=None, total=None), pool_timeout = None
release_conn = False, chunked = False, body_pos = None
response_kw = {&#39;decode_content&#39;: False, &#39;preload_content&#39;: False, &#39;request_method&#39;: &#39;GET&#39;}
parsed_url = Url(scheme=None, auth=None, host=None, port=None, path=&#39;/api1/x3/erp/QAL/XFACILITY&#39;, query=&#39;representation=XFACILITY.%24query&amp;count=50&amp;orderBy=UPDDATTIM%20desc&#39;, fragment=None)
destination_scheme = None
conn = &lt;urllib3.connection.HTTPSConnection object at 0x7f34bbd0eeb0&gt;
release_this_conn = False, http_tunnel_required = True, err = None
clean_exit = True

    def urlopen(
        self,
        method,
        url,
        body=None,
        headers=None,
        retries=None,
        redirect=True,
        assert_same_host=True,
        timeout=_Default,
        pool_timeout=None,
        release_conn=None,
        chunked=False,
        body_pos=None,
        **response_kw
    ):
        &#34;&#34;&#34;
        Get a connection from the pool and perform an HTTP request. This is the
        lowest level call for making a request, so you&#39;ll need to specify all
        the raw details.
    
        .. note::
    
           More commonly, it&#39;s appropriate to use a convenience method provided
           by :class:`.RequestMethods`, such as :meth:`request`.
    
        .. note::
    
           `release_conn` will only behave as expected if
           `preload_content=False` because we want to make
           `preload_content=False` the default behaviour someday soon without
           breaking backwards compatibility.
    
        :param method:
            HTTP request method (such as GET, POST, PUT, etc.)
    
        :param url:
            The URL to perform the request on.
    
        :param body:
            Data to send in the request body, either :class:`str`, :class:`bytes`,
            an iterable of :class:`str`/:class:`bytes`, or a file-like object.
    
        :param headers:
            Dictionary of custom headers to send, such as User-Agent,
            If-None-Match, etc. If None, pool headers are used. If provided,
            these headers completely replace any pool-specific headers.
    
        :param retries:
            Configure the number of retries to allow before raising a
            :class:`~urllib3.exceptions.MaxRetryError` exception.
    
            Pass ``None`` to retry until you receive a response. Pass a
            :class:`~urllib3.util.retry.Retry` object for fine-grained control
            over different types of retries.
            Pass an integer number to retry connection errors that many times,
            but no other types of errors. Pass zero to never retry.
    
            If ``False``, then retries are disabled and any exception is raised
            immediately. Also, instead of raising a MaxRetryError on redirects,
            the redirect response will be returned.
    
        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.
    
        :param redirect:
            If True, automatically handle redirects (status codes 301, 302,
            303, 307, 308). Each redirect counts as a retry. Disabling retries
            will disable redirect, too.
    
        :param assert_same_host:
            If ``True``, will make sure that the host of the pool requests is
            consistent else will raise HostChangedError. When ``False``, you can
            use the pool on an HTTP proxy and request foreign hosts.
    
        :param timeout:
            If specified, overrides the default timeout for this one
            request. It may be a float (in seconds) or an instance of
            :class:`urllib3.util.Timeout`.
    
        :param pool_timeout:
            If set and the pool is set to block=True, then this method will
            block for ``pool_timeout`` seconds and raise EmptyPoolError if no
            connection is available within the time period.
    
        :param release_conn:
            If False, then the urlopen call will not release the connection
            back into the pool once a response is received (but will release if
            you read the entire contents of the response such as when
            `preload_content=True`). This is useful if you&#39;re not preloading
            the response&#39;s content immediately. You will need to call
            ``r.release_conn()`` on the response ``r`` to return the connection
            back into the pool. If None, it takes the value of
            ``response_kw.get(&#39;preload_content&#39;, True)``.
    
        :param chunked:
            If True, urllib3 will send the body using chunked transfer
            encoding. Otherwise, urllib3 will send the body using the standard
            content-length form. Defaults to False.
    
        :param int body_pos:
            Position to seek to in file-like body in the event of a retry or
            redirect. Typically this won&#39;t need to be set because urllib3 will
            auto-populate the value when needed.
    
        :param \\**response_kw:
            Additional parameters are passed to
            :meth:`urllib3.response.HTTPResponse.from_httplib`
        &#34;&#34;&#34;
    
        parsed_url = parse_url(url)
        destination_scheme = parsed_url.scheme
    
        if headers is None:
            headers = self.headers
    
        if not isinstance(retries, Retry):
            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)
    
        if release_conn is None:
            release_conn = response_kw.get(&#34;preload_content&#34;, True)
    
        # Check host
        if assert_same_host and not self.is_same_host(url):
            raise HostChangedError(self, url, retries)
    
        # Ensure that the URL we&#39;re connecting to is properly encoded
        if url.startswith(&#34;/&#34;):
            url = six.ensure_str(_encode_target(url))
        else:
            url = six.ensure_str(parsed_url.url)
    
        conn = None
    
        # Track whether `conn` needs to be released before
        # returning/raising/recursing. Update this variable if necessary, and
        # leave `release_conn` constant throughout the function. That way, if
        # the function recurses, the original value of `release_conn` will be
        # passed down into the recursive call, and its value will be respected.
        #
        # See issue #651 [1] for details.
        #
        # [1] &lt;https://github.com/urllib3/urllib3/issues/651&gt;
        release_this_conn = release_conn
    
        http_tunnel_required = connection_requires_http_tunnel(
            self.proxy, self.proxy_config, destination_scheme
        )
    
        # Merge the proxy headers. Only done when not using HTTP CONNECT. We
        # have to copy the headers dict so we can safely change it without those
        # changes being reflected in anyone else&#39;s copy.
        if not http_tunnel_required:
            headers = headers.copy()
            headers.update(self.proxy_headers)
    
        # Must keep the exception bound to a separate variable or else Python 3
        # complains about UnboundLocalError.
        err = None
    
        # Keep track of whether we cleanly exited the except block. This
        # ensures we do proper cleanup in finally.
        clean_exit = False
    
        # Rewind body position, if needed. Record current position
        # for future rewinds in the event of a redirect/retry.
        body_pos = set_file_position(body, body_pos)
    
        try:
            # Request a connection from the queue.
            timeout_obj = self._get_timeout(timeout)
            conn = self._get_conn(timeout=pool_timeout)
    
            conn.timeout = timeout_obj.connect_timeout
    
            is_new_proxy_conn = self.proxy is not None and not getattr(
                conn, &#34;sock&#34;, None
            )
            if is_new_proxy_conn and http_tunnel_required:
                self._prepare_proxy(conn)
    
            # Make the request on the httplib connection object.
            httplib_response = self._make_request(
                conn,
                method,
                url,
                timeout=timeout_obj,
                body=body,
                headers=headers,
                chunked=chunked,
            )
    
            # If we&#39;re going to release the connection in ``finally:``, then
            # the response doesn&#39;t need to know about the connection. Otherwise
            # it will also try to release it and we&#39;ll have a double-release
            # mess.
            response_conn = conn if not release_conn else None
    
            # Pass method to Response for length checking
            response_kw[&#34;request_method&#34;] = method
    
            # Import httplib&#39;s response into our own wrapper object
            response = self.ResponseCls.from_httplib(
                httplib_response,
                pool=self,
                connection=response_conn,
                retries=retries,
                **response_kw
            )
    
            # Everything went great!
            clean_exit = True
    
        except EmptyPoolError:
            # Didn&#39;t get a connection from the pool, no need to clean up
            clean_exit = True
            release_this_conn = False
            raise
    
        except (
            TimeoutError,
            HTTPException,
            SocketError,
            ProtocolError,
            BaseSSLError,
            SSLError,
            CertificateError,
        ) as e:
            # Discard the connection for these exceptions. It will be
            # replaced during the next _get_conn() call.
            clean_exit = False
    
            def _is_ssl_error_message_from_http_proxy(ssl_error):
                # We&#39;re trying to detect the message &#39;WRONG_VERSION_NUMBER&#39; but
                # SSLErrors are kinda all over the place when it comes to the message,
                # so we try to cover our bases here!
                message = &#34; &#34;.join(re.split(&#34;[^a-z]&#34;, str(ssl_error).lower()))
                return (
                    &#34;wrong version number&#34; in message or &#34;unknown protocol&#34; in message
                )
    
            # Try to detect a common user error with proxies which is to
            # set an HTTP proxy to be HTTPS when it should be &#39;http://&#39;
            # (ie {&#39;http&#39;: &#39;http://proxy&#39;, &#39;https&#39;: &#39;https://proxy&#39;})
            # Instead we add a nice error message and point to a URL.
            if (
                isinstance(e, BaseSSLError)
                and self.proxy
                and _is_ssl_error_message_from_http_proxy(e)
                and conn.proxy
                and conn.proxy.scheme == &#34;https&#34;
            ):
                e = ProxyError(
                    &#34;Your proxy appears to only use HTTP and not HTTPS, &#34;
                    &#34;try changing your proxy URL to be HTTP. See: &#34;
                    &#34;https://urllib3.readthedocs.io/en/1.26.x/advanced-usage.html&#34;
                    &#34;#https-proxy-error-http-proxy&#34;,
                    SSLError(e),
                )
            elif isinstance(e, (BaseSSLError, CertificateError)):
                e = SSLError(e)
            elif isinstance(e, (SocketError, NewConnectionError)) and self.proxy:
                e = ProxyError(&#34;Cannot connect to proxy.&#34;, e)
            elif isinstance(e, (SocketError, HTTPException)):
                e = ProtocolError(&#34;Connection aborted.&#34;, e)
    
            retries = retries.increment(
                method, url, error=e, _pool=self, _stacktrace=sys.exc_info()[2]
            )
            retries.sleep()
    
            # Keep track of the error for the retry warning.
            err = e
    
        finally:
            if not clean_exit:
                # We hit some kind of exception, handled or otherwise. We need
                # to throw the connection away unless explicitly told not to.
                # Close the connection, set the variable to None, and make sure
                # we put the None back in the pool to avoid leaking it.
                conn = conn and conn.close()
                release_this_conn = True
    
            if release_this_conn:
                # Put the connection back to be reused. If the connection is
                # expired then it will be None, which will get replaced with a
                # fresh connection during _get_conn.
                self._put_conn(conn)
    
        if not conn:
            # Try again
            log.warning(
                &#34;Retrying (%r) after connection broken by &#39;%r&#39;: %s&#34;, retries, err, url
            )
            return self.urlopen(
                method,
                url,
                body,
                headers,
                retries,
                redirect,
                assert_same_host,
                timeout=timeout,
                pool_timeout=pool_timeout,
                release_conn=release_conn,
                chunked=chunked,
                body_pos=body_pos,
                **response_kw
            )
    
        # Handle redirect?
        redirect_location = redirect and response.get_redirect_location()
        if redirect_location:
            if response.status == 303:
                method = &#34;GET&#34;
    
            try:
                retries = retries.increment(method, url, response=response, _pool=self)
            except MaxRetryError:
                if retries.raise_on_redirect:
                    response.drain_conn()
                    raise
                return response
    
            response.drain_conn()
            retries.sleep_for_retry(response)
            log.debug(&#34;Redirecting %s -&gt; %s&#34;, url, redirect_location)
            return self.urlopen(
                method,
                redirect_location,
                body,
                headers,
                retries=retries,
                redirect=redirect,
                assert_same_host=assert_same_host,
                timeout=timeout,
                pool_timeout=pool_timeout,
                release_conn=release_conn,
                chunked=chunked,
                body_pos=body_pos,
                **response_kw
            )
    
        # Check if we should retry the HTTP response.
        has_retry_after = bool(response.getheader(&#34;Retry-After&#34;))
        if retries.is_retry(method, response.status, has_retry_after):
            try:
                retries = retries.increment(method, url, response=response, _pool=self)
            except MaxRetryError:
                if retries.raise_on_status:
                    response.drain_conn()
                    raise
                return response
    
            response.drain_conn()
            retries.sleep(response)
            log.debug(&#34;Retry: %s&#34;, url)
&gt;           return self.urlopen(
                method,
                url,
                body,
                headers,
                retries=retries,
                redirect=redirect,
                assert_same_host=assert_same_host,
                timeout=timeout,
                pool_timeout=pool_timeout,
                release_conn=release_conn,
                chunked=chunked,
                body_pos=body_pos,
                **response_kw
            )

/usr/local/lib/python3.8/site-packages/urllib3/connectionpool.py:878: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connectionpool.HTTPSConnectionPool object at 0x7f34c006af40&gt;
method = &#39;GET&#39;
url = &#39;/api1/x3/erp/QAL/XFACILITY?representation=XFACILITY.%24query&amp;count=50&amp;orderBy=UPDDATTIM%20desc&#39;
body = None
headers = {&#39;User-Agent&#39;: &#39;python-requests/2.28.1&#39;, &#39;Accept-Encoding&#39;: &#39;gzip, deflate&#39;, &#39;Accept&#39;: &#39;*/*&#39;, &#39;Connection&#39;: &#39;keep-alive&#39;, &#39;Content-Type&#39;: &#39;application/json&#39;, &#39;Authorization&#39;: &#39;Basic aW50cmFjbzpXYXNzaW1Db3ZhZ2VA&#39;}
retries = Retry(total=0, connect=None, read=None, redirect=None, status=None)
redirect = False, assert_same_host = False
timeout = Timeout(connect=None, read=None, total=None), pool_timeout = None
release_conn = False, chunked = False, body_pos = None
response_kw = {&#39;decode_content&#39;: False, &#39;preload_content&#39;: False, &#39;request_method&#39;: &#39;GET&#39;}
parsed_url = Url(scheme=None, auth=None, host=None, port=None, path=&#39;/api1/x3/erp/QAL/XFACILITY&#39;, query=&#39;representation=XFACILITY.%24query&amp;count=50&amp;orderBy=UPDDATTIM%20desc&#39;, fragment=None)
destination_scheme = None
conn = &lt;urllib3.connection.HTTPSConnection object at 0x7f34bbd0eeb0&gt;
release_this_conn = False, http_tunnel_required = True, err = None
clean_exit = True

    def urlopen(
        self,
        method,
        url,
        body=None,
        headers=None,
        retries=None,
        redirect=True,
        assert_same_host=True,
        timeout=_Default,
        pool_timeout=None,
        release_conn=None,
        chunked=False,
        body_pos=None,
        **response_kw
    ):
        &#34;&#34;&#34;
        Get a connection from the pool and perform an HTTP request. This is the
        lowest level call for making a request, so you&#39;ll need to specify all
        the raw details.
    
        .. note::
    
           More commonly, it&#39;s appropriate to use a convenience method provided
           by :class:`.RequestMethods`, such as :meth:`request`.
    
        .. note::
    
           `release_conn` will only behave as expected if
           `preload_content=False` because we want to make
           `preload_content=False` the default behaviour someday soon without
           breaking backwards compatibility.
    
        :param method:
            HTTP request method (such as GET, POST, PUT, etc.)
    
        :param url:
            The URL to perform the request on.
    
        :param body:
            Data to send in the request body, either :class:`str`, :class:`bytes`,
            an iterable of :class:`str`/:class:`bytes`, or a file-like object.
    
        :param headers:
            Dictionary of custom headers to send, such as User-Agent,
            If-None-Match, etc. If None, pool headers are used. If provided,
            these headers completely replace any pool-specific headers.
    
        :param retries:
            Configure the number of retries to allow before raising a
            :class:`~urllib3.exceptions.MaxRetryError` exception.
    
            Pass ``None`` to retry until you receive a response. Pass a
            :class:`~urllib3.util.retry.Retry` object for fine-grained control
            over different types of retries.
            Pass an integer number to retry connection errors that many times,
            but no other types of errors. Pass zero to never retry.
    
            If ``False``, then retries are disabled and any exception is raised
            immediately. Also, instead of raising a MaxRetryError on redirects,
            the redirect response will be returned.
    
        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.
    
        :param redirect:
            If True, automatically handle redirects (status codes 301, 302,
            303, 307, 308). Each redirect counts as a retry. Disabling retries
            will disable redirect, too.
    
        :param assert_same_host:
            If ``True``, will make sure that the host of the pool requests is
            consistent else will raise HostChangedError. When ``False``, you can
            use the pool on an HTTP proxy and request foreign hosts.
    
        :param timeout:
            If specified, overrides the default timeout for this one
            request. It may be a float (in seconds) or an instance of
            :class:`urllib3.util.Timeout`.
    
        :param pool_timeout:
            If set and the pool is set to block=True, then this method will
            block for ``pool_timeout`` seconds and raise EmptyPoolError if no
            connection is available within the time period.
    
        :param release_conn:
            If False, then the urlopen call will not release the connection
            back into the pool once a response is received (but will release if
            you read the entire contents of the response such as when
            `preload_content=True`). This is useful if you&#39;re not preloading
            the response&#39;s content immediately. You will need to call
            ``r.release_conn()`` on the response ``r`` to return the connection
            back into the pool. If None, it takes the value of
            ``response_kw.get(&#39;preload_content&#39;, True)``.
    
        :param chunked:
            If True, urllib3 will send the body using chunked transfer
            encoding. Otherwise, urllib3 will send the body using the standard
            content-length form. Defaults to False.
    
        :param int body_pos:
            Position to seek to in file-like body in the event of a retry or
            redirect. Typically this won&#39;t need to be set because urllib3 will
            auto-populate the value when needed.
    
        :param \\**response_kw:
            Additional parameters are passed to
            :meth:`urllib3.response.HTTPResponse.from_httplib`
        &#34;&#34;&#34;
    
        parsed_url = parse_url(url)
        destination_scheme = parsed_url.scheme
    
        if headers is None:
            headers = self.headers
    
        if not isinstance(retries, Retry):
            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)
    
        if release_conn is None:
            release_conn = response_kw.get(&#34;preload_content&#34;, True)
    
        # Check host
        if assert_same_host and not self.is_same_host(url):
            raise HostChangedError(self, url, retries)
    
        # Ensure that the URL we&#39;re connecting to is properly encoded
        if url.startswith(&#34;/&#34;):
            url = six.ensure_str(_encode_target(url))
        else:
            url = six.ensure_str(parsed_url.url)
    
        conn = None
    
        # Track whether `conn` needs to be released before
        # returning/raising/recursing. Update this variable if necessary, and
        # leave `release_conn` constant throughout the function. That way, if
        # the function recurses, the original value of `release_conn` will be
        # passed down into the recursive call, and its value will be respected.
        #
        # See issue #651 [1] for details.
        #
        # [1] &lt;https://github.com/urllib3/urllib3/issues/651&gt;
        release_this_conn = release_conn
    
        http_tunnel_required = connection_requires_http_tunnel(
            self.proxy, self.proxy_config, destination_scheme
        )
    
        # Merge the proxy headers. Only done when not using HTTP CONNECT. We
        # have to copy the headers dict so we can safely change it without those
        # changes being reflected in anyone else&#39;s copy.
        if not http_tunnel_required:
            headers = headers.copy()
            headers.update(self.proxy_headers)
    
        # Must keep the exception bound to a separate variable or else Python 3
        # complains about UnboundLocalError.
        err = None
    
        # Keep track of whether we cleanly exited the except block. This
        # ensures we do proper cleanup in finally.
        clean_exit = False
    
        # Rewind body position, if needed. Record current position
        # for future rewinds in the event of a redirect/retry.
        body_pos = set_file_position(body, body_pos)
    
        try:
            # Request a connection from the queue.
            timeout_obj = self._get_timeout(timeout)
            conn = self._get_conn(timeout=pool_timeout)
    
            conn.timeout = timeout_obj.connect_timeout
    
            is_new_proxy_conn = self.proxy is not None and not getattr(
                conn, &#34;sock&#34;, None
            )
            if is_new_proxy_conn and http_tunnel_required:
                self._prepare_proxy(conn)
    
            # Make the request on the httplib connection object.
            httplib_response = self._make_request(
                conn,
                method,
                url,
                timeout=timeout_obj,
                body=body,
                headers=headers,
                chunked=chunked,
            )
    
            # If we&#39;re going to release the connection in ``finally:``, then
            # the response doesn&#39;t need to know about the connection. Otherwise
            # it will also try to release it and we&#39;ll have a double-release
            # mess.
            response_conn = conn if not release_conn else None
    
            # Pass method to Response for length checking
            response_kw[&#34;request_method&#34;] = method
    
            # Import httplib&#39;s response into our own wrapper object
            response = self.ResponseCls.from_httplib(
                httplib_response,
                pool=self,
                connection=response_conn,
                retries=retries,
                **response_kw
            )
    
            # Everything went great!
            clean_exit = True
    
        except EmptyPoolError:
            # Didn&#39;t get a connection from the pool, no need to clean up
            clean_exit = True
            release_this_conn = False
            raise
    
        except (
            TimeoutError,
            HTTPException,
            SocketError,
            ProtocolError,
            BaseSSLError,
            SSLError,
            CertificateError,
        ) as e:
            # Discard the connection for these exceptions. It will be
            # replaced during the next _get_conn() call.
            clean_exit = False
    
            def _is_ssl_error_message_from_http_proxy(ssl_error):
                # We&#39;re trying to detect the message &#39;WRONG_VERSION_NUMBER&#39; but
                # SSLErrors are kinda all over the place when it comes to the message,
                # so we try to cover our bases here!
                message = &#34; &#34;.join(re.split(&#34;[^a-z]&#34;, str(ssl_error).lower()))
                return (
                    &#34;wrong version number&#34; in message or &#34;unknown protocol&#34; in message
                )
    
            # Try to detect a common user error with proxies which is to
            # set an HTTP proxy to be HTTPS when it should be &#39;http://&#39;
            # (ie {&#39;http&#39;: &#39;http://proxy&#39;, &#39;https&#39;: &#39;https://proxy&#39;})
            # Instead we add a nice error message and point to a URL.
            if (
                isinstance(e, BaseSSLError)
                and self.proxy
                and _is_ssl_error_message_from_http_proxy(e)
                and conn.proxy
                and conn.proxy.scheme == &#34;https&#34;
            ):
                e = ProxyError(
                    &#34;Your proxy appears to only use HTTP and not HTTPS, &#34;
                    &#34;try changing your proxy URL to be HTTP. See: &#34;
                    &#34;https://urllib3.readthedocs.io/en/1.26.x/advanced-usage.html&#34;
                    &#34;#https-proxy-error-http-proxy&#34;,
                    SSLError(e),
                )
            elif isinstance(e, (BaseSSLError, CertificateError)):
                e = SSLError(e)
            elif isinstance(e, (SocketError, NewConnectionError)) and self.proxy:
                e = ProxyError(&#34;Cannot connect to proxy.&#34;, e)
            elif isinstance(e, (SocketError, HTTPException)):
                e = ProtocolError(&#34;Connection aborted.&#34;, e)
    
            retries = retries.increment(
                method, url, error=e, _pool=self, _stacktrace=sys.exc_info()[2]
            )
            retries.sleep()
    
            # Keep track of the error for the retry warning.
            err = e
    
        finally:
            if not clean_exit:
                # We hit some kind of exception, handled or otherwise. We need
                # to throw the connection away unless explicitly told not to.
                # Close the connection, set the variable to None, and make sure
                # we put the None back in the pool to avoid leaking it.
                conn = conn and conn.close()
                release_this_conn = True
    
            if release_this_conn:
                # Put the connection back to be reused. If the connection is
                # expired then it will be None, which will get replaced with a
                # fresh connection during _get_conn.
                self._put_conn(conn)
    
        if not conn:
            # Try again
            log.warning(
                &#34;Retrying (%r) after connection broken by &#39;%r&#39;: %s&#34;, retries, err, url
            )
            return self.urlopen(
                method,
                url,
                body,
                headers,
                retries,
                redirect,
                assert_same_host,
                timeout=timeout,
                pool_timeout=pool_timeout,
                release_conn=release_conn,
                chunked=chunked,
                body_pos=body_pos,
                **response_kw
            )
    
        # Handle redirect?
        redirect_location = redirect and response.get_redirect_location()
        if redirect_location:
            if response.status == 303:
                method = &#34;GET&#34;
    
            try:
                retries = retries.increment(method, url, response=response, _pool=self)
            except MaxRetryError:
                if retries.raise_on_redirect:
                    response.drain_conn()
                    raise
                return response
    
            response.drain_conn()
            retries.sleep_for_retry(response)
            log.debug(&#34;Redirecting %s -&gt; %s&#34;, url, redirect_location)
            return self.urlopen(
                method,
                redirect_location,
                body,
                headers,
                retries=retries,
                redirect=redirect,
                assert_same_host=assert_same_host,
                timeout=timeout,
                pool_timeout=pool_timeout,
                release_conn=release_conn,
                chunked=chunked,
                body_pos=body_pos,
                **response_kw
            )
    
        # Check if we should retry the HTTP response.
        has_retry_after = bool(response.getheader(&#34;Retry-After&#34;))
        if retries.is_retry(method, response.status, has_retry_after):
            try:
&gt;               retries = retries.increment(method, url, response=response, _pool=self)

/usr/local/lib/python3.8/site-packages/urllib3/connectionpool.py:868: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Retry(total=0, connect=None, read=None, redirect=None, status=None)
method = &#39;GET&#39;
url = &#39;/api1/x3/erp/QAL/XFACILITY?representation=XFACILITY.%24query&amp;count=50&amp;orderBy=UPDDATTIM%20desc&#39;
response = &lt;urllib3.response.HTTPResponse object at 0x7f34bbd3a8b0&gt;
error = None
_pool = &lt;urllib3.connectionpool.HTTPSConnectionPool object at 0x7f34c006af40&gt;
_stacktrace = None

    def increment(
        self,
        method=None,
        url=None,
        response=None,
        error=None,
        _pool=None,
        _stacktrace=None,
    ):
        &#34;&#34;&#34;Return a new Retry object with incremented retry counters.
    
        :param response: A response object, or None, if the server did not
            return a response.
        :type response: :class:`~urllib3.response.HTTPResponse`
        :param Exception error: An error encountered during the request, or
            None if the response was received successfully.
    
        :return: A new ``Retry`` object.
        &#34;&#34;&#34;
        if self.total is False and error:
            # Disabled, indicate to re-raise the error.
            raise six.reraise(type(error), error, _stacktrace)
    
        total = self.total
        if total is not None:
            total -= 1
    
        connect = self.connect
        read = self.read
        redirect = self.redirect
        status_count = self.status
        other = self.other
        cause = &#34;unknown&#34;
        status = None
        redirect_location = None
    
        if error and self._is_connection_error(error):
            # Connect retry?
            if connect is False:
                raise six.reraise(type(error), error, _stacktrace)
            elif connect is not None:
                connect -= 1
    
        elif error and self._is_read_error(error):
            # Read retry?
            if read is False or not self._is_method_retryable(method):
                raise six.reraise(type(error), error, _stacktrace)
            elif read is not None:
                read -= 1
    
        elif error:
            # Other retry?
            if other is not None:
                other -= 1
    
        elif response and response.get_redirect_location():
            # Redirect retry?
            if redirect is not None:
                redirect -= 1
            cause = &#34;too many redirects&#34;
            redirect_location = response.get_redirect_location()
            status = response.status
    
        else:
            # Incrementing because of a server error like a 500 in
            # status_forcelist and the given method is in the allowed_methods
            cause = ResponseError.GENERIC_ERROR
            if response and response.status:
                if status_count is not None:
                    status_count -= 1
                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)
                status = response.status
    
        history = self.history + (
            RequestHistory(method, url, error, status, redirect_location),
        )
    
        new_retry = self.new(
            total=total,
            connect=connect,
            read=read,
            redirect=redirect,
            status=status_count,
            other=other,
            history=history,
        )
    
        if new_retry.is_exhausted():
&gt;           raise MaxRetryError(_pool, url, error or ResponseError(cause))
E           urllib3.exceptions.MaxRetryError: HTTPSConnectionPool(host=&#39;sagex3-horsprod.covage.com&#39;, port=443): Max retries exceeded with url: /api1/x3/erp/QAL/XFACILITY?representation=XFACILITY.%24query&amp;count=50&amp;orderBy=UPDDATTIM%20desc (Caused by ResponseError(&#39;too many 502 error responses&#39;))

/usr/local/lib/python3.8/site-packages/urllib3/util/retry.py:592: MaxRetryError

During handling of the above exception, another exception occurred:

x3_client = &lt;x3_wrapper.rest_client.X3RestClient object at 0x7f34c006a910&gt;

    @pytest.mark.livetest
    @pytest.mark.xfail
    @pytest.mark.read_data
    def test_x3_schema_query_facility(x3_client):
        &#34;&#34;&#34;Validate X3 facility schema representation `XFACILITY` query&#34;&#34;&#34;
&gt;       resp = x3_client.list(
            class_name=&#34;XFACILITY&#34;,
            representation=&#34;XFACILITY&#34;,
            count=50,
            **{&#34;orderBy&#34;: &#34;UPDDATTIM desc&#34;},
        )

app/api/live_tests/test_facility/test_query_facility.py:12: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
app/x3_wrapper/rest_client.py:84: in list
    resp = self._cal_x3(&#34;GET&#34;, url, query_params)
app/x3_wrapper/rest_client.py:70: in _cal_x3
    resp = self.client.request(method, url, params=query_params)
/usr/local/lib/python3.8/site-packages/requests/sessions.py:587: in request
    resp = self.send(prep, **send_kwargs)
/usr/local/lib/python3.8/site-packages/requests/sessions.py:701: in send
    r = adapter.send(request, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;requests.adapters.HTTPAdapter object at 0x7f34c006a3a0&gt;
request = &lt;PreparedRequest [GET]&gt;, stream = False
timeout = Timeout(connect=None, read=None, total=None), verify = True
cert = None
proxies = OrderedDict([(&#39;no&#39;, &#39;gitlab-runner-cache-01-prd.nut.covage.com&#39;), (&#39;http&#39;, &#39;http://squid.kosc.net:3128&#39;), (&#39;https&#39;, &#39;http://squid.kosc.net:3128&#39;)])

    def send(
        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None
    ):
        &#34;&#34;&#34;Sends PreparedRequest object. Returns Response object.
    
        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.
        :param stream: (optional) Whether to stream the request content.
        :param timeout: (optional) How long to wait for the server to send
            data before giving up, as a float, or a :ref:`(connect timeout,
            read timeout) &lt;timeouts&gt;` tuple.
        :type timeout: float or tuple or urllib3 Timeout object
        :param verify: (optional) Either a boolean, in which case it controls whether
            we verify the server&#39;s TLS certificate, or a string, in which case it
            must be a path to a CA bundle to use
        :param cert: (optional) Any user-provided SSL certificate to be trusted.
        :param proxies: (optional) The proxies dictionary to apply to the request.
        :rtype: requests.Response
        &#34;&#34;&#34;
    
        try:
            conn = self.get_connection(request.url, proxies)
        except LocationValueError as e:
            raise InvalidURL(e, request=request)
    
        self.cert_verify(conn, request.url, verify, cert)
        url = self.request_url(request, proxies)
        self.add_headers(
            request,
            stream=stream,
            timeout=timeout,
            verify=verify,
            cert=cert,
            proxies=proxies,
        )
    
        chunked = not (request.body is None or &#34;Content-Length&#34; in request.headers)
    
        if isinstance(timeout, tuple):
            try:
                connect, read = timeout
                timeout = TimeoutSauce(connect=connect, read=read)
            except ValueError:
                raise ValueError(
                    f&#34;Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, &#34;
                    f&#34;or a single float to set both timeouts to the same value.&#34;
                )
        elif isinstance(timeout, TimeoutSauce):
            pass
        else:
            timeout = TimeoutSauce(connect=timeout, read=timeout)
    
        try:
            if not chunked:
                resp = conn.urlopen(
                    method=request.method,
                    url=url,
                    body=request.body,
                    headers=request.headers,
                    redirect=False,
                    assert_same_host=False,
                    preload_content=False,
                    decode_content=False,
                    retries=self.max_retries,
                    timeout=timeout,
                )
    
            # Send the request.
            else:
                if hasattr(conn, &#34;proxy_pool&#34;):
                    conn = conn.proxy_pool
    
                low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)
    
                try:
                    skip_host = &#34;Host&#34; in request.headers
                    low_conn.putrequest(
                        request.method,
                        url,
                        skip_accept_encoding=True,
                        skip_host=skip_host,
                    )
    
                    for header, value in request.headers.items():
                        low_conn.putheader(header, value)
    
                    low_conn.endheaders()
    
                    for i in request.body:
                        low_conn.send(hex(len(i))[2:].encode(&#34;utf-8&#34;))
                        low_conn.send(b&#34;\r\n&#34;)
                        low_conn.send(i)
                        low_conn.send(b&#34;\r\n&#34;)
                    low_conn.send(b&#34;0\r\n\r\n&#34;)
    
                    # Receive the response from the server
                    r = low_conn.getresponse()
    
                    resp = HTTPResponse.from_httplib(
                        r,
                        pool=conn,
                        connection=low_conn,
                        preload_content=False,
                        decode_content=False,
                    )
                except Exception:
                    # If we hit any problems here, clean up the connection.
                    # Then, raise so that we can handle the actual exception.
                    low_conn.close()
                    raise
    
        except (ProtocolError, OSError) as err:
            raise ConnectionError(err, request=request)
    
        except MaxRetryError as e:
            if isinstance(e.reason, ConnectTimeoutError):
                # TODO: Remove this in 3.0.0: see #2811
                if not isinstance(e.reason, NewConnectionError):
                    raise ConnectTimeout(e, request=request)
    
            if isinstance(e.reason, ResponseError):
&gt;               raise RetryError(e, request=request)
E               requests.exceptions.RetryError: HTTPSConnectionPool(host=&#39;sagex3-horsprod.covage.com&#39;, port=443): Max retries exceeded with url: /api1/x3/erp/QAL/XFACILITY?representation=XFACILITY.%24query&amp;count=50&amp;orderBy=UPDDATTIM%20desc (Caused by ResponseError(&#39;too many 502 error responses&#39;))

/usr/local/lib/python3.8/site-packages/requests/adapters.py:556: RetryError</pre> </div> </div> </details> <details class="phase teardown "> <summary> <h4 class=title> <span class=phase-name>Teardown</span> </h4> </summary> <div class=content> </div> </details> </div> </div> </details> <details class="test xfailed"> <summary> <h3 class="title test-title"> <span class="status badge xfailed ">XFAIL</span> <span class=test-name> <span class=funcname>test_api_list_facilities</span> </span> <span class=duration>0:00:00.723795</span> </h3> </summary> <div class=content> <div class=documentation> <p>Validate api schema representation for route <cite>/catalogs/</cite></p> <p>Test order_by and filter params</p> </div> <table class=metadata> <tr> <th>Started</th> <td>2023-06-30 01:14:56</td> </tr> <tr> <th>Ended</th> <td>2023-06-30 01:14:57</td> </tr> <tr> <th>Duration</th> <td>0:00:00.723795</td> </tr> <tr> <th>Markers</th> <td> <div class=marker> <span class="marker-name badge">read_data</span> <span class=marker-args> </span> </div> <div class=marker> <span class="marker-name badge">xfail</span> <span class=marker-args> </span> </div> <div class=marker> <span class="marker-name badge">livetest</span> <span class=marker-args> </span> </div> </td> </tr> <tr> <th>Fixtures</th> <td> <span class="badge fixturename"> django_test_environment </span> <span class="badge fixturename"> django_db_blocker </span> <span class="badge fixturename"> test_client </span> <span class="badge fixturename"> request </span> </td> </tr> </table> <div class=repr> <pre>AssertionError: b&#39;{&#34;detail&#34;:&#34;Server Error (500)&#34;,&#34;status_code&#34;:500}&#39;
assert 500 == 200
 +  where 500 = &lt;Response [500]&gt;.status_code</pre> </div> <div class=test-phases> <details class="phase setup "> <summary> <h4 class=title> <span class=phase-name>Setup</span> </h4> </summary> <div class=content> </div> </details> <details class="phase call xfailed" open> <summary> <h4 class=title> <span class="status  xfailed"></span> <span class=phase-name>Call</span> </h4> </summary> <div class=content> <div class=repr> <pre>test_client = &lt;conftest.LiveServerSession object at 0x7f34bb9fd3a0&gt;

    @pytest.mark.livetest
    @pytest.mark.xfail
    @pytest.mark.read_data
    def test_api_list_facilities(test_client):
        &#34;&#34;&#34;
        Validate api schema representation for route `/catalogs/`\n
        Test order_by and filter params
        &#34;&#34;&#34;
        resp_1 = test_client.get(&#34;/api/v0/facilities/&#34;)
&gt;       assert resp_1.status_code == 200, resp_1.content
E       AssertionError: b&#39;{&#34;detail&#34;:&#34;Server Error (500)&#34;,&#34;status_code&#34;:500}&#39;
E       assert 500 == 200
E        +  where 500 = &lt;Response [500]&gt;.status_code

app/api/live_tests/test_facility/test_query_facility.py:30: AssertionError</pre> </div> </div> </details> <details class="phase teardown "> <summary> <h4 class=title> <span class=phase-name>Teardown</span> </h4> </summary> <div class=content> </div> </details> </div> </div> </details> </div> </details> <details class=file> <summary> <h2 class="title file-title"> <span class=fspath> app/api/live_tests/test_validate_import_schema.py </span> <span class=counts> <span title="6 xfailed" class="count status badge xfailed ">6</span> </span> <span class=duration> 0:00:05.333487 </span> </h2> </summary> <div class="content box"> <details class="test xfailed"> <summary> <h3 class="title test-title"> <span class="status badge xfailed ">XFAIL</span> <span class=test-name> <span class=funcname>test_validate_schema_WYXOHKSC</span><span class=params>[QAL]</span> </span> <span class=duration>0:00:02.003188</span> </h3> </summary> <div class=content> <div class=documentation> <p>Compare diff for <cite>WYXOHKSC</cite> model between local snapshot and os.environ[&quot;LIVE_TEST_X3_FOLDER&quot;]</p> <p>WYXOHKSC: Contract import</p> </div> <table class=metadata> <tr> <th>Started</th> <td>2023-06-30 01:14:33</td> </tr> <tr> <th>Ended</th> <td>2023-06-30 01:14:35</td> </tr> <tr> <th>Duration</th> <td>0:00:02.003188</td> </tr> <tr> <th>Markers</th> <td> <div class=marker> <span class="marker-name badge">xfail</span> <span class=marker-args> </span> </div> <div class=marker> <span class="marker-name badge">livetest</span> <span class=marker-args> </span> </div> </td> </tr> <tr> <th>Fixtures</th> <td> <span class="badge fixturename"> django_test_environment </span> <span class="badge fixturename"> django_db_blocker </span> <span class="badge fixturename"> folder </span> <span class="badge fixturename"> request </span> </td> </tr> </table> <div class=repr> <pre>requests.exceptions.RetryError: HTTPSConnectionPool(host=&#39;sagex3-horsprod.covage.com&#39;, port=443): Max retries exceeded with url: /api1/x3/erp/QAL/AOBJEXT(&#39;WYXOHKSC&#39;)?representation=AOBJEXT.%24details (Caused by ResponseError(&#39;too many 502 error responses&#39;))</pre> </div> <div class=test-phases> <details class="phase setup "> <summary> <h4 class=title> <span class=phase-name>Setup</span> </h4> </summary> <div class=content> </div> </details> <details class="phase call xfailed" open> <summary> <h4 class=title> <span class="status  xfailed"></span> <span class=phase-name>Call</span> </h4> </summary> <div class=content> <div class=repr> <pre>self = &lt;requests.adapters.HTTPAdapter object at 0x7f34bbd16070&gt;
request = &lt;PreparedRequest [GET]&gt;, stream = False
timeout = Timeout(connect=None, read=None, total=None), verify = True
cert = None
proxies = OrderedDict([(&#39;no&#39;, &#39;gitlab-runner-cache-01-prd.nut.covage.com&#39;), (&#39;http&#39;, &#39;http://squid.kosc.net:3128&#39;), (&#39;https&#39;, &#39;http://squid.kosc.net:3128&#39;)])

    def send(
        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None
    ):
        &#34;&#34;&#34;Sends PreparedRequest object. Returns Response object.
    
        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.
        :param stream: (optional) Whether to stream the request content.
        :param timeout: (optional) How long to wait for the server to send
            data before giving up, as a float, or a :ref:`(connect timeout,
            read timeout) &lt;timeouts&gt;` tuple.
        :type timeout: float or tuple or urllib3 Timeout object
        :param verify: (optional) Either a boolean, in which case it controls whether
            we verify the server&#39;s TLS certificate, or a string, in which case it
            must be a path to a CA bundle to use
        :param cert: (optional) Any user-provided SSL certificate to be trusted.
        :param proxies: (optional) The proxies dictionary to apply to the request.
        :rtype: requests.Response
        &#34;&#34;&#34;
    
        try:
            conn = self.get_connection(request.url, proxies)
        except LocationValueError as e:
            raise InvalidURL(e, request=request)
    
        self.cert_verify(conn, request.url, verify, cert)
        url = self.request_url(request, proxies)
        self.add_headers(
            request,
            stream=stream,
            timeout=timeout,
            verify=verify,
            cert=cert,
            proxies=proxies,
        )
    
        chunked = not (request.body is None or &#34;Content-Length&#34; in request.headers)
    
        if isinstance(timeout, tuple):
            try:
                connect, read = timeout
                timeout = TimeoutSauce(connect=connect, read=read)
            except ValueError:
                raise ValueError(
                    f&#34;Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, &#34;
                    f&#34;or a single float to set both timeouts to the same value.&#34;
                )
        elif isinstance(timeout, TimeoutSauce):
            pass
        else:
            timeout = TimeoutSauce(connect=timeout, read=timeout)
    
        try:
            if not chunked:
&gt;               resp = conn.urlopen(
                    method=request.method,
                    url=url,
                    body=request.body,
                    headers=request.headers,
                    redirect=False,
                    assert_same_host=False,
                    preload_content=False,
                    decode_content=False,
                    retries=self.max_retries,
                    timeout=timeout,
                )

/usr/local/lib/python3.8/site-packages/requests/adapters.py:489: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connectionpool.HTTPSConnectionPool object at 0x7f34bbd16400&gt;
method = &#39;GET&#39;
url = &#34;/api1/x3/erp/QAL/AOBJEXT(&#39;WYXOHKSC&#39;)?representation=AOBJEXT.%24details&#34;
body = None
headers = {&#39;User-Agent&#39;: &#39;python-requests/2.28.1&#39;, &#39;Accept-Encoding&#39;: &#39;gzip, deflate&#39;, &#39;Accept&#39;: &#39;*/*&#39;, &#39;Connection&#39;: &#39;keep-alive&#39;, &#39;Content-Type&#39;: &#39;application/json&#39;, &#39;Authorization&#39;: &#39;Basic aW50cmFjbzpXYXNzaW1Db3ZhZ2VA&#39;}
retries = Retry(total=2, connect=None, read=None, redirect=None, status=None)
redirect = False, assert_same_host = False
timeout = Timeout(connect=None, read=None, total=None), pool_timeout = None
release_conn = False, chunked = False, body_pos = None
response_kw = {&#39;decode_content&#39;: False, &#39;preload_content&#39;: False, &#39;request_method&#39;: &#39;GET&#39;}
parsed_url = Url(scheme=None, auth=None, host=None, port=None, path=&#34;/api1/x3/erp/QAL/AOBJEXT(&#39;WYXOHKSC&#39;)&#34;, query=&#39;representation=AOBJEXT.%24details&#39;, fragment=None)
destination_scheme = None
conn = &lt;urllib3.connection.HTTPSConnection object at 0x7f34bbd53040&gt;
release_this_conn = False, http_tunnel_required = True, err = None
clean_exit = True

    def urlopen(
        self,
        method,
        url,
        body=None,
        headers=None,
        retries=None,
        redirect=True,
        assert_same_host=True,
        timeout=_Default,
        pool_timeout=None,
        release_conn=None,
        chunked=False,
        body_pos=None,
        **response_kw
    ):
        &#34;&#34;&#34;
        Get a connection from the pool and perform an HTTP request. This is the
        lowest level call for making a request, so you&#39;ll need to specify all
        the raw details.
    
        .. note::
    
           More commonly, it&#39;s appropriate to use a convenience method provided
           by :class:`.RequestMethods`, such as :meth:`request`.
    
        .. note::
    
           `release_conn` will only behave as expected if
           `preload_content=False` because we want to make
           `preload_content=False` the default behaviour someday soon without
           breaking backwards compatibility.
    
        :param method:
            HTTP request method (such as GET, POST, PUT, etc.)
    
        :param url:
            The URL to perform the request on.
    
        :param body:
            Data to send in the request body, either :class:`str`, :class:`bytes`,
            an iterable of :class:`str`/:class:`bytes`, or a file-like object.
    
        :param headers:
            Dictionary of custom headers to send, such as User-Agent,
            If-None-Match, etc. If None, pool headers are used. If provided,
            these headers completely replace any pool-specific headers.
    
        :param retries:
            Configure the number of retries to allow before raising a
            :class:`~urllib3.exceptions.MaxRetryError` exception.
    
            Pass ``None`` to retry until you receive a response. Pass a
            :class:`~urllib3.util.retry.Retry` object for fine-grained control
            over different types of retries.
            Pass an integer number to retry connection errors that many times,
            but no other types of errors. Pass zero to never retry.
    
            If ``False``, then retries are disabled and any exception is raised
            immediately. Also, instead of raising a MaxRetryError on redirects,
            the redirect response will be returned.
    
        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.
    
        :param redirect:
            If True, automatically handle redirects (status codes 301, 302,
            303, 307, 308). Each redirect counts as a retry. Disabling retries
            will disable redirect, too.
    
        :param assert_same_host:
            If ``True``, will make sure that the host of the pool requests is
            consistent else will raise HostChangedError. When ``False``, you can
            use the pool on an HTTP proxy and request foreign hosts.
    
        :param timeout:
            If specified, overrides the default timeout for this one
            request. It may be a float (in seconds) or an instance of
            :class:`urllib3.util.Timeout`.
    
        :param pool_timeout:
            If set and the pool is set to block=True, then this method will
            block for ``pool_timeout`` seconds and raise EmptyPoolError if no
            connection is available within the time period.
    
        :param release_conn:
            If False, then the urlopen call will not release the connection
            back into the pool once a response is received (but will release if
            you read the entire contents of the response such as when
            `preload_content=True`). This is useful if you&#39;re not preloading
            the response&#39;s content immediately. You will need to call
            ``r.release_conn()`` on the response ``r`` to return the connection
            back into the pool. If None, it takes the value of
            ``response_kw.get(&#39;preload_content&#39;, True)``.
    
        :param chunked:
            If True, urllib3 will send the body using chunked transfer
            encoding. Otherwise, urllib3 will send the body using the standard
            content-length form. Defaults to False.
    
        :param int body_pos:
            Position to seek to in file-like body in the event of a retry or
            redirect. Typically this won&#39;t need to be set because urllib3 will
            auto-populate the value when needed.
    
        :param \\**response_kw:
            Additional parameters are passed to
            :meth:`urllib3.response.HTTPResponse.from_httplib`
        &#34;&#34;&#34;
    
        parsed_url = parse_url(url)
        destination_scheme = parsed_url.scheme
    
        if headers is None:
            headers = self.headers
    
        if not isinstance(retries, Retry):
            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)
    
        if release_conn is None:
            release_conn = response_kw.get(&#34;preload_content&#34;, True)
    
        # Check host
        if assert_same_host and not self.is_same_host(url):
            raise HostChangedError(self, url, retries)
    
        # Ensure that the URL we&#39;re connecting to is properly encoded
        if url.startswith(&#34;/&#34;):
            url = six.ensure_str(_encode_target(url))
        else:
            url = six.ensure_str(parsed_url.url)
    
        conn = None
    
        # Track whether `conn` needs to be released before
        # returning/raising/recursing. Update this variable if necessary, and
        # leave `release_conn` constant throughout the function. That way, if
        # the function recurses, the original value of `release_conn` will be
        # passed down into the recursive call, and its value will be respected.
        #
        # See issue #651 [1] for details.
        #
        # [1] &lt;https://github.com/urllib3/urllib3/issues/651&gt;
        release_this_conn = release_conn
    
        http_tunnel_required = connection_requires_http_tunnel(
            self.proxy, self.proxy_config, destination_scheme
        )
    
        # Merge the proxy headers. Only done when not using HTTP CONNECT. We
        # have to copy the headers dict so we can safely change it without those
        # changes being reflected in anyone else&#39;s copy.
        if not http_tunnel_required:
            headers = headers.copy()
            headers.update(self.proxy_headers)
    
        # Must keep the exception bound to a separate variable or else Python 3
        # complains about UnboundLocalError.
        err = None
    
        # Keep track of whether we cleanly exited the except block. This
        # ensures we do proper cleanup in finally.
        clean_exit = False
    
        # Rewind body position, if needed. Record current position
        # for future rewinds in the event of a redirect/retry.
        body_pos = set_file_position(body, body_pos)
    
        try:
            # Request a connection from the queue.
            timeout_obj = self._get_timeout(timeout)
            conn = self._get_conn(timeout=pool_timeout)
    
            conn.timeout = timeout_obj.connect_timeout
    
            is_new_proxy_conn = self.proxy is not None and not getattr(
                conn, &#34;sock&#34;, None
            )
            if is_new_proxy_conn and http_tunnel_required:
                self._prepare_proxy(conn)
    
            # Make the request on the httplib connection object.
            httplib_response = self._make_request(
                conn,
                method,
                url,
                timeout=timeout_obj,
                body=body,
                headers=headers,
                chunked=chunked,
            )
    
            # If we&#39;re going to release the connection in ``finally:``, then
            # the response doesn&#39;t need to know about the connection. Otherwise
            # it will also try to release it and we&#39;ll have a double-release
            # mess.
            response_conn = conn if not release_conn else None
    
            # Pass method to Response for length checking
            response_kw[&#34;request_method&#34;] = method
    
            # Import httplib&#39;s response into our own wrapper object
            response = self.ResponseCls.from_httplib(
                httplib_response,
                pool=self,
                connection=response_conn,
                retries=retries,
                **response_kw
            )
    
            # Everything went great!
            clean_exit = True
    
        except EmptyPoolError:
            # Didn&#39;t get a connection from the pool, no need to clean up
            clean_exit = True
            release_this_conn = False
            raise
    
        except (
            TimeoutError,
            HTTPException,
            SocketError,
            ProtocolError,
            BaseSSLError,
            SSLError,
            CertificateError,
        ) as e:
            # Discard the connection for these exceptions. It will be
            # replaced during the next _get_conn() call.
            clean_exit = False
    
            def _is_ssl_error_message_from_http_proxy(ssl_error):
                # We&#39;re trying to detect the message &#39;WRONG_VERSION_NUMBER&#39; but
                # SSLErrors are kinda all over the place when it comes to the message,
                # so we try to cover our bases here!
                message = &#34; &#34;.join(re.split(&#34;[^a-z]&#34;, str(ssl_error).lower()))
                return (
                    &#34;wrong version number&#34; in message or &#34;unknown protocol&#34; in message
                )
    
            # Try to detect a common user error with proxies which is to
            # set an HTTP proxy to be HTTPS when it should be &#39;http://&#39;
            # (ie {&#39;http&#39;: &#39;http://proxy&#39;, &#39;https&#39;: &#39;https://proxy&#39;})
            # Instead we add a nice error message and point to a URL.
            if (
                isinstance(e, BaseSSLError)
                and self.proxy
                and _is_ssl_error_message_from_http_proxy(e)
                and conn.proxy
                and conn.proxy.scheme == &#34;https&#34;
            ):
                e = ProxyError(
                    &#34;Your proxy appears to only use HTTP and not HTTPS, &#34;
                    &#34;try changing your proxy URL to be HTTP. See: &#34;
                    &#34;https://urllib3.readthedocs.io/en/1.26.x/advanced-usage.html&#34;
                    &#34;#https-proxy-error-http-proxy&#34;,
                    SSLError(e),
                )
            elif isinstance(e, (BaseSSLError, CertificateError)):
                e = SSLError(e)
            elif isinstance(e, (SocketError, NewConnectionError)) and self.proxy:
                e = ProxyError(&#34;Cannot connect to proxy.&#34;, e)
            elif isinstance(e, (SocketError, HTTPException)):
                e = ProtocolError(&#34;Connection aborted.&#34;, e)
    
            retries = retries.increment(
                method, url, error=e, _pool=self, _stacktrace=sys.exc_info()[2]
            )
            retries.sleep()
    
            # Keep track of the error for the retry warning.
            err = e
    
        finally:
            if not clean_exit:
                # We hit some kind of exception, handled or otherwise. We need
                # to throw the connection away unless explicitly told not to.
                # Close the connection, set the variable to None, and make sure
                # we put the None back in the pool to avoid leaking it.
                conn = conn and conn.close()
                release_this_conn = True
    
            if release_this_conn:
                # Put the connection back to be reused. If the connection is
                # expired then it will be None, which will get replaced with a
                # fresh connection during _get_conn.
                self._put_conn(conn)
    
        if not conn:
            # Try again
            log.warning(
                &#34;Retrying (%r) after connection broken by &#39;%r&#39;: %s&#34;, retries, err, url
            )
            return self.urlopen(
                method,
                url,
                body,
                headers,
                retries,
                redirect,
                assert_same_host,
                timeout=timeout,
                pool_timeout=pool_timeout,
                release_conn=release_conn,
                chunked=chunked,
                body_pos=body_pos,
                **response_kw
            )
    
        # Handle redirect?
        redirect_location = redirect and response.get_redirect_location()
        if redirect_location:
            if response.status == 303:
                method = &#34;GET&#34;
    
            try:
                retries = retries.increment(method, url, response=response, _pool=self)
            except MaxRetryError:
                if retries.raise_on_redirect:
                    response.drain_conn()
                    raise
                return response
    
            response.drain_conn()
            retries.sleep_for_retry(response)
            log.debug(&#34;Redirecting %s -&gt; %s&#34;, url, redirect_location)
            return self.urlopen(
                method,
                redirect_location,
                body,
                headers,
                retries=retries,
                redirect=redirect,
                assert_same_host=assert_same_host,
                timeout=timeout,
                pool_timeout=pool_timeout,
                release_conn=release_conn,
                chunked=chunked,
                body_pos=body_pos,
                **response_kw
            )
    
        # Check if we should retry the HTTP response.
        has_retry_after = bool(response.getheader(&#34;Retry-After&#34;))
        if retries.is_retry(method, response.status, has_retry_after):
            try:
                retries = retries.increment(method, url, response=response, _pool=self)
            except MaxRetryError:
                if retries.raise_on_status:
                    response.drain_conn()
                    raise
                return response
    
            response.drain_conn()
            retries.sleep(response)
            log.debug(&#34;Retry: %s&#34;, url)
&gt;           return self.urlopen(
                method,
                url,
                body,
                headers,
                retries=retries,
                redirect=redirect,
                assert_same_host=assert_same_host,
                timeout=timeout,
                pool_timeout=pool_timeout,
                release_conn=release_conn,
                chunked=chunked,
                body_pos=body_pos,
                **response_kw
            )

/usr/local/lib/python3.8/site-packages/urllib3/connectionpool.py:878: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connectionpool.HTTPSConnectionPool object at 0x7f34bbd16400&gt;
method = &#39;GET&#39;
url = &#34;/api1/x3/erp/QAL/AOBJEXT(&#39;WYXOHKSC&#39;)?representation=AOBJEXT.%24details&#34;
body = None
headers = {&#39;User-Agent&#39;: &#39;python-requests/2.28.1&#39;, &#39;Accept-Encoding&#39;: &#39;gzip, deflate&#39;, &#39;Accept&#39;: &#39;*/*&#39;, &#39;Connection&#39;: &#39;keep-alive&#39;, &#39;Content-Type&#39;: &#39;application/json&#39;, &#39;Authorization&#39;: &#39;Basic aW50cmFjbzpXYXNzaW1Db3ZhZ2VA&#39;}
retries = Retry(total=1, connect=None, read=None, redirect=None, status=None)
redirect = False, assert_same_host = False
timeout = Timeout(connect=None, read=None, total=None), pool_timeout = None
release_conn = False, chunked = False, body_pos = None
response_kw = {&#39;decode_content&#39;: False, &#39;preload_content&#39;: False, &#39;request_method&#39;: &#39;GET&#39;}
parsed_url = Url(scheme=None, auth=None, host=None, port=None, path=&#34;/api1/x3/erp/QAL/AOBJEXT(&#39;WYXOHKSC&#39;)&#34;, query=&#39;representation=AOBJEXT.%24details&#39;, fragment=None)
destination_scheme = None
conn = &lt;urllib3.connection.HTTPSConnection object at 0x7f34bbd53040&gt;
release_this_conn = False, http_tunnel_required = True, err = None
clean_exit = True

    def urlopen(
        self,
        method,
        url,
        body=None,
        headers=None,
        retries=None,
        redirect=True,
        assert_same_host=True,
        timeout=_Default,
        pool_timeout=None,
        release_conn=None,
        chunked=False,
        body_pos=None,
        **response_kw
    ):
        &#34;&#34;&#34;
        Get a connection from the pool and perform an HTTP request. This is the
        lowest level call for making a request, so you&#39;ll need to specify all
        the raw details.
    
        .. note::
    
           More commonly, it&#39;s appropriate to use a convenience method provided
           by :class:`.RequestMethods`, such as :meth:`request`.
    
        .. note::
    
           `release_conn` will only behave as expected if
           `preload_content=False` because we want to make
           `preload_content=False` the default behaviour someday soon without
           breaking backwards compatibility.
    
        :param method:
            HTTP request method (such as GET, POST, PUT, etc.)
    
        :param url:
            The URL to perform the request on.
    
        :param body:
            Data to send in the request body, either :class:`str`, :class:`bytes`,
            an iterable of :class:`str`/:class:`bytes`, or a file-like object.
    
        :param headers:
            Dictionary of custom headers to send, such as User-Agent,
            If-None-Match, etc. If None, pool headers are used. If provided,
            these headers completely replace any pool-specific headers.
    
        :param retries:
            Configure the number of retries to allow before raising a
            :class:`~urllib3.exceptions.MaxRetryError` exception.
    
            Pass ``None`` to retry until you receive a response. Pass a
            :class:`~urllib3.util.retry.Retry` object for fine-grained control
            over different types of retries.
            Pass an integer number to retry connection errors that many times,
            but no other types of errors. Pass zero to never retry.
    
            If ``False``, then retries are disabled and any exception is raised
            immediately. Also, instead of raising a MaxRetryError on redirects,
            the redirect response will be returned.
    
        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.
    
        :param redirect:
            If True, automatically handle redirects (status codes 301, 302,
            303, 307, 308). Each redirect counts as a retry. Disabling retries
            will disable redirect, too.
    
        :param assert_same_host:
            If ``True``, will make sure that the host of the pool requests is
            consistent else will raise HostChangedError. When ``False``, you can
            use the pool on an HTTP proxy and request foreign hosts.
    
        :param timeout:
            If specified, overrides the default timeout for this one
            request. It may be a float (in seconds) or an instance of
            :class:`urllib3.util.Timeout`.
    
        :param pool_timeout:
            If set and the pool is set to block=True, then this method will
            block for ``pool_timeout`` seconds and raise EmptyPoolError if no
            connection is available within the time period.
    
        :param release_conn:
            If False, then the urlopen call will not release the connection
            back into the pool once a response is received (but will release if
            you read the entire contents of the response such as when
            `preload_content=True`). This is useful if you&#39;re not preloading
            the response&#39;s content immediately. You will need to call
            ``r.release_conn()`` on the response ``r`` to return the connection
            back into the pool. If None, it takes the value of
            ``response_kw.get(&#39;preload_content&#39;, True)``.
    
        :param chunked:
            If True, urllib3 will send the body using chunked transfer
            encoding. Otherwise, urllib3 will send the body using the standard
            content-length form. Defaults to False.
    
        :param int body_pos:
            Position to seek to in file-like body in the event of a retry or
            redirect. Typically this won&#39;t need to be set because urllib3 will
            auto-populate the value when needed.
    
        :param \\**response_kw:
            Additional parameters are passed to
            :meth:`urllib3.response.HTTPResponse.from_httplib`
        &#34;&#34;&#34;
    
        parsed_url = parse_url(url)
        destination_scheme = parsed_url.scheme
    
        if headers is None:
            headers = self.headers
    
        if not isinstance(retries, Retry):
            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)
    
        if release_conn is None:
            release_conn = response_kw.get(&#34;preload_content&#34;, True)
    
        # Check host
        if assert_same_host and not self.is_same_host(url):
            raise HostChangedError(self, url, retries)
    
        # Ensure that the URL we&#39;re connecting to is properly encoded
        if url.startswith(&#34;/&#34;):
            url = six.ensure_str(_encode_target(url))
        else:
            url = six.ensure_str(parsed_url.url)
    
        conn = None
    
        # Track whether `conn` needs to be released before
        # returning/raising/recursing. Update this variable if necessary, and
        # leave `release_conn` constant throughout the function. That way, if
        # the function recurses, the original value of `release_conn` will be
        # passed down into the recursive call, and its value will be respected.
        #
        # See issue #651 [1] for details.
        #
        # [1] &lt;https://github.com/urllib3/urllib3/issues/651&gt;
        release_this_conn = release_conn
    
        http_tunnel_required = connection_requires_http_tunnel(
            self.proxy, self.proxy_config, destination_scheme
        )
    
        # Merge the proxy headers. Only done when not using HTTP CONNECT. We
        # have to copy the headers dict so we can safely change it without those
        # changes being reflected in anyone else&#39;s copy.
        if not http_tunnel_required:
            headers = headers.copy()
            headers.update(self.proxy_headers)
    
        # Must keep the exception bound to a separate variable or else Python 3
        # complains about UnboundLocalError.
        err = None
    
        # Keep track of whether we cleanly exited the except block. This
        # ensures we do proper cleanup in finally.
        clean_exit = False
    
        # Rewind body position, if needed. Record current position
        # for future rewinds in the event of a redirect/retry.
        body_pos = set_file_position(body, body_pos)
    
        try:
            # Request a connection from the queue.
            timeout_obj = self._get_timeout(timeout)
            conn = self._get_conn(timeout=pool_timeout)
    
            conn.timeout = timeout_obj.connect_timeout
    
            is_new_proxy_conn = self.proxy is not None and not getattr(
                conn, &#34;sock&#34;, None
            )
            if is_new_proxy_conn and http_tunnel_required:
                self._prepare_proxy(conn)
    
            # Make the request on the httplib connection object.
            httplib_response = self._make_request(
                conn,
                method,
                url,
                timeout=timeout_obj,
                body=body,
                headers=headers,
                chunked=chunked,
            )
    
            # If we&#39;re going to release the connection in ``finally:``, then
            # the response doesn&#39;t need to know about the connection. Otherwise
            # it will also try to release it and we&#39;ll have a double-release
            # mess.
            response_conn = conn if not release_conn else None
    
            # Pass method to Response for length checking
            response_kw[&#34;request_method&#34;] = method
    
            # Import httplib&#39;s response into our own wrapper object
            response = self.ResponseCls.from_httplib(
                httplib_response,
                pool=self,
                connection=response_conn,
                retries=retries,
                **response_kw
            )
    
            # Everything went great!
            clean_exit = True
    
        except EmptyPoolError:
            # Didn&#39;t get a connection from the pool, no need to clean up
            clean_exit = True
            release_this_conn = False
            raise
    
        except (
            TimeoutError,
            HTTPException,
            SocketError,
            ProtocolError,
            BaseSSLError,
            SSLError,
            CertificateError,
        ) as e:
            # Discard the connection for these exceptions. It will be
            # replaced during the next _get_conn() call.
            clean_exit = False
    
            def _is_ssl_error_message_from_http_proxy(ssl_error):
                # We&#39;re trying to detect the message &#39;WRONG_VERSION_NUMBER&#39; but
                # SSLErrors are kinda all over the place when it comes to the message,
                # so we try to cover our bases here!
                message = &#34; &#34;.join(re.split(&#34;[^a-z]&#34;, str(ssl_error).lower()))
                return (
                    &#34;wrong version number&#34; in message or &#34;unknown protocol&#34; in message
                )
    
            # Try to detect a common user error with proxies which is to
            # set an HTTP proxy to be HTTPS when it should be &#39;http://&#39;
            # (ie {&#39;http&#39;: &#39;http://proxy&#39;, &#39;https&#39;: &#39;https://proxy&#39;})
            # Instead we add a nice error message and point to a URL.
            if (
                isinstance(e, BaseSSLError)
                and self.proxy
                and _is_ssl_error_message_from_http_proxy(e)
                and conn.proxy
                and conn.proxy.scheme == &#34;https&#34;
            ):
                e = ProxyError(
                    &#34;Your proxy appears to only use HTTP and not HTTPS, &#34;
                    &#34;try changing your proxy URL to be HTTP. See: &#34;
                    &#34;https://urllib3.readthedocs.io/en/1.26.x/advanced-usage.html&#34;
                    &#34;#https-proxy-error-http-proxy&#34;,
                    SSLError(e),
                )
            elif isinstance(e, (BaseSSLError, CertificateError)):
                e = SSLError(e)
            elif isinstance(e, (SocketError, NewConnectionError)) and self.proxy:
                e = ProxyError(&#34;Cannot connect to proxy.&#34;, e)
            elif isinstance(e, (SocketError, HTTPException)):
                e = ProtocolError(&#34;Connection aborted.&#34;, e)
    
            retries = retries.increment(
                method, url, error=e, _pool=self, _stacktrace=sys.exc_info()[2]
            )
            retries.sleep()
    
            # Keep track of the error for the retry warning.
            err = e
    
        finally:
            if not clean_exit:
                # We hit some kind of exception, handled or otherwise. We need
                # to throw the connection away unless explicitly told not to.
                # Close the connection, set the variable to None, and make sure
                # we put the None back in the pool to avoid leaking it.
                conn = conn and conn.close()
                release_this_conn = True
    
            if release_this_conn:
                # Put the connection back to be reused. If the connection is
                # expired then it will be None, which will get replaced with a
                # fresh connection during _get_conn.
                self._put_conn(conn)
    
        if not conn:
            # Try again
            log.warning(
                &#34;Retrying (%r) after connection broken by &#39;%r&#39;: %s&#34;, retries, err, url
            )
            return self.urlopen(
                method,
                url,
                body,
                headers,
                retries,
                redirect,
                assert_same_host,
                timeout=timeout,
                pool_timeout=pool_timeout,
                release_conn=release_conn,
                chunked=chunked,
                body_pos=body_pos,
                **response_kw
            )
    
        # Handle redirect?
        redirect_location = redirect and response.get_redirect_location()
        if redirect_location:
            if response.status == 303:
                method = &#34;GET&#34;
    
            try:
                retries = retries.increment(method, url, response=response, _pool=self)
            except MaxRetryError:
                if retries.raise_on_redirect:
                    response.drain_conn()
                    raise
                return response
    
            response.drain_conn()
            retries.sleep_for_retry(response)
            log.debug(&#34;Redirecting %s -&gt; %s&#34;, url, redirect_location)
            return self.urlopen(
                method,
                redirect_location,
                body,
                headers,
                retries=retries,
                redirect=redirect,
                assert_same_host=assert_same_host,
                timeout=timeout,
                pool_timeout=pool_timeout,
                release_conn=release_conn,
                chunked=chunked,
                body_pos=body_pos,
                **response_kw
            )
    
        # Check if we should retry the HTTP response.
        has_retry_after = bool(response.getheader(&#34;Retry-After&#34;))
        if retries.is_retry(method, response.status, has_retry_after):
            try:
                retries = retries.increment(method, url, response=response, _pool=self)
            except MaxRetryError:
                if retries.raise_on_status:
                    response.drain_conn()
                    raise
                return response
    
            response.drain_conn()
            retries.sleep(response)
            log.debug(&#34;Retry: %s&#34;, url)
&gt;           return self.urlopen(
                method,
                url,
                body,
                headers,
                retries=retries,
                redirect=redirect,
                assert_same_host=assert_same_host,
                timeout=timeout,
                pool_timeout=pool_timeout,
                release_conn=release_conn,
                chunked=chunked,
                body_pos=body_pos,
                **response_kw
            )

/usr/local/lib/python3.8/site-packages/urllib3/connectionpool.py:878: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connectionpool.HTTPSConnectionPool object at 0x7f34bbd16400&gt;
method = &#39;GET&#39;
url = &#34;/api1/x3/erp/QAL/AOBJEXT(&#39;WYXOHKSC&#39;)?representation=AOBJEXT.%24details&#34;
body = None
headers = {&#39;User-Agent&#39;: &#39;python-requests/2.28.1&#39;, &#39;Accept-Encoding&#39;: &#39;gzip, deflate&#39;, &#39;Accept&#39;: &#39;*/*&#39;, &#39;Connection&#39;: &#39;keep-alive&#39;, &#39;Content-Type&#39;: &#39;application/json&#39;, &#39;Authorization&#39;: &#39;Basic aW50cmFjbzpXYXNzaW1Db3ZhZ2VA&#39;}
retries = Retry(total=0, connect=None, read=None, redirect=None, status=None)
redirect = False, assert_same_host = False
timeout = Timeout(connect=None, read=None, total=None), pool_timeout = None
release_conn = False, chunked = False, body_pos = None
response_kw = {&#39;decode_content&#39;: False, &#39;preload_content&#39;: False, &#39;request_method&#39;: &#39;GET&#39;}
parsed_url = Url(scheme=None, auth=None, host=None, port=None, path=&#34;/api1/x3/erp/QAL/AOBJEXT(&#39;WYXOHKSC&#39;)&#34;, query=&#39;representation=AOBJEXT.%24details&#39;, fragment=None)
destination_scheme = None
conn = &lt;urllib3.connection.HTTPSConnection object at 0x7f34bbd53040&gt;
release_this_conn = False, http_tunnel_required = True, err = None
clean_exit = True

    def urlopen(
        self,
        method,
        url,
        body=None,
        headers=None,
        retries=None,
        redirect=True,
        assert_same_host=True,
        timeout=_Default,
        pool_timeout=None,
        release_conn=None,
        chunked=False,
        body_pos=None,
        **response_kw
    ):
        &#34;&#34;&#34;
        Get a connection from the pool and perform an HTTP request. This is the
        lowest level call for making a request, so you&#39;ll need to specify all
        the raw details.
    
        .. note::
    
           More commonly, it&#39;s appropriate to use a convenience method provided
           by :class:`.RequestMethods`, such as :meth:`request`.
    
        .. note::
    
           `release_conn` will only behave as expected if
           `preload_content=False` because we want to make
           `preload_content=False` the default behaviour someday soon without
           breaking backwards compatibility.
    
        :param method:
            HTTP request method (such as GET, POST, PUT, etc.)
    
        :param url:
            The URL to perform the request on.
    
        :param body:
            Data to send in the request body, either :class:`str`, :class:`bytes`,
            an iterable of :class:`str`/:class:`bytes`, or a file-like object.
    
        :param headers:
            Dictionary of custom headers to send, such as User-Agent,
            If-None-Match, etc. If None, pool headers are used. If provided,
            these headers completely replace any pool-specific headers.
    
        :param retries:
            Configure the number of retries to allow before raising a
            :class:`~urllib3.exceptions.MaxRetryError` exception.
    
            Pass ``None`` to retry until you receive a response. Pass a
            :class:`~urllib3.util.retry.Retry` object for fine-grained control
            over different types of retries.
            Pass an integer number to retry connection errors that many times,
            but no other types of errors. Pass zero to never retry.
    
            If ``False``, then retries are disabled and any exception is raised
            immediately. Also, instead of raising a MaxRetryError on redirects,
            the redirect response will be returned.
    
        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.
    
        :param redirect:
            If True, automatically handle redirects (status codes 301, 302,
            303, 307, 308). Each redirect counts as a retry. Disabling retries
            will disable redirect, too.
    
        :param assert_same_host:
            If ``True``, will make sure that the host of the pool requests is
            consistent else will raise HostChangedError. When ``False``, you can
            use the pool on an HTTP proxy and request foreign hosts.
    
        :param timeout:
            If specified, overrides the default timeout for this one
            request. It may be a float (in seconds) or an instance of
            :class:`urllib3.util.Timeout`.
    
        :param pool_timeout:
            If set and the pool is set to block=True, then this method will
            block for ``pool_timeout`` seconds and raise EmptyPoolError if no
            connection is available within the time period.
    
        :param release_conn:
            If False, then the urlopen call will not release the connection
            back into the pool once a response is received (but will release if
            you read the entire contents of the response such as when
            `preload_content=True`). This is useful if you&#39;re not preloading
            the response&#39;s content immediately. You will need to call
            ``r.release_conn()`` on the response ``r`` to return the connection
            back into the pool. If None, it takes the value of
            ``response_kw.get(&#39;preload_content&#39;, True)``.
    
        :param chunked:
            If True, urllib3 will send the body using chunked transfer
            encoding. Otherwise, urllib3 will send the body using the standard
            content-length form. Defaults to False.
    
        :param int body_pos:
            Position to seek to in file-like body in the event of a retry or
            redirect. Typically this won&#39;t need to be set because urllib3 will
            auto-populate the value when needed.
    
        :param \\**response_kw:
            Additional parameters are passed to
            :meth:`urllib3.response.HTTPResponse.from_httplib`
        &#34;&#34;&#34;
    
        parsed_url = parse_url(url)
        destination_scheme = parsed_url.scheme
    
        if headers is None:
            headers = self.headers
    
        if not isinstance(retries, Retry):
            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)
    
        if release_conn is None:
            release_conn = response_kw.get(&#34;preload_content&#34;, True)
    
        # Check host
        if assert_same_host and not self.is_same_host(url):
            raise HostChangedError(self, url, retries)
    
        # Ensure that the URL we&#39;re connecting to is properly encoded
        if url.startswith(&#34;/&#34;):
            url = six.ensure_str(_encode_target(url))
        else:
            url = six.ensure_str(parsed_url.url)
    
        conn = None
    
        # Track whether `conn` needs to be released before
        # returning/raising/recursing. Update this variable if necessary, and
        # leave `release_conn` constant throughout the function. That way, if
        # the function recurses, the original value of `release_conn` will be
        # passed down into the recursive call, and its value will be respected.
        #
        # See issue #651 [1] for details.
        #
        # [1] &lt;https://github.com/urllib3/urllib3/issues/651&gt;
        release_this_conn = release_conn
    
        http_tunnel_required = connection_requires_http_tunnel(
            self.proxy, self.proxy_config, destination_scheme
        )
    
        # Merge the proxy headers. Only done when not using HTTP CONNECT. We
        # have to copy the headers dict so we can safely change it without those
        # changes being reflected in anyone else&#39;s copy.
        if not http_tunnel_required:
            headers = headers.copy()
            headers.update(self.proxy_headers)
    
        # Must keep the exception bound to a separate variable or else Python 3
        # complains about UnboundLocalError.
        err = None
    
        # Keep track of whether we cleanly exited the except block. This
        # ensures we do proper cleanup in finally.
        clean_exit = False
    
        # Rewind body position, if needed. Record current position
        # for future rewinds in the event of a redirect/retry.
        body_pos = set_file_position(body, body_pos)
    
        try:
            # Request a connection from the queue.
            timeout_obj = self._get_timeout(timeout)
            conn = self._get_conn(timeout=pool_timeout)
    
            conn.timeout = timeout_obj.connect_timeout
    
            is_new_proxy_conn = self.proxy is not None and not getattr(
                conn, &#34;sock&#34;, None
            )
            if is_new_proxy_conn and http_tunnel_required:
                self._prepare_proxy(conn)
    
            # Make the request on the httplib connection object.
            httplib_response = self._make_request(
                conn,
                method,
                url,
                timeout=timeout_obj,
                body=body,
                headers=headers,
                chunked=chunked,
            )
    
            # If we&#39;re going to release the connection in ``finally:``, then
            # the response doesn&#39;t need to know about the connection. Otherwise
            # it will also try to release it and we&#39;ll have a double-release
            # mess.
            response_conn = conn if not release_conn else None
    
            # Pass method to Response for length checking
            response_kw[&#34;request_method&#34;] = method
    
            # Import httplib&#39;s response into our own wrapper object
            response = self.ResponseCls.from_httplib(
                httplib_response,
                pool=self,
                connection=response_conn,
                retries=retries,
                **response_kw
            )
    
            # Everything went great!
            clean_exit = True
    
        except EmptyPoolError:
            # Didn&#39;t get a connection from the pool, no need to clean up
            clean_exit = True
            release_this_conn = False
            raise
    
        except (
            TimeoutError,
            HTTPException,
            SocketError,
            ProtocolError,
            BaseSSLError,
            SSLError,
            CertificateError,
        ) as e:
            # Discard the connection for these exceptions. It will be
            # replaced during the next _get_conn() call.
            clean_exit = False
    
            def _is_ssl_error_message_from_http_proxy(ssl_error):
                # We&#39;re trying to detect the message &#39;WRONG_VERSION_NUMBER&#39; but
                # SSLErrors are kinda all over the place when it comes to the message,
                # so we try to cover our bases here!
                message = &#34; &#34;.join(re.split(&#34;[^a-z]&#34;, str(ssl_error).lower()))
                return (
                    &#34;wrong version number&#34; in message or &#34;unknown protocol&#34; in message
                )
    
            # Try to detect a common user error with proxies which is to
            # set an HTTP proxy to be HTTPS when it should be &#39;http://&#39;
            # (ie {&#39;http&#39;: &#39;http://proxy&#39;, &#39;https&#39;: &#39;https://proxy&#39;})
            # Instead we add a nice error message and point to a URL.
            if (
                isinstance(e, BaseSSLError)
                and self.proxy
                and _is_ssl_error_message_from_http_proxy(e)
                and conn.proxy
                and conn.proxy.scheme == &#34;https&#34;
            ):
                e = ProxyError(
                    &#34;Your proxy appears to only use HTTP and not HTTPS, &#34;
                    &#34;try changing your proxy URL to be HTTP. See: &#34;
                    &#34;https://urllib3.readthedocs.io/en/1.26.x/advanced-usage.html&#34;
                    &#34;#https-proxy-error-http-proxy&#34;,
                    SSLError(e),
                )
            elif isinstance(e, (BaseSSLError, CertificateError)):
                e = SSLError(e)
            elif isinstance(e, (SocketError, NewConnectionError)) and self.proxy:
                e = ProxyError(&#34;Cannot connect to proxy.&#34;, e)
            elif isinstance(e, (SocketError, HTTPException)):
                e = ProtocolError(&#34;Connection aborted.&#34;, e)
    
            retries = retries.increment(
                method, url, error=e, _pool=self, _stacktrace=sys.exc_info()[2]
            )
            retries.sleep()
    
            # Keep track of the error for the retry warning.
            err = e
    
        finally:
            if not clean_exit:
                # We hit some kind of exception, handled or otherwise. We need
                # to throw the connection away unless explicitly told not to.
                # Close the connection, set the variable to None, and make sure
                # we put the None back in the pool to avoid leaking it.
                conn = conn and conn.close()
                release_this_conn = True
    
            if release_this_conn:
                # Put the connection back to be reused. If the connection is
                # expired then it will be None, which will get replaced with a
                # fresh connection during _get_conn.
                self._put_conn(conn)
    
        if not conn:
            # Try again
            log.warning(
                &#34;Retrying (%r) after connection broken by &#39;%r&#39;: %s&#34;, retries, err, url
            )
            return self.urlopen(
                method,
                url,
                body,
                headers,
                retries,
                redirect,
                assert_same_host,
                timeout=timeout,
                pool_timeout=pool_timeout,
                release_conn=release_conn,
                chunked=chunked,
                body_pos=body_pos,
                **response_kw
            )
    
        # Handle redirect?
        redirect_location = redirect and response.get_redirect_location()
        if redirect_location:
            if response.status == 303:
                method = &#34;GET&#34;
    
            try:
                retries = retries.increment(method, url, response=response, _pool=self)
            except MaxRetryError:
                if retries.raise_on_redirect:
                    response.drain_conn()
                    raise
                return response
    
            response.drain_conn()
            retries.sleep_for_retry(response)
            log.debug(&#34;Redirecting %s -&gt; %s&#34;, url, redirect_location)
            return self.urlopen(
                method,
                redirect_location,
                body,
                headers,
                retries=retries,
                redirect=redirect,
                assert_same_host=assert_same_host,
                timeout=timeout,
                pool_timeout=pool_timeout,
                release_conn=release_conn,
                chunked=chunked,
                body_pos=body_pos,
                **response_kw
            )
    
        # Check if we should retry the HTTP response.
        has_retry_after = bool(response.getheader(&#34;Retry-After&#34;))
        if retries.is_retry(method, response.status, has_retry_after):
            try:
                retries = retries.increment(method, url, response=response, _pool=self)
            except MaxRetryError:
                if retries.raise_on_status:
                    response.drain_conn()
                    raise
                return response
    
            response.drain_conn()
            retries.sleep(response)
            log.debug(&#34;Retry: %s&#34;, url)
&gt;           return self.urlopen(
                method,
                url,
                body,
                headers,
                retries=retries,
                redirect=redirect,
                assert_same_host=assert_same_host,
                timeout=timeout,
                pool_timeout=pool_timeout,
                release_conn=release_conn,
                chunked=chunked,
                body_pos=body_pos,
                **response_kw
            )

/usr/local/lib/python3.8/site-packages/urllib3/connectionpool.py:878: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connectionpool.HTTPSConnectionPool object at 0x7f34bbd16400&gt;
method = &#39;GET&#39;
url = &#34;/api1/x3/erp/QAL/AOBJEXT(&#39;WYXOHKSC&#39;)?representation=AOBJEXT.%24details&#34;
body = None
headers = {&#39;User-Agent&#39;: &#39;python-requests/2.28.1&#39;, &#39;Accept-Encoding&#39;: &#39;gzip, deflate&#39;, &#39;Accept&#39;: &#39;*/*&#39;, &#39;Connection&#39;: &#39;keep-alive&#39;, &#39;Content-Type&#39;: &#39;application/json&#39;, &#39;Authorization&#39;: &#39;Basic aW50cmFjbzpXYXNzaW1Db3ZhZ2VA&#39;}
retries = Retry(total=0, connect=None, read=None, redirect=None, status=None)
redirect = False, assert_same_host = False
timeout = Timeout(connect=None, read=None, total=None), pool_timeout = None
release_conn = False, chunked = False, body_pos = None
response_kw = {&#39;decode_content&#39;: False, &#39;preload_content&#39;: False, &#39;request_method&#39;: &#39;GET&#39;}
parsed_url = Url(scheme=None, auth=None, host=None, port=None, path=&#34;/api1/x3/erp/QAL/AOBJEXT(&#39;WYXOHKSC&#39;)&#34;, query=&#39;representation=AOBJEXT.%24details&#39;, fragment=None)
destination_scheme = None
conn = &lt;urllib3.connection.HTTPSConnection object at 0x7f34bbd53040&gt;
release_this_conn = False, http_tunnel_required = True, err = None
clean_exit = True

    def urlopen(
        self,
        method,
        url,
        body=None,
        headers=None,
        retries=None,
        redirect=True,
        assert_same_host=True,
        timeout=_Default,
        pool_timeout=None,
        release_conn=None,
        chunked=False,
        body_pos=None,
        **response_kw
    ):
        &#34;&#34;&#34;
        Get a connection from the pool and perform an HTTP request. This is the
        lowest level call for making a request, so you&#39;ll need to specify all
        the raw details.
    
        .. note::
    
           More commonly, it&#39;s appropriate to use a convenience method provided
           by :class:`.RequestMethods`, such as :meth:`request`.
    
        .. note::
    
           `release_conn` will only behave as expected if
           `preload_content=False` because we want to make
           `preload_content=False` the default behaviour someday soon without
           breaking backwards compatibility.
    
        :param method:
            HTTP request method (such as GET, POST, PUT, etc.)
    
        :param url:
            The URL to perform the request on.
    
        :param body:
            Data to send in the request body, either :class:`str`, :class:`bytes`,
            an iterable of :class:`str`/:class:`bytes`, or a file-like object.
    
        :param headers:
            Dictionary of custom headers to send, such as User-Agent,
            If-None-Match, etc. If None, pool headers are used. If provided,
            these headers completely replace any pool-specific headers.
    
        :param retries:
            Configure the number of retries to allow before raising a
            :class:`~urllib3.exceptions.MaxRetryError` exception.
    
            Pass ``None`` to retry until you receive a response. Pass a
            :class:`~urllib3.util.retry.Retry` object for fine-grained control
            over different types of retries.
            Pass an integer number to retry connection errors that many times,
            but no other types of errors. Pass zero to never retry.
    
            If ``False``, then retries are disabled and any exception is raised
            immediately. Also, instead of raising a MaxRetryError on redirects,
            the redirect response will be returned.
    
        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.
    
        :param redirect:
            If True, automatically handle redirects (status codes 301, 302,
            303, 307, 308). Each redirect counts as a retry. Disabling retries
            will disable redirect, too.
    
        :param assert_same_host:
            If ``True``, will make sure that the host of the pool requests is
            consistent else will raise HostChangedError. When ``False``, you can
            use the pool on an HTTP proxy and request foreign hosts.
    
        :param timeout:
            If specified, overrides the default timeout for this one
            request. It may be a float (in seconds) or an instance of
            :class:`urllib3.util.Timeout`.
    
        :param pool_timeout:
            If set and the pool is set to block=True, then this method will
            block for ``pool_timeout`` seconds and raise EmptyPoolError if no
            connection is available within the time period.
    
        :param release_conn:
            If False, then the urlopen call will not release the connection
            back into the pool once a response is received (but will release if
            you read the entire contents of the response such as when
            `preload_content=True`). This is useful if you&#39;re not preloading
            the response&#39;s content immediately. You will need to call
            ``r.release_conn()`` on the response ``r`` to return the connection
            back into the pool. If None, it takes the value of
            ``response_kw.get(&#39;preload_content&#39;, True)``.
    
        :param chunked:
            If True, urllib3 will send the body using chunked transfer
            encoding. Otherwise, urllib3 will send the body using the standard
            content-length form. Defaults to False.
    
        :param int body_pos:
            Position to seek to in file-like body in the event of a retry or
            redirect. Typically this won&#39;t need to be set because urllib3 will
            auto-populate the value when needed.
    
        :param \\**response_kw:
            Additional parameters are passed to
            :meth:`urllib3.response.HTTPResponse.from_httplib`
        &#34;&#34;&#34;
    
        parsed_url = parse_url(url)
        destination_scheme = parsed_url.scheme
    
        if headers is None:
            headers = self.headers
    
        if not isinstance(retries, Retry):
            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)
    
        if release_conn is None:
            release_conn = response_kw.get(&#34;preload_content&#34;, True)
    
        # Check host
        if assert_same_host and not self.is_same_host(url):
            raise HostChangedError(self, url, retries)
    
        # Ensure that the URL we&#39;re connecting to is properly encoded
        if url.startswith(&#34;/&#34;):
            url = six.ensure_str(_encode_target(url))
        else:
            url = six.ensure_str(parsed_url.url)
    
        conn = None
    
        # Track whether `conn` needs to be released before
        # returning/raising/recursing. Update this variable if necessary, and
        # leave `release_conn` constant throughout the function. That way, if
        # the function recurses, the original value of `release_conn` will be
        # passed down into the recursive call, and its value will be respected.
        #
        # See issue #651 [1] for details.
        #
        # [1] &lt;https://github.com/urllib3/urllib3/issues/651&gt;
        release_this_conn = release_conn
    
        http_tunnel_required = connection_requires_http_tunnel(
            self.proxy, self.proxy_config, destination_scheme
        )
    
        # Merge the proxy headers. Only done when not using HTTP CONNECT. We
        # have to copy the headers dict so we can safely change it without those
        # changes being reflected in anyone else&#39;s copy.
        if not http_tunnel_required:
            headers = headers.copy()
            headers.update(self.proxy_headers)
    
        # Must keep the exception bound to a separate variable or else Python 3
        # complains about UnboundLocalError.
        err = None
    
        # Keep track of whether we cleanly exited the except block. This
        # ensures we do proper cleanup in finally.
        clean_exit = False
    
        # Rewind body position, if needed. Record current position
        # for future rewinds in the event of a redirect/retry.
        body_pos = set_file_position(body, body_pos)
    
        try:
            # Request a connection from the queue.
            timeout_obj = self._get_timeout(timeout)
            conn = self._get_conn(timeout=pool_timeout)
    
            conn.timeout = timeout_obj.connect_timeout
    
            is_new_proxy_conn = self.proxy is not None and not getattr(
                conn, &#34;sock&#34;, None
            )
            if is_new_proxy_conn and http_tunnel_required:
                self._prepare_proxy(conn)
    
            # Make the request on the httplib connection object.
            httplib_response = self._make_request(
                conn,
                method,
                url,
                timeout=timeout_obj,
                body=body,
                headers=headers,
                chunked=chunked,
            )
    
            # If we&#39;re going to release the connection in ``finally:``, then
            # the response doesn&#39;t need to know about the connection. Otherwise
            # it will also try to release it and we&#39;ll have a double-release
            # mess.
            response_conn = conn if not release_conn else None
    
            # Pass method to Response for length checking
            response_kw[&#34;request_method&#34;] = method
    
            # Import httplib&#39;s response into our own wrapper object
            response = self.ResponseCls.from_httplib(
                httplib_response,
                pool=self,
                connection=response_conn,
                retries=retries,
                **response_kw
            )
    
            # Everything went great!
            clean_exit = True
    
        except EmptyPoolError:
            # Didn&#39;t get a connection from the pool, no need to clean up
            clean_exit = True
            release_this_conn = False
            raise
    
        except (
            TimeoutError,
            HTTPException,
            SocketError,
            ProtocolError,
            BaseSSLError,
            SSLError,
            CertificateError,
        ) as e:
            # Discard the connection for these exceptions. It will be
            # replaced during the next _get_conn() call.
            clean_exit = False
    
            def _is_ssl_error_message_from_http_proxy(ssl_error):
                # We&#39;re trying to detect the message &#39;WRONG_VERSION_NUMBER&#39; but
                # SSLErrors are kinda all over the place when it comes to the message,
                # so we try to cover our bases here!
                message = &#34; &#34;.join(re.split(&#34;[^a-z]&#34;, str(ssl_error).lower()))
                return (
                    &#34;wrong version number&#34; in message or &#34;unknown protocol&#34; in message
                )
    
            # Try to detect a common user error with proxies which is to
            # set an HTTP proxy to be HTTPS when it should be &#39;http://&#39;
            # (ie {&#39;http&#39;: &#39;http://proxy&#39;, &#39;https&#39;: &#39;https://proxy&#39;})
            # Instead we add a nice error message and point to a URL.
            if (
                isinstance(e, BaseSSLError)
                and self.proxy
                and _is_ssl_error_message_from_http_proxy(e)
                and conn.proxy
                and conn.proxy.scheme == &#34;https&#34;
            ):
                e = ProxyError(
                    &#34;Your proxy appears to only use HTTP and not HTTPS, &#34;
                    &#34;try changing your proxy URL to be HTTP. See: &#34;
                    &#34;https://urllib3.readthedocs.io/en/1.26.x/advanced-usage.html&#34;
                    &#34;#https-proxy-error-http-proxy&#34;,
                    SSLError(e),
                )
            elif isinstance(e, (BaseSSLError, CertificateError)):
                e = SSLError(e)
            elif isinstance(e, (SocketError, NewConnectionError)) and self.proxy:
                e = ProxyError(&#34;Cannot connect to proxy.&#34;, e)
            elif isinstance(e, (SocketError, HTTPException)):
                e = ProtocolError(&#34;Connection aborted.&#34;, e)
    
            retries = retries.increment(
                method, url, error=e, _pool=self, _stacktrace=sys.exc_info()[2]
            )
            retries.sleep()
    
            # Keep track of the error for the retry warning.
            err = e
    
        finally:
            if not clean_exit:
                # We hit some kind of exception, handled or otherwise. We need
                # to throw the connection away unless explicitly told not to.
                # Close the connection, set the variable to None, and make sure
                # we put the None back in the pool to avoid leaking it.
                conn = conn and conn.close()
                release_this_conn = True
    
            if release_this_conn:
                # Put the connection back to be reused. If the connection is
                # expired then it will be None, which will get replaced with a
                # fresh connection during _get_conn.
                self._put_conn(conn)
    
        if not conn:
            # Try again
            log.warning(
                &#34;Retrying (%r) after connection broken by &#39;%r&#39;: %s&#34;, retries, err, url
            )
            return self.urlopen(
                method,
                url,
                body,
                headers,
                retries,
                redirect,
                assert_same_host,
                timeout=timeout,
                pool_timeout=pool_timeout,
                release_conn=release_conn,
                chunked=chunked,
                body_pos=body_pos,
                **response_kw
            )
    
        # Handle redirect?
        redirect_location = redirect and response.get_redirect_location()
        if redirect_location:
            if response.status == 303:
                method = &#34;GET&#34;
    
            try:
                retries = retries.increment(method, url, response=response, _pool=self)
            except MaxRetryError:
                if retries.raise_on_redirect:
                    response.drain_conn()
                    raise
                return response
    
            response.drain_conn()
            retries.sleep_for_retry(response)
            log.debug(&#34;Redirecting %s -&gt; %s&#34;, url, redirect_location)
            return self.urlopen(
                method,
                redirect_location,
                body,
                headers,
                retries=retries,
                redirect=redirect,
                assert_same_host=assert_same_host,
                timeout=timeout,
                pool_timeout=pool_timeout,
                release_conn=release_conn,
                chunked=chunked,
                body_pos=body_pos,
                **response_kw
            )
    
        # Check if we should retry the HTTP response.
        has_retry_after = bool(response.getheader(&#34;Retry-After&#34;))
        if retries.is_retry(method, response.status, has_retry_after):
            try:
&gt;               retries = retries.increment(method, url, response=response, _pool=self)

/usr/local/lib/python3.8/site-packages/urllib3/connectionpool.py:868: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Retry(total=0, connect=None, read=None, redirect=None, status=None)
method = &#39;GET&#39;
url = &#34;/api1/x3/erp/QAL/AOBJEXT(&#39;WYXOHKSC&#39;)?representation=AOBJEXT.%24details&#34;
response = &lt;urllib3.response.HTTPResponse object at 0x7f34bbe7e6a0&gt;
error = None
_pool = &lt;urllib3.connectionpool.HTTPSConnectionPool object at 0x7f34bbd16400&gt;
_stacktrace = None

    def increment(
        self,
        method=None,
        url=None,
        response=None,
        error=None,
        _pool=None,
        _stacktrace=None,
    ):
        &#34;&#34;&#34;Return a new Retry object with incremented retry counters.
    
        :param response: A response object, or None, if the server did not
            return a response.
        :type response: :class:`~urllib3.response.HTTPResponse`
        :param Exception error: An error encountered during the request, or
            None if the response was received successfully.
    
        :return: A new ``Retry`` object.
        &#34;&#34;&#34;
        if self.total is False and error:
            # Disabled, indicate to re-raise the error.
            raise six.reraise(type(error), error, _stacktrace)
    
        total = self.total
        if total is not None:
            total -= 1
    
        connect = self.connect
        read = self.read
        redirect = self.redirect
        status_count = self.status
        other = self.other
        cause = &#34;unknown&#34;
        status = None
        redirect_location = None
    
        if error and self._is_connection_error(error):
            # Connect retry?
            if connect is False:
                raise six.reraise(type(error), error, _stacktrace)
            elif connect is not None:
                connect -= 1
    
        elif error and self._is_read_error(error):
            # Read retry?
            if read is False or not self._is_method_retryable(method):
                raise six.reraise(type(error), error, _stacktrace)
            elif read is not None:
                read -= 1
    
        elif error:
            # Other retry?
            if other is not None:
                other -= 1
    
        elif response and response.get_redirect_location():
            # Redirect retry?
            if redirect is not None:
                redirect -= 1
            cause = &#34;too many redirects&#34;
            redirect_location = response.get_redirect_location()
            status = response.status
    
        else:
            # Incrementing because of a server error like a 500 in
            # status_forcelist and the given method is in the allowed_methods
            cause = ResponseError.GENERIC_ERROR
            if response and response.status:
                if status_count is not None:
                    status_count -= 1
                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)
                status = response.status
    
        history = self.history + (
            RequestHistory(method, url, error, status, redirect_location),
        )
    
        new_retry = self.new(
            total=total,
            connect=connect,
            read=read,
            redirect=redirect,
            status=status_count,
            other=other,
            history=history,
        )
    
        if new_retry.is_exhausted():
&gt;           raise MaxRetryError(_pool, url, error or ResponseError(cause))
E           urllib3.exceptions.MaxRetryError: HTTPSConnectionPool(host=&#39;sagex3-horsprod.covage.com&#39;, port=443): Max retries exceeded with url: /api1/x3/erp/QAL/AOBJEXT(&#39;WYXOHKSC&#39;)?representation=AOBJEXT.%24details (Caused by ResponseError(&#39;too many 502 error responses&#39;))

/usr/local/lib/python3.8/site-packages/urllib3/util/retry.py:592: MaxRetryError

During handling of the above exception, another exception occurred:

folder = &#39;QAL&#39;

    @pytest.mark.livetest
    @pytest.mark.xfail
    @pytest.mark.parametrize(&#34;folder&#34;, [os.environ[&#34;LIVE_TEST_X3_FOLDER&#34;]])
    def test_validate_schema_WYXOHKSC(folder):
        &#34;&#34;&#34;
        Compare diff for `WYXOHKSC` model between local snapshot and os.environ[&#34;LIVE_TEST_X3_FOLDER&#34;]\n
        WYXOHKSC: Contract import
        &#34;&#34;&#34;
&gt;       destination = get_model_schema_from_x3(&#34;WYXOHKSC&#34;, folder=folder)

app/api/live_tests/test_validate_import_schema.py:43: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
app/api/live_tests/test_validate_import_schema.py:31: in get_model_schema_from_x3
    resp = client.get(class_name=&#34;AOBJEXT&#34;, representation=&#34;AOBJEXT&#34;, ref=model_name)
app/x3_wrapper/rest_client.py:109: in get
    resp = self._cal_x3(&#34;GET&#34;, url, query_params)
app/x3_wrapper/rest_client.py:70: in _cal_x3
    resp = self.client.request(method, url, params=query_params)
/usr/local/lib/python3.8/site-packages/requests/sessions.py:587: in request
    resp = self.send(prep, **send_kwargs)
/usr/local/lib/python3.8/site-packages/requests/sessions.py:701: in send
    r = adapter.send(request, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;requests.adapters.HTTPAdapter object at 0x7f34bbd16070&gt;
request = &lt;PreparedRequest [GET]&gt;, stream = False
timeout = Timeout(connect=None, read=None, total=None), verify = True
cert = None
proxies = OrderedDict([(&#39;no&#39;, &#39;gitlab-runner-cache-01-prd.nut.covage.com&#39;), (&#39;http&#39;, &#39;http://squid.kosc.net:3128&#39;), (&#39;https&#39;, &#39;http://squid.kosc.net:3128&#39;)])

    def send(
        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None
    ):
        &#34;&#34;&#34;Sends PreparedRequest object. Returns Response object.
    
        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.
        :param stream: (optional) Whether to stream the request content.
        :param timeout: (optional) How long to wait for the server to send
            data before giving up, as a float, or a :ref:`(connect timeout,
            read timeout) &lt;timeouts&gt;` tuple.
        :type timeout: float or tuple or urllib3 Timeout object
        :param verify: (optional) Either a boolean, in which case it controls whether
            we verify the server&#39;s TLS certificate, or a string, in which case it
            must be a path to a CA bundle to use
        :param cert: (optional) Any user-provided SSL certificate to be trusted.
        :param proxies: (optional) The proxies dictionary to apply to the request.
        :rtype: requests.Response
        &#34;&#34;&#34;
    
        try:
            conn = self.get_connection(request.url, proxies)
        except LocationValueError as e:
            raise InvalidURL(e, request=request)
    
        self.cert_verify(conn, request.url, verify, cert)
        url = self.request_url(request, proxies)
        self.add_headers(
            request,
            stream=stream,
            timeout=timeout,
            verify=verify,
            cert=cert,
            proxies=proxies,
        )
    
        chunked = not (request.body is None or &#34;Content-Length&#34; in request.headers)
    
        if isinstance(timeout, tuple):
            try:
                connect, read = timeout
                timeout = TimeoutSauce(connect=connect, read=read)
            except ValueError:
                raise ValueError(
                    f&#34;Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, &#34;
                    f&#34;or a single float to set both timeouts to the same value.&#34;
                )
        elif isinstance(timeout, TimeoutSauce):
            pass
        else:
            timeout = TimeoutSauce(connect=timeout, read=timeout)
    
        try:
            if not chunked:
                resp = conn.urlopen(
                    method=request.method,
                    url=url,
                    body=request.body,
                    headers=request.headers,
                    redirect=False,
                    assert_same_host=False,
                    preload_content=False,
                    decode_content=False,
                    retries=self.max_retries,
                    timeout=timeout,
                )
    
            # Send the request.
            else:
                if hasattr(conn, &#34;proxy_pool&#34;):
                    conn = conn.proxy_pool
    
                low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)
    
                try:
                    skip_host = &#34;Host&#34; in request.headers
                    low_conn.putrequest(
                        request.method,
                        url,
                        skip_accept_encoding=True,
                        skip_host=skip_host,
                    )
    
                    for header, value in request.headers.items():
                        low_conn.putheader(header, value)
    
                    low_conn.endheaders()
    
                    for i in request.body:
                        low_conn.send(hex(len(i))[2:].encode(&#34;utf-8&#34;))
                        low_conn.send(b&#34;\r\n&#34;)
                        low_conn.send(i)
                        low_conn.send(b&#34;\r\n&#34;)
                    low_conn.send(b&#34;0\r\n\r\n&#34;)
    
                    # Receive the response from the server
                    r = low_conn.getresponse()
    
                    resp = HTTPResponse.from_httplib(
                        r,
                        pool=conn,
                        connection=low_conn,
                        preload_content=False,
                        decode_content=False,
                    )
                except Exception:
                    # If we hit any problems here, clean up the connection.
                    # Then, raise so that we can handle the actual exception.
                    low_conn.close()
                    raise
    
        except (ProtocolError, OSError) as err:
            raise ConnectionError(err, request=request)
    
        except MaxRetryError as e:
            if isinstance(e.reason, ConnectTimeoutError):
                # TODO: Remove this in 3.0.0: see #2811
                if not isinstance(e.reason, NewConnectionError):
                    raise ConnectTimeout(e, request=request)
    
            if isinstance(e.reason, ResponseError):
&gt;               raise RetryError(e, request=request)
E               requests.exceptions.RetryError: HTTPSConnectionPool(host=&#39;sagex3-horsprod.covage.com&#39;, port=443): Max retries exceeded with url: /api1/x3/erp/QAL/AOBJEXT(&#39;WYXOHKSC&#39;)?representation=AOBJEXT.%24details (Caused by ResponseError(&#39;too many 502 error responses&#39;))

/usr/local/lib/python3.8/site-packages/requests/adapters.py:556: RetryError</pre> </div> </div> </details> <details class="phase teardown "> <summary> <h4 class=title> <span class=phase-name>Teardown</span> </h4> </summary> <div class=content> </div> </details> </div> </div> </details> <details class="test xfailed"> <summary> <h3 class="title test-title"> <span class="status badge xfailed ">XFAIL</span> <span class=test-name> <span class=funcname>test_validate_schema_ZTRANSCO</span><span class=params>[QAL]</span> </span> <span class=duration>0:00:00.684497</span> </h3> </summary> <div class=content> <div class=documentation> <p>Compare diff for <cite>ZTRANSCO</cite> model between local snapshot and os.environ[&quot;LIVE_TEST_X3_FOLDER&quot;]</p> <p>ZTRANSCO: Transcoding data export</p> </div> <table class=metadata> <tr> <th>Started</th> <td>2023-06-30 01:14:35</td> </tr> <tr> <th>Ended</th> <td>2023-06-30 01:14:36</td> </tr> <tr> <th>Duration</th> <td>0:00:00.684497</td> </tr> <tr> <th>Markers</th> <td> <div class=marker> <span class="marker-name badge">xfail</span> <span class=marker-args> </span> </div> <div class=marker> <span class="marker-name badge">livetest</span> <span class=marker-args> </span> </div> </td> </tr> <tr> <th>Fixtures</th> <td> <span class="badge fixturename"> django_test_environment </span> <span class="badge fixturename"> django_db_blocker </span> <span class="badge fixturename"> folder </span> <span class="badge fixturename"> request </span> </td> </tr> </table> <div class=repr> <pre>requests.exceptions.RetryError: HTTPSConnectionPool(host=&#39;sagex3-horsprod.covage.com&#39;, port=443): Max retries exceeded with url: /api1/x3/erp/QAL/AOBJEXT(&#39;ZTRANSCO&#39;)?representation=AOBJEXT.%24details (Caused by ResponseError(&#39;too many 502 error responses&#39;))</pre> </div> <div class=test-phases> <details class="phase setup "> <summary> <h4 class=title> <span class=phase-name>Setup</span> </h4> </summary> <div class=content> </div> </details> <details class="phase call xfailed" open> <summary> <h4 class=title> <span class="status  xfailed"></span> <span class=phase-name>Call</span> </h4> </summary> <div class=content> <div class=repr> <pre>self = &lt;requests.adapters.HTTPAdapter object at 0x7f34c03a3e50&gt;
request = &lt;PreparedRequest [GET]&gt;, stream = False
timeout = Timeout(connect=None, read=None, total=None), verify = True
cert = None
proxies = OrderedDict([(&#39;no&#39;, &#39;gitlab-runner-cache-01-prd.nut.covage.com&#39;), (&#39;http&#39;, &#39;http://squid.kosc.net:3128&#39;), (&#39;https&#39;, &#39;http://squid.kosc.net:3128&#39;)])

    def send(
        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None
    ):
        &#34;&#34;&#34;Sends PreparedRequest object. Returns Response object.
    
        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.
        :param stream: (optional) Whether to stream the request content.
        :param timeout: (optional) How long to wait for the server to send
            data before giving up, as a float, or a :ref:`(connect timeout,
            read timeout) &lt;timeouts&gt;` tuple.
        :type timeout: float or tuple or urllib3 Timeout object
        :param verify: (optional) Either a boolean, in which case it controls whether
            we verify the server&#39;s TLS certificate, or a string, in which case it
            must be a path to a CA bundle to use
        :param cert: (optional) Any user-provided SSL certificate to be trusted.
        :param proxies: (optional) The proxies dictionary to apply to the request.
        :rtype: requests.Response
        &#34;&#34;&#34;
    
        try:
            conn = self.get_connection(request.url, proxies)
        except LocationValueError as e:
            raise InvalidURL(e, request=request)
    
        self.cert_verify(conn, request.url, verify, cert)
        url = self.request_url(request, proxies)
        self.add_headers(
            request,
            stream=stream,
            timeout=timeout,
            verify=verify,
            cert=cert,
            proxies=proxies,
        )
    
        chunked = not (request.body is None or &#34;Content-Length&#34; in request.headers)
    
        if isinstance(timeout, tuple):
            try:
                connect, read = timeout
                timeout = TimeoutSauce(connect=connect, read=read)
            except ValueError:
                raise ValueError(
                    f&#34;Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, &#34;
                    f&#34;or a single float to set both timeouts to the same value.&#34;
                )
        elif isinstance(timeout, TimeoutSauce):
            pass
        else:
            timeout = TimeoutSauce(connect=timeout, read=timeout)
    
        try:
            if not chunked:
&gt;               resp = conn.urlopen(
                    method=request.method,
                    url=url,
                    body=request.body,
                    headers=request.headers,
                    redirect=False,
                    assert_same_host=False,
                    preload_content=False,
                    decode_content=False,
                    retries=self.max_retries,
                    timeout=timeout,
                )

/usr/local/lib/python3.8/site-packages/requests/adapters.py:489: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connectionpool.HTTPSConnectionPool object at 0x7f34c03daf10&gt;
method = &#39;GET&#39;
url = &#34;/api1/x3/erp/QAL/AOBJEXT(&#39;ZTRANSCO&#39;)?representation=AOBJEXT.%24details&#34;
body = None
headers = {&#39;User-Agent&#39;: &#39;python-requests/2.28.1&#39;, &#39;Accept-Encoding&#39;: &#39;gzip, deflate&#39;, &#39;Accept&#39;: &#39;*/*&#39;, &#39;Connection&#39;: &#39;keep-alive&#39;, &#39;Content-Type&#39;: &#39;application/json&#39;, &#39;Authorization&#39;: &#39;Basic aW50cmFjbzpXYXNzaW1Db3ZhZ2VA&#39;}
retries = Retry(total=2, connect=None, read=None, redirect=None, status=None)
redirect = False, assert_same_host = False
timeout = Timeout(connect=None, read=None, total=None), pool_timeout = None
release_conn = False, chunked = False, body_pos = None
response_kw = {&#39;decode_content&#39;: False, &#39;preload_content&#39;: False, &#39;request_method&#39;: &#39;GET&#39;}
parsed_url = Url(scheme=None, auth=None, host=None, port=None, path=&#34;/api1/x3/erp/QAL/AOBJEXT(&#39;ZTRANSCO&#39;)&#34;, query=&#39;representation=AOBJEXT.%24details&#39;, fragment=None)
destination_scheme = None
conn = &lt;urllib3.connection.HTTPSConnection object at 0x7f34c048c160&gt;
release_this_conn = False, http_tunnel_required = True, err = None
clean_exit = True

    def urlopen(
        self,
        method,
        url,
        body=None,
        headers=None,
        retries=None,
        redirect=True,
        assert_same_host=True,
        timeout=_Default,
        pool_timeout=None,
        release_conn=None,
        chunked=False,
        body_pos=None,
        **response_kw
    ):
        &#34;&#34;&#34;
        Get a connection from the pool and perform an HTTP request. This is the
        lowest level call for making a request, so you&#39;ll need to specify all
        the raw details.
    
        .. note::
    
           More commonly, it&#39;s appropriate to use a convenience method provided
           by :class:`.RequestMethods`, such as :meth:`request`.
    
        .. note::
    
           `release_conn` will only behave as expected if
           `preload_content=False` because we want to make
           `preload_content=False` the default behaviour someday soon without
           breaking backwards compatibility.
    
        :param method:
            HTTP request method (such as GET, POST, PUT, etc.)
    
        :param url:
            The URL to perform the request on.
    
        :param body:
            Data to send in the request body, either :class:`str`, :class:`bytes`,
            an iterable of :class:`str`/:class:`bytes`, or a file-like object.
    
        :param headers:
            Dictionary of custom headers to send, such as User-Agent,
            If-None-Match, etc. If None, pool headers are used. If provided,
            these headers completely replace any pool-specific headers.
    
        :param retries:
            Configure the number of retries to allow before raising a
            :class:`~urllib3.exceptions.MaxRetryError` exception.
    
            Pass ``None`` to retry until you receive a response. Pass a
            :class:`~urllib3.util.retry.Retry` object for fine-grained control
            over different types of retries.
            Pass an integer number to retry connection errors that many times,
            but no other types of errors. Pass zero to never retry.
    
            If ``False``, then retries are disabled and any exception is raised
            immediately. Also, instead of raising a MaxRetryError on redirects,
            the redirect response will be returned.
    
        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.
    
        :param redirect:
            If True, automatically handle redirects (status codes 301, 302,
            303, 307, 308). Each redirect counts as a retry. Disabling retries
            will disable redirect, too.
    
        :param assert_same_host:
            If ``True``, will make sure that the host of the pool requests is
            consistent else will raise HostChangedError. When ``False``, you can
            use the pool on an HTTP proxy and request foreign hosts.
    
        :param timeout:
            If specified, overrides the default timeout for this one
            request. It may be a float (in seconds) or an instance of
            :class:`urllib3.util.Timeout`.
    
        :param pool_timeout:
            If set and the pool is set to block=True, then this method will
            block for ``pool_timeout`` seconds and raise EmptyPoolError if no
            connection is available within the time period.
    
        :param release_conn:
            If False, then the urlopen call will not release the connection
            back into the pool once a response is received (but will release if
            you read the entire contents of the response such as when
            `preload_content=True`). This is useful if you&#39;re not preloading
            the response&#39;s content immediately. You will need to call
            ``r.release_conn()`` on the response ``r`` to return the connection
            back into the pool. If None, it takes the value of
            ``response_kw.get(&#39;preload_content&#39;, True)``.
    
        :param chunked:
            If True, urllib3 will send the body using chunked transfer
            encoding. Otherwise, urllib3 will send the body using the standard
            content-length form. Defaults to False.
    
        :param int body_pos:
            Position to seek to in file-like body in the event of a retry or
            redirect. Typically this won&#39;t need to be set because urllib3 will
            auto-populate the value when needed.
    
        :param \\**response_kw:
            Additional parameters are passed to
            :meth:`urllib3.response.HTTPResponse.from_httplib`
        &#34;&#34;&#34;
    
        parsed_url = parse_url(url)
        destination_scheme = parsed_url.scheme
    
        if headers is None:
            headers = self.headers
    
        if not isinstance(retries, Retry):
            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)
    
        if release_conn is None:
            release_conn = response_kw.get(&#34;preload_content&#34;, True)
    
        # Check host
        if assert_same_host and not self.is_same_host(url):
            raise HostChangedError(self, url, retries)
    
        # Ensure that the URL we&#39;re connecting to is properly encoded
        if url.startswith(&#34;/&#34;):
            url = six.ensure_str(_encode_target(url))
        else:
            url = six.ensure_str(parsed_url.url)
    
        conn = None
    
        # Track whether `conn` needs to be released before
        # returning/raising/recursing. Update this variable if necessary, and
        # leave `release_conn` constant throughout the function. That way, if
        # the function recurses, the original value of `release_conn` will be
        # passed down into the recursive call, and its value will be respected.
        #
        # See issue #651 [1] for details.
        #
        # [1] &lt;https://github.com/urllib3/urllib3/issues/651&gt;
        release_this_conn = release_conn
    
        http_tunnel_required = connection_requires_http_tunnel(
            self.proxy, self.proxy_config, destination_scheme
        )
    
        # Merge the proxy headers. Only done when not using HTTP CONNECT. We
        # have to copy the headers dict so we can safely change it without those
        # changes being reflected in anyone else&#39;s copy.
        if not http_tunnel_required:
            headers = headers.copy()
            headers.update(self.proxy_headers)
    
        # Must keep the exception bound to a separate variable or else Python 3
        # complains about UnboundLocalError.
        err = None
    
        # Keep track of whether we cleanly exited the except block. This
        # ensures we do proper cleanup in finally.
        clean_exit = False
    
        # Rewind body position, if needed. Record current position
        # for future rewinds in the event of a redirect/retry.
        body_pos = set_file_position(body, body_pos)
    
        try:
            # Request a connection from the queue.
            timeout_obj = self._get_timeout(timeout)
            conn = self._get_conn(timeout=pool_timeout)
    
            conn.timeout = timeout_obj.connect_timeout
    
            is_new_proxy_conn = self.proxy is not None and not getattr(
                conn, &#34;sock&#34;, None
            )
            if is_new_proxy_conn and http_tunnel_required:
                self._prepare_proxy(conn)
    
            # Make the request on the httplib connection object.
            httplib_response = self._make_request(
                conn,
                method,
                url,
                timeout=timeout_obj,
                body=body,
                headers=headers,
                chunked=chunked,
            )
    
            # If we&#39;re going to release the connection in ``finally:``, then
            # the response doesn&#39;t need to know about the connection. Otherwise
            # it will also try to release it and we&#39;ll have a double-release
            # mess.
            response_conn = conn if not release_conn else None
    
            # Pass method to Response for length checking
            response_kw[&#34;request_method&#34;] = method
    
            # Import httplib&#39;s response into our own wrapper object
            response = self.ResponseCls.from_httplib(
                httplib_response,
                pool=self,
                connection=response_conn,
                retries=retries,
                **response_kw
            )
    
            # Everything went great!
            clean_exit = True
    
        except EmptyPoolError:
            # Didn&#39;t get a connection from the pool, no need to clean up
            clean_exit = True
            release_this_conn = False
            raise
    
        except (
            TimeoutError,
            HTTPException,
            SocketError,
            ProtocolError,
            BaseSSLError,
            SSLError,
            CertificateError,
        ) as e:
            # Discard the connection for these exceptions. It will be
            # replaced during the next _get_conn() call.
            clean_exit = False
    
            def _is_ssl_error_message_from_http_proxy(ssl_error):
                # We&#39;re trying to detect the message &#39;WRONG_VERSION_NUMBER&#39; but
                # SSLErrors are kinda all over the place when it comes to the message,
                # so we try to cover our bases here!
                message = &#34; &#34;.join(re.split(&#34;[^a-z]&#34;, str(ssl_error).lower()))
                return (
                    &#34;wrong version number&#34; in message or &#34;unknown protocol&#34; in message
                )
    
            # Try to detect a common user error with proxies which is to
            # set an HTTP proxy to be HTTPS when it should be &#39;http://&#39;
            # (ie {&#39;http&#39;: &#39;http://proxy&#39;, &#39;https&#39;: &#39;https://proxy&#39;})
            # Instead we add a nice error message and point to a URL.
            if (
                isinstance(e, BaseSSLError)
                and self.proxy
                and _is_ssl_error_message_from_http_proxy(e)
                and conn.proxy
                and conn.proxy.scheme == &#34;https&#34;
            ):
                e = ProxyError(
                    &#34;Your proxy appears to only use HTTP and not HTTPS, &#34;
                    &#34;try changing your proxy URL to be HTTP. See: &#34;
                    &#34;https://urllib3.readthedocs.io/en/1.26.x/advanced-usage.html&#34;
                    &#34;#https-proxy-error-http-proxy&#34;,
                    SSLError(e),
                )
            elif isinstance(e, (BaseSSLError, CertificateError)):
                e = SSLError(e)
            elif isinstance(e, (SocketError, NewConnectionError)) and self.proxy:
                e = ProxyError(&#34;Cannot connect to proxy.&#34;, e)
            elif isinstance(e, (SocketError, HTTPException)):
                e = ProtocolError(&#34;Connection aborted.&#34;, e)
    
            retries = retries.increment(
                method, url, error=e, _pool=self, _stacktrace=sys.exc_info()[2]
            )
            retries.sleep()
    
            # Keep track of the error for the retry warning.
            err = e
    
        finally:
            if not clean_exit:
                # We hit some kind of exception, handled or otherwise. We need
                # to throw the connection away unless explicitly told not to.
                # Close the connection, set the variable to None, and make sure
                # we put the None back in the pool to avoid leaking it.
                conn = conn and conn.close()
                release_this_conn = True
    
            if release_this_conn:
                # Put the connection back to be reused. If the connection is
                # expired then it will be None, which will get replaced with a
                # fresh connection during _get_conn.
                self._put_conn(conn)
    
        if not conn:
            # Try again
            log.warning(
                &#34;Retrying (%r) after connection broken by &#39;%r&#39;: %s&#34;, retries, err, url
            )
            return self.urlopen(
                method,
                url,
                body,
                headers,
                retries,
                redirect,
                assert_same_host,
                timeout=timeout,
                pool_timeout=pool_timeout,
                release_conn=release_conn,
                chunked=chunked,
                body_pos=body_pos,
                **response_kw
            )
    
        # Handle redirect?
        redirect_location = redirect and response.get_redirect_location()
        if redirect_location:
            if response.status == 303:
                method = &#34;GET&#34;
    
            try:
                retries = retries.increment(method, url, response=response, _pool=self)
            except MaxRetryError:
                if retries.raise_on_redirect:
                    response.drain_conn()
                    raise
                return response
    
            response.drain_conn()
            retries.sleep_for_retry(response)
            log.debug(&#34;Redirecting %s -&gt; %s&#34;, url, redirect_location)
            return self.urlopen(
                method,
                redirect_location,
                body,
                headers,
                retries=retries,
                redirect=redirect,
                assert_same_host=assert_same_host,
                timeout=timeout,
                pool_timeout=pool_timeout,
                release_conn=release_conn,
                chunked=chunked,
                body_pos=body_pos,
                **response_kw
            )
    
        # Check if we should retry the HTTP response.
        has_retry_after = bool(response.getheader(&#34;Retry-After&#34;))
        if retries.is_retry(method, response.status, has_retry_after):
            try:
                retries = retries.increment(method, url, response=response, _pool=self)
            except MaxRetryError:
                if retries.raise_on_status:
                    response.drain_conn()
                    raise
                return response
    
            response.drain_conn()
            retries.sleep(response)
            log.debug(&#34;Retry: %s&#34;, url)
&gt;           return self.urlopen(
                method,
                url,
                body,
                headers,
                retries=retries,
                redirect=redirect,
                assert_same_host=assert_same_host,
                timeout=timeout,
                pool_timeout=pool_timeout,
                release_conn=release_conn,
                chunked=chunked,
                body_pos=body_pos,
                **response_kw
            )

/usr/local/lib/python3.8/site-packages/urllib3/connectionpool.py:878: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connectionpool.HTTPSConnectionPool object at 0x7f34c03daf10&gt;
method = &#39;GET&#39;
url = &#34;/api1/x3/erp/QAL/AOBJEXT(&#39;ZTRANSCO&#39;)?representation=AOBJEXT.%24details&#34;
body = None
headers = {&#39;User-Agent&#39;: &#39;python-requests/2.28.1&#39;, &#39;Accept-Encoding&#39;: &#39;gzip, deflate&#39;, &#39;Accept&#39;: &#39;*/*&#39;, &#39;Connection&#39;: &#39;keep-alive&#39;, &#39;Content-Type&#39;: &#39;application/json&#39;, &#39;Authorization&#39;: &#39;Basic aW50cmFjbzpXYXNzaW1Db3ZhZ2VA&#39;}
retries = Retry(total=1, connect=None, read=None, redirect=None, status=None)
redirect = False, assert_same_host = False
timeout = Timeout(connect=None, read=None, total=None), pool_timeout = None
release_conn = False, chunked = False, body_pos = None
response_kw = {&#39;decode_content&#39;: False, &#39;preload_content&#39;: False, &#39;request_method&#39;: &#39;GET&#39;}
parsed_url = Url(scheme=None, auth=None, host=None, port=None, path=&#34;/api1/x3/erp/QAL/AOBJEXT(&#39;ZTRANSCO&#39;)&#34;, query=&#39;representation=AOBJEXT.%24details&#39;, fragment=None)
destination_scheme = None
conn = &lt;urllib3.connection.HTTPSConnection object at 0x7f34c048c160&gt;
release_this_conn = False, http_tunnel_required = True, err = None
clean_exit = True

    def urlopen(
        self,
        method,
        url,
        body=None,
        headers=None,
        retries=None,
        redirect=True,
        assert_same_host=True,
        timeout=_Default,
        pool_timeout=None,
        release_conn=None,
        chunked=False,
        body_pos=None,
        **response_kw
    ):
        &#34;&#34;&#34;
        Get a connection from the pool and perform an HTTP request. This is the
        lowest level call for making a request, so you&#39;ll need to specify all
        the raw details.
    
        .. note::
    
           More commonly, it&#39;s appropriate to use a convenience method provided
           by :class:`.RequestMethods`, such as :meth:`request`.
    
        .. note::
    
           `release_conn` will only behave as expected if
           `preload_content=False` because we want to make
           `preload_content=False` the default behaviour someday soon without
           breaking backwards compatibility.
    
        :param method:
            HTTP request method (such as GET, POST, PUT, etc.)
    
        :param url:
            The URL to perform the request on.
    
        :param body:
            Data to send in the request body, either :class:`str`, :class:`bytes`,
            an iterable of :class:`str`/:class:`bytes`, or a file-like object.
    
        :param headers:
            Dictionary of custom headers to send, such as User-Agent,
            If-None-Match, etc. If None, pool headers are used. If provided,
            these headers completely replace any pool-specific headers.
    
        :param retries:
            Configure the number of retries to allow before raising a
            :class:`~urllib3.exceptions.MaxRetryError` exception.
    
            Pass ``None`` to retry until you receive a response. Pass a
            :class:`~urllib3.util.retry.Retry` object for fine-grained control
            over different types of retries.
            Pass an integer number to retry connection errors that many times,
            but no other types of errors. Pass zero to never retry.
    
            If ``False``, then retries are disabled and any exception is raised
            immediately. Also, instead of raising a MaxRetryError on redirects,
            the redirect response will be returned.
    
        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.
    
        :param redirect:
            If True, automatically handle redirects (status codes 301, 302,
            303, 307, 308). Each redirect counts as a retry. Disabling retries
            will disable redirect, too.
    
        :param assert_same_host:
            If ``True``, will make sure that the host of the pool requests is
            consistent else will raise HostChangedError. When ``False``, you can
            use the pool on an HTTP proxy and request foreign hosts.
    
        :param timeout:
            If specified, overrides the default timeout for this one
            request. It may be a float (in seconds) or an instance of
            :class:`urllib3.util.Timeout`.
    
        :param pool_timeout:
            If set and the pool is set to block=True, then this method will
            block for ``pool_timeout`` seconds and raise EmptyPoolError if no
            connection is available within the time period.
    
        :param release_conn:
            If False, then the urlopen call will not release the connection
            back into the pool once a response is received (but will release if
            you read the entire contents of the response such as when
            `preload_content=True`). This is useful if you&#39;re not preloading
            the response&#39;s content immediately. You will need to call
            ``r.release_conn()`` on the response ``r`` to return the connection
            back into the pool. If None, it takes the value of
            ``response_kw.get(&#39;preload_content&#39;, True)``.
    
        :param chunked:
            If True, urllib3 will send the body using chunked transfer
            encoding. Otherwise, urllib3 will send the body using the standard
            content-length form. Defaults to False.
    
        :param int body_pos:
            Position to seek to in file-like body in the event of a retry or
            redirect. Typically this won&#39;t need to be set because urllib3 will
            auto-populate the value when needed.
    
        :param \\**response_kw:
            Additional parameters are passed to
            :meth:`urllib3.response.HTTPResponse.from_httplib`
        &#34;&#34;&#34;
    
        parsed_url = parse_url(url)
        destination_scheme = parsed_url.scheme
    
        if headers is None:
            headers = self.headers
    
        if not isinstance(retries, Retry):
            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)
    
        if release_conn is None:
            release_conn = response_kw.get(&#34;preload_content&#34;, True)
    
        # Check host
        if assert_same_host and not self.is_same_host(url):
            raise HostChangedError(self, url, retries)
    
        # Ensure that the URL we&#39;re connecting to is properly encoded
        if url.startswith(&#34;/&#34;):
            url = six.ensure_str(_encode_target(url))
        else:
            url = six.ensure_str(parsed_url.url)
    
        conn = None
    
        # Track whether `conn` needs to be released before
        # returning/raising/recursing. Update this variable if necessary, and
        # leave `release_conn` constant throughout the function. That way, if
        # the function recurses, the original value of `release_conn` will be
        # passed down into the recursive call, and its value will be respected.
        #
        # See issue #651 [1] for details.
        #
        # [1] &lt;https://github.com/urllib3/urllib3/issues/651&gt;
        release_this_conn = release_conn
    
        http_tunnel_required = connection_requires_http_tunnel(
            self.proxy, self.proxy_config, destination_scheme
        )
    
        # Merge the proxy headers. Only done when not using HTTP CONNECT. We
        # have to copy the headers dict so we can safely change it without those
        # changes being reflected in anyone else&#39;s copy.
        if not http_tunnel_required:
            headers = headers.copy()
            headers.update(self.proxy_headers)
    
        # Must keep the exception bound to a separate variable or else Python 3
        # complains about UnboundLocalError.
        err = None
    
        # Keep track of whether we cleanly exited the except block. This
        # ensures we do proper cleanup in finally.
        clean_exit = False
    
        # Rewind body position, if needed. Record current position
        # for future rewinds in the event of a redirect/retry.
        body_pos = set_file_position(body, body_pos)
    
        try:
            # Request a connection from the queue.
            timeout_obj = self._get_timeout(timeout)
            conn = self._get_conn(timeout=pool_timeout)
    
            conn.timeout = timeout_obj.connect_timeout
    
            is_new_proxy_conn = self.proxy is not None and not getattr(
                conn, &#34;sock&#34;, None
            )
            if is_new_proxy_conn and http_tunnel_required:
                self._prepare_proxy(conn)
    
            # Make the request on the httplib connection object.
            httplib_response = self._make_request(
                conn,
                method,
                url,
                timeout=timeout_obj,
                body=body,
                headers=headers,
                chunked=chunked,
            )
    
            # If we&#39;re going to release the connection in ``finally:``, then
            # the response doesn&#39;t need to know about the connection. Otherwise
            # it will also try to release it and we&#39;ll have a double-release
            # mess.
            response_conn = conn if not release_conn else None
    
            # Pass method to Response for length checking
            response_kw[&#34;request_method&#34;] = method
    
            # Import httplib&#39;s response into our own wrapper object
            response = self.ResponseCls.from_httplib(
                httplib_response,
                pool=self,
                connection=response_conn,
                retries=retries,
                **response_kw
            )
    
            # Everything went great!
            clean_exit = True
    
        except EmptyPoolError:
            # Didn&#39;t get a connection from the pool, no need to clean up
            clean_exit = True
            release_this_conn = False
            raise
    
        except (
            TimeoutError,
            HTTPException,
            SocketError,
            ProtocolError,
            BaseSSLError,
            SSLError,
            CertificateError,
        ) as e:
            # Discard the connection for these exceptions. It will be
            # replaced during the next _get_conn() call.
            clean_exit = False
    
            def _is_ssl_error_message_from_http_proxy(ssl_error):
                # We&#39;re trying to detect the message &#39;WRONG_VERSION_NUMBER&#39; but
                # SSLErrors are kinda all over the place when it comes to the message,
                # so we try to cover our bases here!
                message = &#34; &#34;.join(re.split(&#34;[^a-z]&#34;, str(ssl_error).lower()))
                return (
                    &#34;wrong version number&#34; in message or &#34;unknown protocol&#34; in message
                )
    
            # Try to detect a common user error with proxies which is to
            # set an HTTP proxy to be HTTPS when it should be &#39;http://&#39;
            # (ie {&#39;http&#39;: &#39;http://proxy&#39;, &#39;https&#39;: &#39;https://proxy&#39;})
            # Instead we add a nice error message and point to a URL.
            if (
                isinstance(e, BaseSSLError)
                and self.proxy
                and _is_ssl_error_message_from_http_proxy(e)
                and conn.proxy
                and conn.proxy.scheme == &#34;https&#34;
            ):
                e = ProxyError(
                    &#34;Your proxy appears to only use HTTP and not HTTPS, &#34;
                    &#34;try changing your proxy URL to be HTTP. See: &#34;
                    &#34;https://urllib3.readthedocs.io/en/1.26.x/advanced-usage.html&#34;
                    &#34;#https-proxy-error-http-proxy&#34;,
                    SSLError(e),
                )
            elif isinstance(e, (BaseSSLError, CertificateError)):
                e = SSLError(e)
            elif isinstance(e, (SocketError, NewConnectionError)) and self.proxy:
                e = ProxyError(&#34;Cannot connect to proxy.&#34;, e)
            elif isinstance(e, (SocketError, HTTPException)):
                e = ProtocolError(&#34;Connection aborted.&#34;, e)
    
            retries = retries.increment(
                method, url, error=e, _pool=self, _stacktrace=sys.exc_info()[2]
            )
            retries.sleep()
    
            # Keep track of the error for the retry warning.
            err = e
    
        finally:
            if not clean_exit:
                # We hit some kind of exception, handled or otherwise. We need
                # to throw the connection away unless explicitly told not to.
                # Close the connection, set the variable to None, and make sure
                # we put the None back in the pool to avoid leaking it.
                conn = conn and conn.close()
                release_this_conn = True
    
            if release_this_conn:
                # Put the connection back to be reused. If the connection is
                # expired then it will be None, which will get replaced with a
                # fresh connection during _get_conn.
                self._put_conn(conn)
    
        if not conn:
            # Try again
            log.warning(
                &#34;Retrying (%r) after connection broken by &#39;%r&#39;: %s&#34;, retries, err, url
            )
            return self.urlopen(
                method,
                url,
                body,
                headers,
                retries,
                redirect,
                assert_same_host,
                timeout=timeout,
                pool_timeout=pool_timeout,
                release_conn=release_conn,
                chunked=chunked,
                body_pos=body_pos,
                **response_kw
            )
    
        # Handle redirect?
        redirect_location = redirect and response.get_redirect_location()
        if redirect_location:
            if response.status == 303:
                method = &#34;GET&#34;
    
            try:
                retries = retries.increment(method, url, response=response, _pool=self)
            except MaxRetryError:
                if retries.raise_on_redirect:
                    response.drain_conn()
                    raise
                return response
    
            response.drain_conn()
            retries.sleep_for_retry(response)
            log.debug(&#34;Redirecting %s -&gt; %s&#34;, url, redirect_location)
            return self.urlopen(
                method,
                redirect_location,
                body,
                headers,
                retries=retries,
                redirect=redirect,
                assert_same_host=assert_same_host,
                timeout=timeout,
                pool_timeout=pool_timeout,
                release_conn=release_conn,
                chunked=chunked,
                body_pos=body_pos,
                **response_kw
            )
    
        # Check if we should retry the HTTP response.
        has_retry_after = bool(response.getheader(&#34;Retry-After&#34;))
        if retries.is_retry(method, response.status, has_retry_after):
            try:
                retries = retries.increment(method, url, response=response, _pool=self)
            except MaxRetryError:
                if retries.raise_on_status:
                    response.drain_conn()
                    raise
                return response
    
            response.drain_conn()
            retries.sleep(response)
            log.debug(&#34;Retry: %s&#34;, url)
&gt;           return self.urlopen(
                method,
                url,
                body,
                headers,
                retries=retries,
                redirect=redirect,
                assert_same_host=assert_same_host,
                timeout=timeout,
                pool_timeout=pool_timeout,
                release_conn=release_conn,
                chunked=chunked,
                body_pos=body_pos,
                **response_kw
            )

/usr/local/lib/python3.8/site-packages/urllib3/connectionpool.py:878: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connectionpool.HTTPSConnectionPool object at 0x7f34c03daf10&gt;
method = &#39;GET&#39;
url = &#34;/api1/x3/erp/QAL/AOBJEXT(&#39;ZTRANSCO&#39;)?representation=AOBJEXT.%24details&#34;
body = None
headers = {&#39;User-Agent&#39;: &#39;python-requests/2.28.1&#39;, &#39;Accept-Encoding&#39;: &#39;gzip, deflate&#39;, &#39;Accept&#39;: &#39;*/*&#39;, &#39;Connection&#39;: &#39;keep-alive&#39;, &#39;Content-Type&#39;: &#39;application/json&#39;, &#39;Authorization&#39;: &#39;Basic aW50cmFjbzpXYXNzaW1Db3ZhZ2VA&#39;}
retries = Retry(total=0, connect=None, read=None, redirect=None, status=None)
redirect = False, assert_same_host = False
timeout = Timeout(connect=None, read=None, total=None), pool_timeout = None
release_conn = False, chunked = False, body_pos = None
response_kw = {&#39;decode_content&#39;: False, &#39;preload_content&#39;: False, &#39;request_method&#39;: &#39;GET&#39;}
parsed_url = Url(scheme=None, auth=None, host=None, port=None, path=&#34;/api1/x3/erp/QAL/AOBJEXT(&#39;ZTRANSCO&#39;)&#34;, query=&#39;representation=AOBJEXT.%24details&#39;, fragment=None)
destination_scheme = None
conn = &lt;urllib3.connection.HTTPSConnection object at 0x7f34c048c160&gt;
release_this_conn = False, http_tunnel_required = True, err = None
clean_exit = True

    def urlopen(
        self,
        method,
        url,
        body=None,
        headers=None,
        retries=None,
        redirect=True,
        assert_same_host=True,
        timeout=_Default,
        pool_timeout=None,
        release_conn=None,
        chunked=False,
        body_pos=None,
        **response_kw
    ):
        &#34;&#34;&#34;
        Get a connection from the pool and perform an HTTP request. This is the
        lowest level call for making a request, so you&#39;ll need to specify all
        the raw details.
    
        .. note::
    
           More commonly, it&#39;s appropriate to use a convenience method provided
           by :class:`.RequestMethods`, such as :meth:`request`.
    
        .. note::
    
           `release_conn` will only behave as expected if
           `preload_content=False` because we want to make
           `preload_content=False` the default behaviour someday soon without
           breaking backwards compatibility.
    
        :param method:
            HTTP request method (such as GET, POST, PUT, etc.)
    
        :param url:
            The URL to perform the request on.
    
        :param body:
            Data to send in the request body, either :class:`str`, :class:`bytes`,
            an iterable of :class:`str`/:class:`bytes`, or a file-like object.
    
        :param headers:
            Dictionary of custom headers to send, such as User-Agent,
            If-None-Match, etc. If None, pool headers are used. If provided,
            these headers completely replace any pool-specific headers.
    
        :param retries:
            Configure the number of retries to allow before raising a
            :class:`~urllib3.exceptions.MaxRetryError` exception.
    
            Pass ``None`` to retry until you receive a response. Pass a
            :class:`~urllib3.util.retry.Retry` object for fine-grained control
            over different types of retries.
            Pass an integer number to retry connection errors that many times,
            but no other types of errors. Pass zero to never retry.
    
            If ``False``, then retries are disabled and any exception is raised
            immediately. Also, instead of raising a MaxRetryError on redirects,
            the redirect response will be returned.
    
        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.
    
        :param redirect:
            If True, automatically handle redirects (status codes 301, 302,
            303, 307, 308). Each redirect counts as a retry. Disabling retries
            will disable redirect, too.
    
        :param assert_same_host:
            If ``True``, will make sure that the host of the pool requests is
            consistent else will raise HostChangedError. When ``False``, you can
            use the pool on an HTTP proxy and request foreign hosts.
    
        :param timeout:
            If specified, overrides the default timeout for this one
            request. It may be a float (in seconds) or an instance of
            :class:`urllib3.util.Timeout`.
    
        :param pool_timeout:
            If set and the pool is set to block=True, then this method will
            block for ``pool_timeout`` seconds and raise EmptyPoolError if no
            connection is available within the time period.
    
        :param release_conn:
            If False, then the urlopen call will not release the connection
            back into the pool once a response is received (but will release if
            you read the entire contents of the response such as when
            `preload_content=True`). This is useful if you&#39;re not preloading
            the response&#39;s content immediately. You will need to call
            ``r.release_conn()`` on the response ``r`` to return the connection
            back into the pool. If None, it takes the value of
            ``response_kw.get(&#39;preload_content&#39;, True)``.
    
        :param chunked:
            If True, urllib3 will send the body using chunked transfer
            encoding. Otherwise, urllib3 will send the body using the standard
            content-length form. Defaults to False.
    
        :param int body_pos:
            Position to seek to in file-like body in the event of a retry or
            redirect. Typically this won&#39;t need to be set because urllib3 will
            auto-populate the value when needed.
    
        :param \\**response_kw:
            Additional parameters are passed to
            :meth:`urllib3.response.HTTPResponse.from_httplib`
        &#34;&#34;&#34;
    
        parsed_url = parse_url(url)
        destination_scheme = parsed_url.scheme
    
        if headers is None:
            headers = self.headers
    
        if not isinstance(retries, Retry):
            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)
    
        if release_conn is None:
            release_conn = response_kw.get(&#34;preload_content&#34;, True)
    
        # Check host
        if assert_same_host and not self.is_same_host(url):
            raise HostChangedError(self, url, retries)
    
        # Ensure that the URL we&#39;re connecting to is properly encoded
        if url.startswith(&#34;/&#34;):
            url = six.ensure_str(_encode_target(url))
        else:
            url = six.ensure_str(parsed_url.url)
    
        conn = None
    
        # Track whether `conn` needs to be released before
        # returning/raising/recursing. Update this variable if necessary, and
        # leave `release_conn` constant throughout the function. That way, if
        # the function recurses, the original value of `release_conn` will be
        # passed down into the recursive call, and its value will be respected.
        #
        # See issue #651 [1] for details.
        #
        # [1] &lt;https://github.com/urllib3/urllib3/issues/651&gt;
        release_this_conn = release_conn
    
        http_tunnel_required = connection_requires_http_tunnel(
            self.proxy, self.proxy_config, destination_scheme
        )
    
        # Merge the proxy headers. Only done when not using HTTP CONNECT. We
        # have to copy the headers dict so we can safely change it without those
        # changes being reflected in anyone else&#39;s copy.
        if not http_tunnel_required:
            headers = headers.copy()
            headers.update(self.proxy_headers)
    
        # Must keep the exception bound to a separate variable or else Python 3
        # complains about UnboundLocalError.
        err = None
    
        # Keep track of whether we cleanly exited the except block. This
        # ensures we do proper cleanup in finally.
        clean_exit = False
    
        # Rewind body position, if needed. Record current position
        # for future rewinds in the event of a redirect/retry.
        body_pos = set_file_position(body, body_pos)
    
        try:
            # Request a connection from the queue.
            timeout_obj = self._get_timeout(timeout)
            conn = self._get_conn(timeout=pool_timeout)
    
            conn.timeout = timeout_obj.connect_timeout
    
            is_new_proxy_conn = self.proxy is not None and not getattr(
                conn, &#34;sock&#34;, None
            )
            if is_new_proxy_conn and http_tunnel_required:
                self._prepare_proxy(conn)
    
            # Make the request on the httplib connection object.
            httplib_response = self._make_request(
                conn,
                method,
                url,
                timeout=timeout_obj,
                body=body,
                headers=headers,
                chunked=chunked,
            )
    
            # If we&#39;re going to release the connection in ``finally:``, then
            # the response doesn&#39;t need to know about the connection. Otherwise
            # it will also try to release it and we&#39;ll have a double-release
            # mess.
            response_conn = conn if not release_conn else None
    
            # Pass method to Response for length checking
            response_kw[&#34;request_method&#34;] = method
    
            # Import httplib&#39;s response into our own wrapper object
            response = self.ResponseCls.from_httplib(
                httplib_response,
                pool=self,
                connection=response_conn,
                retries=retries,
                **response_kw
            )
    
            # Everything went great!
            clean_exit = True
    
        except EmptyPoolError:
            # Didn&#39;t get a connection from the pool, no need to clean up
            clean_exit = True
            release_this_conn = False
            raise
    
        except (
            TimeoutError,
            HTTPException,
            SocketError,
            ProtocolError,
            BaseSSLError,
            SSLError,
            CertificateError,
        ) as e:
            # Discard the connection for these exceptions. It will be
            # replaced during the next _get_conn() call.
            clean_exit = False
    
            def _is_ssl_error_message_from_http_proxy(ssl_error):
                # We&#39;re trying to detect the message &#39;WRONG_VERSION_NUMBER&#39; but
                # SSLErrors are kinda all over the place when it comes to the message,
                # so we try to cover our bases here!
                message = &#34; &#34;.join(re.split(&#34;[^a-z]&#34;, str(ssl_error).lower()))
                return (
                    &#34;wrong version number&#34; in message or &#34;unknown protocol&#34; in message
                )
    
            # Try to detect a common user error with proxies which is to
            # set an HTTP proxy to be HTTPS when it should be &#39;http://&#39;
            # (ie {&#39;http&#39;: &#39;http://proxy&#39;, &#39;https&#39;: &#39;https://proxy&#39;})
            # Instead we add a nice error message and point to a URL.
            if (
                isinstance(e, BaseSSLError)
                and self.proxy
                and _is_ssl_error_message_from_http_proxy(e)
                and conn.proxy
                and conn.proxy.scheme == &#34;https&#34;
            ):
                e = ProxyError(
                    &#34;Your proxy appears to only use HTTP and not HTTPS, &#34;
                    &#34;try changing your proxy URL to be HTTP. See: &#34;
                    &#34;https://urllib3.readthedocs.io/en/1.26.x/advanced-usage.html&#34;
                    &#34;#https-proxy-error-http-proxy&#34;,
                    SSLError(e),
                )
            elif isinstance(e, (BaseSSLError, CertificateError)):
                e = SSLError(e)
            elif isinstance(e, (SocketError, NewConnectionError)) and self.proxy:
                e = ProxyError(&#34;Cannot connect to proxy.&#34;, e)
            elif isinstance(e, (SocketError, HTTPException)):
                e = ProtocolError(&#34;Connection aborted.&#34;, e)
    
            retries = retries.increment(
                method, url, error=e, _pool=self, _stacktrace=sys.exc_info()[2]
            )
            retries.sleep()
    
            # Keep track of the error for the retry warning.
            err = e
    
        finally:
            if not clean_exit:
                # We hit some kind of exception, handled or otherwise. We need
                # to throw the connection away unless explicitly told not to.
                # Close the connection, set the variable to None, and make sure
                # we put the None back in the pool to avoid leaking it.
                conn = conn and conn.close()
                release_this_conn = True
    
            if release_this_conn:
                # Put the connection back to be reused. If the connection is
                # expired then it will be None, which will get replaced with a
                # fresh connection during _get_conn.
                self._put_conn(conn)
    
        if not conn:
            # Try again
            log.warning(
                &#34;Retrying (%r) after connection broken by &#39;%r&#39;: %s&#34;, retries, err, url
            )
            return self.urlopen(
                method,
                url,
                body,
                headers,
                retries,
                redirect,
                assert_same_host,
                timeout=timeout,
                pool_timeout=pool_timeout,
                release_conn=release_conn,
                chunked=chunked,
                body_pos=body_pos,
                **response_kw
            )
    
        # Handle redirect?
        redirect_location = redirect and response.get_redirect_location()
        if redirect_location:
            if response.status == 303:
                method = &#34;GET&#34;
    
            try:
                retries = retries.increment(method, url, response=response, _pool=self)
            except MaxRetryError:
                if retries.raise_on_redirect:
                    response.drain_conn()
                    raise
                return response
    
            response.drain_conn()
            retries.sleep_for_retry(response)
            log.debug(&#34;Redirecting %s -&gt; %s&#34;, url, redirect_location)
            return self.urlopen(
                method,
                redirect_location,
                body,
                headers,
                retries=retries,
                redirect=redirect,
                assert_same_host=assert_same_host,
                timeout=timeout,
                pool_timeout=pool_timeout,
                release_conn=release_conn,
                chunked=chunked,
                body_pos=body_pos,
                **response_kw
            )
    
        # Check if we should retry the HTTP response.
        has_retry_after = bool(response.getheader(&#34;Retry-After&#34;))
        if retries.is_retry(method, response.status, has_retry_after):
            try:
                retries = retries.increment(method, url, response=response, _pool=self)
            except MaxRetryError:
                if retries.raise_on_status:
                    response.drain_conn()
                    raise
                return response
    
            response.drain_conn()
            retries.sleep(response)
            log.debug(&#34;Retry: %s&#34;, url)
&gt;           return self.urlopen(
                method,
                url,
                body,
                headers,
                retries=retries,
                redirect=redirect,
                assert_same_host=assert_same_host,
                timeout=timeout,
                pool_timeout=pool_timeout,
                release_conn=release_conn,
                chunked=chunked,
                body_pos=body_pos,
                **response_kw
            )

/usr/local/lib/python3.8/site-packages/urllib3/connectionpool.py:878: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connectionpool.HTTPSConnectionPool object at 0x7f34c03daf10&gt;
method = &#39;GET&#39;
url = &#34;/api1/x3/erp/QAL/AOBJEXT(&#39;ZTRANSCO&#39;)?representation=AOBJEXT.%24details&#34;
body = None
headers = {&#39;User-Agent&#39;: &#39;python-requests/2.28.1&#39;, &#39;Accept-Encoding&#39;: &#39;gzip, deflate&#39;, &#39;Accept&#39;: &#39;*/*&#39;, &#39;Connection&#39;: &#39;keep-alive&#39;, &#39;Content-Type&#39;: &#39;application/json&#39;, &#39;Authorization&#39;: &#39;Basic aW50cmFjbzpXYXNzaW1Db3ZhZ2VA&#39;}
retries = Retry(total=0, connect=None, read=None, redirect=None, status=None)
redirect = False, assert_same_host = False
timeout = Timeout(connect=None, read=None, total=None), pool_timeout = None
release_conn = False, chunked = False, body_pos = None
response_kw = {&#39;decode_content&#39;: False, &#39;preload_content&#39;: False, &#39;request_method&#39;: &#39;GET&#39;}
parsed_url = Url(scheme=None, auth=None, host=None, port=None, path=&#34;/api1/x3/erp/QAL/AOBJEXT(&#39;ZTRANSCO&#39;)&#34;, query=&#39;representation=AOBJEXT.%24details&#39;, fragment=None)
destination_scheme = None
conn = &lt;urllib3.connection.HTTPSConnection object at 0x7f34c048c160&gt;
release_this_conn = False, http_tunnel_required = True, err = None
clean_exit = True

    def urlopen(
        self,
        method,
        url,
        body=None,
        headers=None,
        retries=None,
        redirect=True,
        assert_same_host=True,
        timeout=_Default,
        pool_timeout=None,
        release_conn=None,
        chunked=False,
        body_pos=None,
        **response_kw
    ):
        &#34;&#34;&#34;
        Get a connection from the pool and perform an HTTP request. This is the
        lowest level call for making a request, so you&#39;ll need to specify all
        the raw details.
    
        .. note::
    
           More commonly, it&#39;s appropriate to use a convenience method provided
           by :class:`.RequestMethods`, such as :meth:`request`.
    
        .. note::
    
           `release_conn` will only behave as expected if
           `preload_content=False` because we want to make
           `preload_content=False` the default behaviour someday soon without
           breaking backwards compatibility.
    
        :param method:
            HTTP request method (such as GET, POST, PUT, etc.)
    
        :param url:
            The URL to perform the request on.
    
        :param body:
            Data to send in the request body, either :class:`str`, :class:`bytes`,
            an iterable of :class:`str`/:class:`bytes`, or a file-like object.
    
        :param headers:
            Dictionary of custom headers to send, such as User-Agent,
            If-None-Match, etc. If None, pool headers are used. If provided,
            these headers completely replace any pool-specific headers.
    
        :param retries:
            Configure the number of retries to allow before raising a
            :class:`~urllib3.exceptions.MaxRetryError` exception.
    
            Pass ``None`` to retry until you receive a response. Pass a
            :class:`~urllib3.util.retry.Retry` object for fine-grained control
            over different types of retries.
            Pass an integer number to retry connection errors that many times,
            but no other types of errors. Pass zero to never retry.
    
            If ``False``, then retries are disabled and any exception is raised
            immediately. Also, instead of raising a MaxRetryError on redirects,
            the redirect response will be returned.
    
        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.
    
        :param redirect:
            If True, automatically handle redirects (status codes 301, 302,
            303, 307, 308). Each redirect counts as a retry. Disabling retries
            will disable redirect, too.
    
        :param assert_same_host:
            If ``True``, will make sure that the host of the pool requests is
            consistent else will raise HostChangedError. When ``False``, you can
            use the pool on an HTTP proxy and request foreign hosts.
    
        :param timeout:
            If specified, overrides the default timeout for this one
            request. It may be a float (in seconds) or an instance of
            :class:`urllib3.util.Timeout`.
    
        :param pool_timeout:
            If set and the pool is set to block=True, then this method will
            block for ``pool_timeout`` seconds and raise EmptyPoolError if no
            connection is available within the time period.
    
        :param release_conn:
            If False, then the urlopen call will not release the connection
            back into the pool once a response is received (but will release if
            you read the entire contents of the response such as when
            `preload_content=True`). This is useful if you&#39;re not preloading
            the response&#39;s content immediately. You will need to call
            ``r.release_conn()`` on the response ``r`` to return the connection
            back into the pool. If None, it takes the value of
            ``response_kw.get(&#39;preload_content&#39;, True)``.
    
        :param chunked:
            If True, urllib3 will send the body using chunked transfer
            encoding. Otherwise, urllib3 will send the body using the standard
            content-length form. Defaults to False.
    
        :param int body_pos:
            Position to seek to in file-like body in the event of a retry or
            redirect. Typically this won&#39;t need to be set because urllib3 will
            auto-populate the value when needed.
    
        :param \\**response_kw:
            Additional parameters are passed to
            :meth:`urllib3.response.HTTPResponse.from_httplib`
        &#34;&#34;&#34;
    
        parsed_url = parse_url(url)
        destination_scheme = parsed_url.scheme
    
        if headers is None:
            headers = self.headers
    
        if not isinstance(retries, Retry):
            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)
    
        if release_conn is None:
            release_conn = response_kw.get(&#34;preload_content&#34;, True)
    
        # Check host
        if assert_same_host and not self.is_same_host(url):
            raise HostChangedError(self, url, retries)
    
        # Ensure that the URL we&#39;re connecting to is properly encoded
        if url.startswith(&#34;/&#34;):
            url = six.ensure_str(_encode_target(url))
        else:
            url = six.ensure_str(parsed_url.url)
    
        conn = None
    
        # Track whether `conn` needs to be released before
        # returning/raising/recursing. Update this variable if necessary, and
        # leave `release_conn` constant throughout the function. That way, if
        # the function recurses, the original value of `release_conn` will be
        # passed down into the recursive call, and its value will be respected.
        #
        # See issue #651 [1] for details.
        #
        # [1] &lt;https://github.com/urllib3/urllib3/issues/651&gt;
        release_this_conn = release_conn
    
        http_tunnel_required = connection_requires_http_tunnel(
            self.proxy, self.proxy_config, destination_scheme
        )
    
        # Merge the proxy headers. Only done when not using HTTP CONNECT. We
        # have to copy the headers dict so we can safely change it without those
        # changes being reflected in anyone else&#39;s copy.
        if not http_tunnel_required:
            headers = headers.copy()
            headers.update(self.proxy_headers)
    
        # Must keep the exception bound to a separate variable or else Python 3
        # complains about UnboundLocalError.
        err = None
    
        # Keep track of whether we cleanly exited the except block. This
        # ensures we do proper cleanup in finally.
        clean_exit = False
    
        # Rewind body position, if needed. Record current position
        # for future rewinds in the event of a redirect/retry.
        body_pos = set_file_position(body, body_pos)
    
        try:
            # Request a connection from the queue.
            timeout_obj = self._get_timeout(timeout)
            conn = self._get_conn(timeout=pool_timeout)
    
            conn.timeout = timeout_obj.connect_timeout
    
            is_new_proxy_conn = self.proxy is not None and not getattr(
                conn, &#34;sock&#34;, None
            )
            if is_new_proxy_conn and http_tunnel_required:
                self._prepare_proxy(conn)
    
            # Make the request on the httplib connection object.
            httplib_response = self._make_request(
                conn,
                method,
                url,
                timeout=timeout_obj,
                body=body,
                headers=headers,
                chunked=chunked,
            )
    
            # If we&#39;re going to release the connection in ``finally:``, then
            # the response doesn&#39;t need to know about the connection. Otherwise
            # it will also try to release it and we&#39;ll have a double-release
            # mess.
            response_conn = conn if not release_conn else None
    
            # Pass method to Response for length checking
            response_kw[&#34;request_method&#34;] = method
    
            # Import httplib&#39;s response into our own wrapper object
            response = self.ResponseCls.from_httplib(
                httplib_response,
                pool=self,
                connection=response_conn,
                retries=retries,
                **response_kw
            )
    
            # Everything went great!
            clean_exit = True
    
        except EmptyPoolError:
            # Didn&#39;t get a connection from the pool, no need to clean up
            clean_exit = True
            release_this_conn = False
            raise
    
        except (
            TimeoutError,
            HTTPException,
            SocketError,
            ProtocolError,
            BaseSSLError,
            SSLError,
            CertificateError,
        ) as e:
            # Discard the connection for these exceptions. It will be
            # replaced during the next _get_conn() call.
            clean_exit = False
    
            def _is_ssl_error_message_from_http_proxy(ssl_error):
                # We&#39;re trying to detect the message &#39;WRONG_VERSION_NUMBER&#39; but
                # SSLErrors are kinda all over the place when it comes to the message,
                # so we try to cover our bases here!
                message = &#34; &#34;.join(re.split(&#34;[^a-z]&#34;, str(ssl_error).lower()))
                return (
                    &#34;wrong version number&#34; in message or &#34;unknown protocol&#34; in message
                )
    
            # Try to detect a common user error with proxies which is to
            # set an HTTP proxy to be HTTPS when it should be &#39;http://&#39;
            # (ie {&#39;http&#39;: &#39;http://proxy&#39;, &#39;https&#39;: &#39;https://proxy&#39;})
            # Instead we add a nice error message and point to a URL.
            if (
                isinstance(e, BaseSSLError)
                and self.proxy
                and _is_ssl_error_message_from_http_proxy(e)
                and conn.proxy
                and conn.proxy.scheme == &#34;https&#34;
            ):
                e = ProxyError(
                    &#34;Your proxy appears to only use HTTP and not HTTPS, &#34;
                    &#34;try changing your proxy URL to be HTTP. See: &#34;
                    &#34;https://urllib3.readthedocs.io/en/1.26.x/advanced-usage.html&#34;
                    &#34;#https-proxy-error-http-proxy&#34;,
                    SSLError(e),
                )
            elif isinstance(e, (BaseSSLError, CertificateError)):
                e = SSLError(e)
            elif isinstance(e, (SocketError, NewConnectionError)) and self.proxy:
                e = ProxyError(&#34;Cannot connect to proxy.&#34;, e)
            elif isinstance(e, (SocketError, HTTPException)):
                e = ProtocolError(&#34;Connection aborted.&#34;, e)
    
            retries = retries.increment(
                method, url, error=e, _pool=self, _stacktrace=sys.exc_info()[2]
            )
            retries.sleep()
    
            # Keep track of the error for the retry warning.
            err = e
    
        finally:
            if not clean_exit:
                # We hit some kind of exception, handled or otherwise. We need
                # to throw the connection away unless explicitly told not to.
                # Close the connection, set the variable to None, and make sure
                # we put the None back in the pool to avoid leaking it.
                conn = conn and conn.close()
                release_this_conn = True
    
            if release_this_conn:
                # Put the connection back to be reused. If the connection is
                # expired then it will be None, which will get replaced with a
                # fresh connection during _get_conn.
                self._put_conn(conn)
    
        if not conn:
            # Try again
            log.warning(
                &#34;Retrying (%r) after connection broken by &#39;%r&#39;: %s&#34;, retries, err, url
            )
            return self.urlopen(
                method,
                url,
                body,
                headers,
                retries,
                redirect,
                assert_same_host,
                timeout=timeout,
                pool_timeout=pool_timeout,
                release_conn=release_conn,
                chunked=chunked,
                body_pos=body_pos,
                **response_kw
            )
    
        # Handle redirect?
        redirect_location = redirect and response.get_redirect_location()
        if redirect_location:
            if response.status == 303:
                method = &#34;GET&#34;
    
            try:
                retries = retries.increment(method, url, response=response, _pool=self)
            except MaxRetryError:
                if retries.raise_on_redirect:
                    response.drain_conn()
                    raise
                return response
    
            response.drain_conn()
            retries.sleep_for_retry(response)
            log.debug(&#34;Redirecting %s -&gt; %s&#34;, url, redirect_location)
            return self.urlopen(
                method,
                redirect_location,
                body,
                headers,
                retries=retries,
                redirect=redirect,
                assert_same_host=assert_same_host,
                timeout=timeout,
                pool_timeout=pool_timeout,
                release_conn=release_conn,
                chunked=chunked,
                body_pos=body_pos,
                **response_kw
            )
    
        # Check if we should retry the HTTP response.
        has_retry_after = bool(response.getheader(&#34;Retry-After&#34;))
        if retries.is_retry(method, response.status, has_retry_after):
            try:
&gt;               retries = retries.increment(method, url, response=response, _pool=self)

/usr/local/lib/python3.8/site-packages/urllib3/connectionpool.py:868: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Retry(total=0, connect=None, read=None, redirect=None, status=None)
method = &#39;GET&#39;
url = &#34;/api1/x3/erp/QAL/AOBJEXT(&#39;ZTRANSCO&#39;)?representation=AOBJEXT.%24details&#34;
response = &lt;urllib3.response.HTTPResponse object at 0x7f34c03531f0&gt;
error = None
_pool = &lt;urllib3.connectionpool.HTTPSConnectionPool object at 0x7f34c03daf10&gt;
_stacktrace = None

    def increment(
        self,
        method=None,
        url=None,
        response=None,
        error=None,
        _pool=None,
        _stacktrace=None,
    ):
        &#34;&#34;&#34;Return a new Retry object with incremented retry counters.
    
        :param response: A response object, or None, if the server did not
            return a response.
        :type response: :class:`~urllib3.response.HTTPResponse`
        :param Exception error: An error encountered during the request, or
            None if the response was received successfully.
    
        :return: A new ``Retry`` object.
        &#34;&#34;&#34;
        if self.total is False and error:
            # Disabled, indicate to re-raise the error.
            raise six.reraise(type(error), error, _stacktrace)
    
        total = self.total
        if total is not None:
            total -= 1
    
        connect = self.connect
        read = self.read
        redirect = self.redirect
        status_count = self.status
        other = self.other
        cause = &#34;unknown&#34;
        status = None
        redirect_location = None
    
        if error and self._is_connection_error(error):
            # Connect retry?
            if connect is False:
                raise six.reraise(type(error), error, _stacktrace)
            elif connect is not None:
                connect -= 1
    
        elif error and self._is_read_error(error):
            # Read retry?
            if read is False or not self._is_method_retryable(method):
                raise six.reraise(type(error), error, _stacktrace)
            elif read is not None:
                read -= 1
    
        elif error:
            # Other retry?
            if other is not None:
                other -= 1
    
        elif response and response.get_redirect_location():
            # Redirect retry?
            if redirect is not None:
                redirect -= 1
            cause = &#34;too many redirects&#34;
            redirect_location = response.get_redirect_location()
            status = response.status
    
        else:
            # Incrementing because of a server error like a 500 in
            # status_forcelist and the given method is in the allowed_methods
            cause = ResponseError.GENERIC_ERROR
            if response and response.status:
                if status_count is not None:
                    status_count -= 1
                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)
                status = response.status
    
        history = self.history + (
            RequestHistory(method, url, error, status, redirect_location),
        )
    
        new_retry = self.new(
            total=total,
            connect=connect,
            read=read,
            redirect=redirect,
            status=status_count,
            other=other,
            history=history,
        )
    
        if new_retry.is_exhausted():
&gt;           raise MaxRetryError(_pool, url, error or ResponseError(cause))
E           urllib3.exceptions.MaxRetryError: HTTPSConnectionPool(host=&#39;sagex3-horsprod.covage.com&#39;, port=443): Max retries exceeded with url: /api1/x3/erp/QAL/AOBJEXT(&#39;ZTRANSCO&#39;)?representation=AOBJEXT.%24details (Caused by ResponseError(&#39;too many 502 error responses&#39;))

/usr/local/lib/python3.8/site-packages/urllib3/util/retry.py:592: MaxRetryError

During handling of the above exception, another exception occurred:

folder = &#39;QAL&#39;

    @pytest.mark.livetest
    @pytest.mark.xfail
    @pytest.mark.parametrize(&#34;folder&#34;, [os.environ[&#34;LIVE_TEST_X3_FOLDER&#34;]])
    def test_validate_schema_ZTRANSCO(folder):
        &#34;&#34;&#34;
        Compare diff for `ZTRANSCO` model between local snapshot and os.environ[&#34;LIVE_TEST_X3_FOLDER&#34;]\n
        ZTRANSCO: Transcoding data export
        &#34;&#34;&#34;
&gt;       destination = get_model_schema_from_x3(&#34;ZTRANSCO&#34;, folder=folder)

app/api/live_tests/test_validate_import_schema.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
app/api/live_tests/test_validate_import_schema.py:31: in get_model_schema_from_x3
    resp = client.get(class_name=&#34;AOBJEXT&#34;, representation=&#34;AOBJEXT&#34;, ref=model_name)
app/x3_wrapper/rest_client.py:109: in get
    resp = self._cal_x3(&#34;GET&#34;, url, query_params)
app/x3_wrapper/rest_client.py:70: in _cal_x3
    resp = self.client.request(method, url, params=query_params)
/usr/local/lib/python3.8/site-packages/requests/sessions.py:587: in request
    resp = self.send(prep, **send_kwargs)
/usr/local/lib/python3.8/site-packages/requests/sessions.py:701: in send
    r = adapter.send(request, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;requests.adapters.HTTPAdapter object at 0x7f34c03a3e50&gt;
request = &lt;PreparedRequest [GET]&gt;, stream = False
timeout = Timeout(connect=None, read=None, total=None), verify = True
cert = None
proxies = OrderedDict([(&#39;no&#39;, &#39;gitlab-runner-cache-01-prd.nut.covage.com&#39;), (&#39;http&#39;, &#39;http://squid.kosc.net:3128&#39;), (&#39;https&#39;, &#39;http://squid.kosc.net:3128&#39;)])

    def send(
        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None
    ):
        &#34;&#34;&#34;Sends PreparedRequest object. Returns Response object.
    
        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.
        :param stream: (optional) Whether to stream the request content.
        :param timeout: (optional) How long to wait for the server to send
            data before giving up, as a float, or a :ref:`(connect timeout,
            read timeout) &lt;timeouts&gt;` tuple.
        :type timeout: float or tuple or urllib3 Timeout object
        :param verify: (optional) Either a boolean, in which case it controls whether
            we verify the server&#39;s TLS certificate, or a string, in which case it
            must be a path to a CA bundle to use
        :param cert: (optional) Any user-provided SSL certificate to be trusted.
        :param proxies: (optional) The proxies dictionary to apply to the request.
        :rtype: requests.Response
        &#34;&#34;&#34;
    
        try:
            conn = self.get_connection(request.url, proxies)
        except LocationValueError as e:
            raise InvalidURL(e, request=request)
    
        self.cert_verify(conn, request.url, verify, cert)
        url = self.request_url(request, proxies)
        self.add_headers(
            request,
            stream=stream,
            timeout=timeout,
            verify=verify,
            cert=cert,
            proxies=proxies,
        )
    
        chunked = not (request.body is None or &#34;Content-Length&#34; in request.headers)
    
        if isinstance(timeout, tuple):
            try:
                connect, read = timeout
                timeout = TimeoutSauce(connect=connect, read=read)
            except ValueError:
                raise ValueError(
                    f&#34;Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, &#34;
                    f&#34;or a single float to set both timeouts to the same value.&#34;
                )
        elif isinstance(timeout, TimeoutSauce):
            pass
        else:
            timeout = TimeoutSauce(connect=timeout, read=timeout)
    
        try:
            if not chunked:
                resp = conn.urlopen(
                    method=request.method,
                    url=url,
                    body=request.body,
                    headers=request.headers,
                    redirect=False,
                    assert_same_host=False,
                    preload_content=False,
                    decode_content=False,
                    retries=self.max_retries,
                    timeout=timeout,
                )
    
            # Send the request.
            else:
                if hasattr(conn, &#34;proxy_pool&#34;):
                    conn = conn.proxy_pool
    
                low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)
    
                try:
                    skip_host = &#34;Host&#34; in request.headers
                    low_conn.putrequest(
                        request.method,
                        url,
                        skip_accept_encoding=True,
                        skip_host=skip_host,
                    )
    
                    for header, value in request.headers.items():
                        low_conn.putheader(header, value)
    
                    low_conn.endheaders()
    
                    for i in request.body:
                        low_conn.send(hex(len(i))[2:].encode(&#34;utf-8&#34;))
                        low_conn.send(b&#34;\r\n&#34;)
                        low_conn.send(i)
                        low_conn.send(b&#34;\r\n&#34;)
                    low_conn.send(b&#34;0\r\n\r\n&#34;)
    
                    # Receive the response from the server
                    r = low_conn.getresponse()
    
                    resp = HTTPResponse.from_httplib(
                        r,
                        pool=conn,
                        connection=low_conn,
                        preload_content=False,
                        decode_content=False,
                    )
                except Exception:
                    # If we hit any problems here, clean up the connection.
                    # Then, raise so that we can handle the actual exception.
                    low_conn.close()
                    raise
    
        except (ProtocolError, OSError) as err:
            raise ConnectionError(err, request=request)
    
        except MaxRetryError as e:
            if isinstance(e.reason, ConnectTimeoutError):
                # TODO: Remove this in 3.0.0: see #2811
                if not isinstance(e.reason, NewConnectionError):
                    raise ConnectTimeout(e, request=request)
    
            if isinstance(e.reason, ResponseError):
&gt;               raise RetryError(e, request=request)
E               requests.exceptions.RetryError: HTTPSConnectionPool(host=&#39;sagex3-horsprod.covage.com&#39;, port=443): Max retries exceeded with url: /api1/x3/erp/QAL/AOBJEXT(&#39;ZTRANSCO&#39;)?representation=AOBJEXT.%24details (Caused by ResponseError(&#39;too many 502 error responses&#39;))

/usr/local/lib/python3.8/site-packages/requests/adapters.py:556: RetryError</pre> </div> </div> </details> <details class="phase teardown "> <summary> <h4 class=title> <span class=phase-name>Teardown</span> </h4> </summary> <div class=content> </div> </details> </div> </div> </details> <details class="test xfailed"> <summary> <h3 class="title test-title"> <span class="status badge xfailed ">XFAIL</span> <span class=test-name> <span class=funcname>test_validate_schema_WYXOHACT</span><span class=params>[QAL]</span> </span> <span class=duration>0:00:00.680765</span> </h3> </summary> <div class=content> <div class=documentation> <p>Compare diff for <cite>WYXOHACT</cite> model between local snapshot and os.environ[&quot;LIVE_TEST_X3_FOLDER&quot;]</p> <p>WYXOHACT: Activate contract</p> </div> <table class=metadata> <tr> <th>Started</th> <td>2023-06-30 01:14:36</td> </tr> <tr> <th>Ended</th> <td>2023-06-30 01:14:37</td> </tr> <tr> <th>Duration</th> <td>0:00:00.680765</td> </tr> <tr> <th>Markers</th> <td> <div class=marker> <span class="marker-name badge">xfail</span> <span class=marker-args> </span> </div> <div class=marker> <span class="marker-name badge">livetest</span> <span class=marker-args> </span> </div> </td> </tr> <tr> <th>Fixtures</th> <td> <span class="badge fixturename"> django_test_environment </span> <span class="badge fixturename"> django_db_blocker </span> <span class="badge fixturename"> folder </span> <span class="badge fixturename"> request </span> </td> </tr> </table> <div class=repr> <pre>requests.exceptions.RetryError: HTTPSConnectionPool(host=&#39;sagex3-horsprod.covage.com&#39;, port=443): Max retries exceeded with url: /api1/x3/erp/QAL/AOBJEXT(&#39;WYXOHACT&#39;)?representation=AOBJEXT.%24details (Caused by ResponseError(&#39;too many 502 error responses&#39;))</pre> </div> <div class=test-phases> <details class="phase setup "> <summary> <h4 class=title> <span class=phase-name>Setup</span> </h4> </summary> <div class=content> </div> </details> <details class="phase call xfailed" open> <summary> <h4 class=title> <span class="status  xfailed"></span> <span class=phase-name>Call</span> </h4> </summary> <div class=content> <div class=repr> <pre>self = &lt;requests.adapters.HTTPAdapter object at 0x7f34c15042e0&gt;
request = &lt;PreparedRequest [GET]&gt;, stream = False
timeout = Timeout(connect=None, read=None, total=None), verify = True
cert = None
proxies = OrderedDict([(&#39;no&#39;, &#39;gitlab-runner-cache-01-prd.nut.covage.com&#39;), (&#39;http&#39;, &#39;http://squid.kosc.net:3128&#39;), (&#39;https&#39;, &#39;http://squid.kosc.net:3128&#39;)])

    def send(
        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None
    ):
        &#34;&#34;&#34;Sends PreparedRequest object. Returns Response object.
    
        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.
        :param stream: (optional) Whether to stream the request content.
        :param timeout: (optional) How long to wait for the server to send
            data before giving up, as a float, or a :ref:`(connect timeout,
            read timeout) &lt;timeouts&gt;` tuple.
        :type timeout: float or tuple or urllib3 Timeout object
        :param verify: (optional) Either a boolean, in which case it controls whether
            we verify the server&#39;s TLS certificate, or a string, in which case it
            must be a path to a CA bundle to use
        :param cert: (optional) Any user-provided SSL certificate to be trusted.
        :param proxies: (optional) The proxies dictionary to apply to the request.
        :rtype: requests.Response
        &#34;&#34;&#34;
    
        try:
            conn = self.get_connection(request.url, proxies)
        except LocationValueError as e:
            raise InvalidURL(e, request=request)
    
        self.cert_verify(conn, request.url, verify, cert)
        url = self.request_url(request, proxies)
        self.add_headers(
            request,
            stream=stream,
            timeout=timeout,
            verify=verify,
            cert=cert,
            proxies=proxies,
        )
    
        chunked = not (request.body is None or &#34;Content-Length&#34; in request.headers)
    
        if isinstance(timeout, tuple):
            try:
                connect, read = timeout
                timeout = TimeoutSauce(connect=connect, read=read)
            except ValueError:
                raise ValueError(
                    f&#34;Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, &#34;
                    f&#34;or a single float to set both timeouts to the same value.&#34;
                )
        elif isinstance(timeout, TimeoutSauce):
            pass
        else:
            timeout = TimeoutSauce(connect=timeout, read=timeout)
    
        try:
            if not chunked:
&gt;               resp = conn.urlopen(
                    method=request.method,
                    url=url,
                    body=request.body,
                    headers=request.headers,
                    redirect=False,
                    assert_same_host=False,
                    preload_content=False,
                    decode_content=False,
                    retries=self.max_retries,
                    timeout=timeout,
                )

/usr/local/lib/python3.8/site-packages/requests/adapters.py:489: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connectionpool.HTTPSConnectionPool object at 0x7f34c1504610&gt;
method = &#39;GET&#39;
url = &#34;/api1/x3/erp/QAL/AOBJEXT(&#39;WYXOHACT&#39;)?representation=AOBJEXT.%24details&#34;
body = None
headers = {&#39;User-Agent&#39;: &#39;python-requests/2.28.1&#39;, &#39;Accept-Encoding&#39;: &#39;gzip, deflate&#39;, &#39;Accept&#39;: &#39;*/*&#39;, &#39;Connection&#39;: &#39;keep-alive&#39;, &#39;Content-Type&#39;: &#39;application/json&#39;, &#39;Authorization&#39;: &#39;Basic aW50cmFjbzpXYXNzaW1Db3ZhZ2VA&#39;}
retries = Retry(total=2, connect=None, read=None, redirect=None, status=None)
redirect = False, assert_same_host = False
timeout = Timeout(connect=None, read=None, total=None), pool_timeout = None
release_conn = False, chunked = False, body_pos = None
response_kw = {&#39;decode_content&#39;: False, &#39;preload_content&#39;: False, &#39;request_method&#39;: &#39;GET&#39;}
parsed_url = Url(scheme=None, auth=None, host=None, port=None, path=&#34;/api1/x3/erp/QAL/AOBJEXT(&#39;WYXOHACT&#39;)&#34;, query=&#39;representation=AOBJEXT.%24details&#39;, fragment=None)
destination_scheme = None
conn = &lt;urllib3.connection.HTTPSConnection object at 0x7f34c1504250&gt;
release_this_conn = False, http_tunnel_required = True, err = None
clean_exit = True

    def urlopen(
        self,
        method,
        url,
        body=None,
        headers=None,
        retries=None,
        redirect=True,
        assert_same_host=True,
        timeout=_Default,
        pool_timeout=None,
        release_conn=None,
        chunked=False,
        body_pos=None,
        **response_kw
    ):
        &#34;&#34;&#34;
        Get a connection from the pool and perform an HTTP request. This is the
        lowest level call for making a request, so you&#39;ll need to specify all
        the raw details.
    
        .. note::
    
           More commonly, it&#39;s appropriate to use a convenience method provided
           by :class:`.RequestMethods`, such as :meth:`request`.
    
        .. note::
    
           `release_conn` will only behave as expected if
           `preload_content=False` because we want to make
           `preload_content=False` the default behaviour someday soon without
           breaking backwards compatibility.
    
        :param method:
            HTTP request method (such as GET, POST, PUT, etc.)
    
        :param url:
            The URL to perform the request on.
    
        :param body:
            Data to send in the request body, either :class:`str`, :class:`bytes`,
            an iterable of :class:`str`/:class:`bytes`, or a file-like object.
    
        :param headers:
            Dictionary of custom headers to send, such as User-Agent,
            If-None-Match, etc. If None, pool headers are used. If provided,
            these headers completely replace any pool-specific headers.
    
        :param retries:
            Configure the number of retries to allow before raising a
            :class:`~urllib3.exceptions.MaxRetryError` exception.
    
            Pass ``None`` to retry until you receive a response. Pass a
            :class:`~urllib3.util.retry.Retry` object for fine-grained control
            over different types of retries.
            Pass an integer number to retry connection errors that many times,
            but no other types of errors. Pass zero to never retry.
    
            If ``False``, then retries are disabled and any exception is raised
            immediately. Also, instead of raising a MaxRetryError on redirects,
            the redirect response will be returned.
    
        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.
    
        :param redirect:
            If True, automatically handle redirects (status codes 301, 302,
            303, 307, 308). Each redirect counts as a retry. Disabling retries
            will disable redirect, too.
    
        :param assert_same_host:
            If ``True``, will make sure that the host of the pool requests is
            consistent else will raise HostChangedError. When ``False``, you can
            use the pool on an HTTP proxy and request foreign hosts.
    
        :param timeout:
            If specified, overrides the default timeout for this one
            request. It may be a float (in seconds) or an instance of
            :class:`urllib3.util.Timeout`.
    
        :param pool_timeout:
            If set and the pool is set to block=True, then this method will
            block for ``pool_timeout`` seconds and raise EmptyPoolError if no
            connection is available within the time period.
    
        :param release_conn:
            If False, then the urlopen call will not release the connection
            back into the pool once a response is received (but will release if
            you read the entire contents of the response such as when
            `preload_content=True`). This is useful if you&#39;re not preloading
            the response&#39;s content immediately. You will need to call
            ``r.release_conn()`` on the response ``r`` to return the connection
            back into the pool. If None, it takes the value of
            ``response_kw.get(&#39;preload_content&#39;, True)``.
    
        :param chunked:
            If True, urllib3 will send the body using chunked transfer
            encoding. Otherwise, urllib3 will send the body using the standard
            content-length form. Defaults to False.
    
        :param int body_pos:
            Position to seek to in file-like body in the event of a retry or
            redirect. Typically this won&#39;t need to be set because urllib3 will
            auto-populate the value when needed.
    
        :param \\**response_kw:
            Additional parameters are passed to
            :meth:`urllib3.response.HTTPResponse.from_httplib`
        &#34;&#34;&#34;
    
        parsed_url = parse_url(url)
        destination_scheme = parsed_url.scheme
    
        if headers is None:
            headers = self.headers
    
        if not isinstance(retries, Retry):
            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)
    
        if release_conn is None:
            release_conn = response_kw.get(&#34;preload_content&#34;, True)
    
        # Check host
        if assert_same_host and not self.is_same_host(url):
            raise HostChangedError(self, url, retries)
    
        # Ensure that the URL we&#39;re connecting to is properly encoded
        if url.startswith(&#34;/&#34;):
            url = six.ensure_str(_encode_target(url))
        else:
            url = six.ensure_str(parsed_url.url)
    
        conn = None
    
        # Track whether `conn` needs to be released before
        # returning/raising/recursing. Update this variable if necessary, and
        # leave `release_conn` constant throughout the function. That way, if
        # the function recurses, the original value of `release_conn` will be
        # passed down into the recursive call, and its value will be respected.
        #
        # See issue #651 [1] for details.
        #
        # [1] &lt;https://github.com/urllib3/urllib3/issues/651&gt;
        release_this_conn = release_conn
    
        http_tunnel_required = connection_requires_http_tunnel(
            self.proxy, self.proxy_config, destination_scheme
        )
    
        # Merge the proxy headers. Only done when not using HTTP CONNECT. We
        # have to copy the headers dict so we can safely change it without those
        # changes being reflected in anyone else&#39;s copy.
        if not http_tunnel_required:
            headers = headers.copy()
            headers.update(self.proxy_headers)
    
        # Must keep the exception bound to a separate variable or else Python 3
        # complains about UnboundLocalError.
        err = None
    
        # Keep track of whether we cleanly exited the except block. This
        # ensures we do proper cleanup in finally.
        clean_exit = False
    
        # Rewind body position, if needed. Record current position
        # for future rewinds in the event of a redirect/retry.
        body_pos = set_file_position(body, body_pos)
    
        try:
            # Request a connection from the queue.
            timeout_obj = self._get_timeout(timeout)
            conn = self._get_conn(timeout=pool_timeout)
    
            conn.timeout = timeout_obj.connect_timeout
    
            is_new_proxy_conn = self.proxy is not None and not getattr(
                conn, &#34;sock&#34;, None
            )
            if is_new_proxy_conn and http_tunnel_required:
                self._prepare_proxy(conn)
    
            # Make the request on the httplib connection object.
            httplib_response = self._make_request(
                conn,
                method,
                url,
                timeout=timeout_obj,
                body=body,
                headers=headers,
                chunked=chunked,
            )
    
            # If we&#39;re going to release the connection in ``finally:``, then
            # the response doesn&#39;t need to know about the connection. Otherwise
            # it will also try to release it and we&#39;ll have a double-release
            # mess.
            response_conn = conn if not release_conn else None
    
            # Pass method to Response for length checking
            response_kw[&#34;request_method&#34;] = method
    
            # Import httplib&#39;s response into our own wrapper object
            response = self.ResponseCls.from_httplib(
                httplib_response,
                pool=self,
                connection=response_conn,
                retries=retries,
                **response_kw
            )
    
            # Everything went great!
            clean_exit = True
    
        except EmptyPoolError:
            # Didn&#39;t get a connection from the pool, no need to clean up
            clean_exit = True
            release_this_conn = False
            raise
    
        except (
            TimeoutError,
            HTTPException,
            SocketError,
            ProtocolError,
            BaseSSLError,
            SSLError,
            CertificateError,
        ) as e:
            # Discard the connection for these exceptions. It will be
            # replaced during the next _get_conn() call.
            clean_exit = False
    
            def _is_ssl_error_message_from_http_proxy(ssl_error):
                # We&#39;re trying to detect the message &#39;WRONG_VERSION_NUMBER&#39; but
                # SSLErrors are kinda all over the place when it comes to the message,
                # so we try to cover our bases here!
                message = &#34; &#34;.join(re.split(&#34;[^a-z]&#34;, str(ssl_error).lower()))
                return (
                    &#34;wrong version number&#34; in message or &#34;unknown protocol&#34; in message
                )
    
            # Try to detect a common user error with proxies which is to
            # set an HTTP proxy to be HTTPS when it should be &#39;http://&#39;
            # (ie {&#39;http&#39;: &#39;http://proxy&#39;, &#39;https&#39;: &#39;https://proxy&#39;})
            # Instead we add a nice error message and point to a URL.
            if (
                isinstance(e, BaseSSLError)
                and self.proxy
                and _is_ssl_error_message_from_http_proxy(e)
                and conn.proxy
                and conn.proxy.scheme == &#34;https&#34;
            ):
                e = ProxyError(
                    &#34;Your proxy appears to only use HTTP and not HTTPS, &#34;
                    &#34;try changing your proxy URL to be HTTP. See: &#34;
                    &#34;https://urllib3.readthedocs.io/en/1.26.x/advanced-usage.html&#34;
                    &#34;#https-proxy-error-http-proxy&#34;,
                    SSLError(e),
                )
            elif isinstance(e, (BaseSSLError, CertificateError)):
                e = SSLError(e)
            elif isinstance(e, (SocketError, NewConnectionError)) and self.proxy:
                e = ProxyError(&#34;Cannot connect to proxy.&#34;, e)
            elif isinstance(e, (SocketError, HTTPException)):
                e = ProtocolError(&#34;Connection aborted.&#34;, e)
    
            retries = retries.increment(
                method, url, error=e, _pool=self, _stacktrace=sys.exc_info()[2]
            )
            retries.sleep()
    
            # Keep track of the error for the retry warning.
            err = e
    
        finally:
            if not clean_exit:
                # We hit some kind of exception, handled or otherwise. We need
                # to throw the connection away unless explicitly told not to.
                # Close the connection, set the variable to None, and make sure
                # we put the None back in the pool to avoid leaking it.
                conn = conn and conn.close()
                release_this_conn = True
    
            if release_this_conn:
                # Put the connection back to be reused. If the connection is
                # expired then it will be None, which will get replaced with a
                # fresh connection during _get_conn.
                self._put_conn(conn)
    
        if not conn:
            # Try again
            log.warning(
                &#34;Retrying (%r) after connection broken by &#39;%r&#39;: %s&#34;, retries, err, url
            )
            return self.urlopen(
                method,
                url,
                body,
                headers,
                retries,
                redirect,
                assert_same_host,
                timeout=timeout,
                pool_timeout=pool_timeout,
                release_conn=release_conn,
                chunked=chunked,
                body_pos=body_pos,
                **response_kw
            )
    
        # Handle redirect?
        redirect_location = redirect and response.get_redirect_location()
        if redirect_location:
            if response.status == 303:
                method = &#34;GET&#34;
    
            try:
                retries = retries.increment(method, url, response=response, _pool=self)
            except MaxRetryError:
                if retries.raise_on_redirect:
                    response.drain_conn()
                    raise
                return response
    
            response.drain_conn()
            retries.sleep_for_retry(response)
            log.debug(&#34;Redirecting %s -&gt; %s&#34;, url, redirect_location)
            return self.urlopen(
                method,
                redirect_location,
                body,
                headers,
                retries=retries,
                redirect=redirect,
                assert_same_host=assert_same_host,
                timeout=timeout,
                pool_timeout=pool_timeout,
                release_conn=release_conn,
                chunked=chunked,
                body_pos=body_pos,
                **response_kw
            )
    
        # Check if we should retry the HTTP response.
        has_retry_after = bool(response.getheader(&#34;Retry-After&#34;))
        if retries.is_retry(method, response.status, has_retry_after):
            try:
                retries = retries.increment(method, url, response=response, _pool=self)
            except MaxRetryError:
                if retries.raise_on_status:
                    response.drain_conn()
                    raise
                return response
    
            response.drain_conn()
            retries.sleep(response)
            log.debug(&#34;Retry: %s&#34;, url)
&gt;           return self.urlopen(
                method,
                url,
                body,
                headers,
                retries=retries,
                redirect=redirect,
                assert_same_host=assert_same_host,
                timeout=timeout,
                pool_timeout=pool_timeout,
                release_conn=release_conn,
                chunked=chunked,
                body_pos=body_pos,
                **response_kw
            )

/usr/local/lib/python3.8/site-packages/urllib3/connectionpool.py:878: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connectionpool.HTTPSConnectionPool object at 0x7f34c1504610&gt;
method = &#39;GET&#39;
url = &#34;/api1/x3/erp/QAL/AOBJEXT(&#39;WYXOHACT&#39;)?representation=AOBJEXT.%24details&#34;
body = None
headers = {&#39;User-Agent&#39;: &#39;python-requests/2.28.1&#39;, &#39;Accept-Encoding&#39;: &#39;gzip, deflate&#39;, &#39;Accept&#39;: &#39;*/*&#39;, &#39;Connection&#39;: &#39;keep-alive&#39;, &#39;Content-Type&#39;: &#39;application/json&#39;, &#39;Authorization&#39;: &#39;Basic aW50cmFjbzpXYXNzaW1Db3ZhZ2VA&#39;}
retries = Retry(total=1, connect=None, read=None, redirect=None, status=None)
redirect = False, assert_same_host = False
timeout = Timeout(connect=None, read=None, total=None), pool_timeout = None
release_conn = False, chunked = False, body_pos = None
response_kw = {&#39;decode_content&#39;: False, &#39;preload_content&#39;: False, &#39;request_method&#39;: &#39;GET&#39;}
parsed_url = Url(scheme=None, auth=None, host=None, port=None, path=&#34;/api1/x3/erp/QAL/AOBJEXT(&#39;WYXOHACT&#39;)&#34;, query=&#39;representation=AOBJEXT.%24details&#39;, fragment=None)
destination_scheme = None
conn = &lt;urllib3.connection.HTTPSConnection object at 0x7f34c1504250&gt;
release_this_conn = False, http_tunnel_required = True, err = None
clean_exit = True

    def urlopen(
        self,
        method,
        url,
        body=None,
        headers=None,
        retries=None,
        redirect=True,
        assert_same_host=True,
        timeout=_Default,
        pool_timeout=None,
        release_conn=None,
        chunked=False,
        body_pos=None,
        **response_kw
    ):
        &#34;&#34;&#34;
        Get a connection from the pool and perform an HTTP request. This is the
        lowest level call for making a request, so you&#39;ll need to specify all
        the raw details.
    
        .. note::
    
           More commonly, it&#39;s appropriate to use a convenience method provided
           by :class:`.RequestMethods`, such as :meth:`request`.
    
        .. note::
    
           `release_conn` will only behave as expected if
           `preload_content=False` because we want to make
           `preload_content=False` the default behaviour someday soon without
           breaking backwards compatibility.
    
        :param method:
            HTTP request method (such as GET, POST, PUT, etc.)
    
        :param url:
            The URL to perform the request on.
    
        :param body:
            Data to send in the request body, either :class:`str`, :class:`bytes`,
            an iterable of :class:`str`/:class:`bytes`, or a file-like object.
    
        :param headers:
            Dictionary of custom headers to send, such as User-Agent,
            If-None-Match, etc. If None, pool headers are used. If provided,
            these headers completely replace any pool-specific headers.
    
        :param retries:
            Configure the number of retries to allow before raising a
            :class:`~urllib3.exceptions.MaxRetryError` exception.
    
            Pass ``None`` to retry until you receive a response. Pass a
            :class:`~urllib3.util.retry.Retry` object for fine-grained control
            over different types of retries.
            Pass an integer number to retry connection errors that many times,
            but no other types of errors. Pass zero to never retry.
    
            If ``False``, then retries are disabled and any exception is raised
            immediately. Also, instead of raising a MaxRetryError on redirects,
            the redirect response will be returned.
    
        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.
    
        :param redirect:
            If True, automatically handle redirects (status codes 301, 302,
            303, 307, 308). Each redirect counts as a retry. Disabling retries
            will disable redirect, too.
    
        :param assert_same_host:
            If ``True``, will make sure that the host of the pool requests is
            consistent else will raise HostChangedError. When ``False``, you can
            use the pool on an HTTP proxy and request foreign hosts.
    
        :param timeout:
            If specified, overrides the default timeout for this one
            request. It may be a float (in seconds) or an instance of
            :class:`urllib3.util.Timeout`.
    
        :param pool_timeout:
            If set and the pool is set to block=True, then this method will
            block for ``pool_timeout`` seconds and raise EmptyPoolError if no
            connection is available within the time period.
    
        :param release_conn:
            If False, then the urlopen call will not release the connection
            back into the pool once a response is received (but will release if
            you read the entire contents of the response such as when
            `preload_content=True`). This is useful if you&#39;re not preloading
            the response&#39;s content immediately. You will need to call
            ``r.release_conn()`` on the response ``r`` to return the connection
            back into the pool. If None, it takes the value of
            ``response_kw.get(&#39;preload_content&#39;, True)``.
    
        :param chunked:
            If True, urllib3 will send the body using chunked transfer
            encoding. Otherwise, urllib3 will send the body using the standard
            content-length form. Defaults to False.
    
        :param int body_pos:
            Position to seek to in file-like body in the event of a retry or
            redirect. Typically this won&#39;t need to be set because urllib3 will
            auto-populate the value when needed.
    
        :param \\**response_kw:
            Additional parameters are passed to
            :meth:`urllib3.response.HTTPResponse.from_httplib`
        &#34;&#34;&#34;
    
        parsed_url = parse_url(url)
        destination_scheme = parsed_url.scheme
    
        if headers is None:
            headers = self.headers
    
        if not isinstance(retries, Retry):
            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)
    
        if release_conn is None:
            release_conn = response_kw.get(&#34;preload_content&#34;, True)
    
        # Check host
        if assert_same_host and not self.is_same_host(url):
            raise HostChangedError(self, url, retries)
    
        # Ensure that the URL we&#39;re connecting to is properly encoded
        if url.startswith(&#34;/&#34;):
            url = six.ensure_str(_encode_target(url))
        else:
            url = six.ensure_str(parsed_url.url)
    
        conn = None
    
        # Track whether `conn` needs to be released before
        # returning/raising/recursing. Update this variable if necessary, and
        # leave `release_conn` constant throughout the function. That way, if
        # the function recurses, the original value of `release_conn` will be
        # passed down into the recursive call, and its value will be respected.
        #
        # See issue #651 [1] for details.
        #
        # [1] &lt;https://github.com/urllib3/urllib3/issues/651&gt;
        release_this_conn = release_conn
    
        http_tunnel_required = connection_requires_http_tunnel(
            self.proxy, self.proxy_config, destination_scheme
        )
    
        # Merge the proxy headers. Only done when not using HTTP CONNECT. We
        # have to copy the headers dict so we can safely change it without those
        # changes being reflected in anyone else&#39;s copy.
        if not http_tunnel_required:
            headers = headers.copy()
            headers.update(self.proxy_headers)
    
        # Must keep the exception bound to a separate variable or else Python 3
        # complains about UnboundLocalError.
        err = None
    
        # Keep track of whether we cleanly exited the except block. This
        # ensures we do proper cleanup in finally.
        clean_exit = False
    
        # Rewind body position, if needed. Record current position
        # for future rewinds in the event of a redirect/retry.
        body_pos = set_file_position(body, body_pos)
    
        try:
            # Request a connection from the queue.
            timeout_obj = self._get_timeout(timeout)
            conn = self._get_conn(timeout=pool_timeout)
    
            conn.timeout = timeout_obj.connect_timeout
    
            is_new_proxy_conn = self.proxy is not None and not getattr(
                conn, &#34;sock&#34;, None
            )
            if is_new_proxy_conn and http_tunnel_required:
                self._prepare_proxy(conn)
    
            # Make the request on the httplib connection object.
            httplib_response = self._make_request(
                conn,
                method,
                url,
                timeout=timeout_obj,
                body=body,
                headers=headers,
                chunked=chunked,
            )
    
            # If we&#39;re going to release the connection in ``finally:``, then
            # the response doesn&#39;t need to know about the connection. Otherwise
            # it will also try to release it and we&#39;ll have a double-release
            # mess.
            response_conn = conn if not release_conn else None
    
            # Pass method to Response for length checking
            response_kw[&#34;request_method&#34;] = method
    
            # Import httplib&#39;s response into our own wrapper object
            response = self.ResponseCls.from_httplib(
                httplib_response,
                pool=self,
                connection=response_conn,
                retries=retries,
                **response_kw
            )
    
            # Everything went great!
            clean_exit = True
    
        except EmptyPoolError:
            # Didn&#39;t get a connection from the pool, no need to clean up
            clean_exit = True
            release_this_conn = False
            raise
    
        except (
            TimeoutError,
            HTTPException,
            SocketError,
            ProtocolError,
            BaseSSLError,
            SSLError,
            CertificateError,
        ) as e:
            # Discard the connection for these exceptions. It will be
            # replaced during the next _get_conn() call.
            clean_exit = False
    
            def _is_ssl_error_message_from_http_proxy(ssl_error):
                # We&#39;re trying to detect the message &#39;WRONG_VERSION_NUMBER&#39; but
                # SSLErrors are kinda all over the place when it comes to the message,
                # so we try to cover our bases here!
                message = &#34; &#34;.join(re.split(&#34;[^a-z]&#34;, str(ssl_error).lower()))
                return (
                    &#34;wrong version number&#34; in message or &#34;unknown protocol&#34; in message
                )
    
            # Try to detect a common user error with proxies which is to
            # set an HTTP proxy to be HTTPS when it should be &#39;http://&#39;
            # (ie {&#39;http&#39;: &#39;http://proxy&#39;, &#39;https&#39;: &#39;https://proxy&#39;})
            # Instead we add a nice error message and point to a URL.
            if (
                isinstance(e, BaseSSLError)
                and self.proxy
                and _is_ssl_error_message_from_http_proxy(e)
                and conn.proxy
                and conn.proxy.scheme == &#34;https&#34;
            ):
                e = ProxyError(
                    &#34;Your proxy appears to only use HTTP and not HTTPS, &#34;
                    &#34;try changing your proxy URL to be HTTP. See: &#34;
                    &#34;https://urllib3.readthedocs.io/en/1.26.x/advanced-usage.html&#34;
                    &#34;#https-proxy-error-http-proxy&#34;,
                    SSLError(e),
                )
            elif isinstance(e, (BaseSSLError, CertificateError)):
                e = SSLError(e)
            elif isinstance(e, (SocketError, NewConnectionError)) and self.proxy:
                e = ProxyError(&#34;Cannot connect to proxy.&#34;, e)
            elif isinstance(e, (SocketError, HTTPException)):
                e = ProtocolError(&#34;Connection aborted.&#34;, e)
    
            retries = retries.increment(
                method, url, error=e, _pool=self, _stacktrace=sys.exc_info()[2]
            )
            retries.sleep()
    
            # Keep track of the error for the retry warning.
            err = e
    
        finally:
            if not clean_exit:
                # We hit some kind of exception, handled or otherwise. We need
                # to throw the connection away unless explicitly told not to.
                # Close the connection, set the variable to None, and make sure
                # we put the None back in the pool to avoid leaking it.
                conn = conn and conn.close()
                release_this_conn = True
    
            if release_this_conn:
                # Put the connection back to be reused. If the connection is
                # expired then it will be None, which will get replaced with a
                # fresh connection during _get_conn.
                self._put_conn(conn)
    
        if not conn:
            # Try again
            log.warning(
                &#34;Retrying (%r) after connection broken by &#39;%r&#39;: %s&#34;, retries, err, url
            )
            return self.urlopen(
                method,
                url,
                body,
                headers,
                retries,
                redirect,
                assert_same_host,
                timeout=timeout,
                pool_timeout=pool_timeout,
                release_conn=release_conn,
                chunked=chunked,
                body_pos=body_pos,
                **response_kw
            )
    
        # Handle redirect?
        redirect_location = redirect and response.get_redirect_location()
        if redirect_location:
            if response.status == 303:
                method = &#34;GET&#34;
    
            try:
                retries = retries.increment(method, url, response=response, _pool=self)
            except MaxRetryError:
                if retries.raise_on_redirect:
                    response.drain_conn()
                    raise
                return response
    
            response.drain_conn()
            retries.sleep_for_retry(response)
            log.debug(&#34;Redirecting %s -&gt; %s&#34;, url, redirect_location)
            return self.urlopen(
                method,
                redirect_location,
                body,
                headers,
                retries=retries,
                redirect=redirect,
                assert_same_host=assert_same_host,
                timeout=timeout,
                pool_timeout=pool_timeout,
                release_conn=release_conn,
                chunked=chunked,
                body_pos=body_pos,
                **response_kw
            )
    
        # Check if we should retry the HTTP response.
        has_retry_after = bool(response.getheader(&#34;Retry-After&#34;))
        if retries.is_retry(method, response.status, has_retry_after):
            try:
                retries = retries.increment(method, url, response=response, _pool=self)
            except MaxRetryError:
                if retries.raise_on_status:
                    response.drain_conn()
                    raise
                return response
    
            response.drain_conn()
            retries.sleep(response)
            log.debug(&#34;Retry: %s&#34;, url)
&gt;           return self.urlopen(
                method,
                url,
                body,
                headers,
                retries=retries,
                redirect=redirect,
                assert_same_host=assert_same_host,
                timeout=timeout,
                pool_timeout=pool_timeout,
                release_conn=release_conn,
                chunked=chunked,
                body_pos=body_pos,
                **response_kw
            )

/usr/local/lib/python3.8/site-packages/urllib3/connectionpool.py:878: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connectionpool.HTTPSConnectionPool object at 0x7f34c1504610&gt;
method = &#39;GET&#39;
url = &#34;/api1/x3/erp/QAL/AOBJEXT(&#39;WYXOHACT&#39;)?representation=AOBJEXT.%24details&#34;
body = None
headers = {&#39;User-Agent&#39;: &#39;python-requests/2.28.1&#39;, &#39;Accept-Encoding&#39;: &#39;gzip, deflate&#39;, &#39;Accept&#39;: &#39;*/*&#39;, &#39;Connection&#39;: &#39;keep-alive&#39;, &#39;Content-Type&#39;: &#39;application/json&#39;, &#39;Authorization&#39;: &#39;Basic aW50cmFjbzpXYXNzaW1Db3ZhZ2VA&#39;}
retries = Retry(total=0, connect=None, read=None, redirect=None, status=None)
redirect = False, assert_same_host = False
timeout = Timeout(connect=None, read=None, total=None), pool_timeout = None
release_conn = False, chunked = False, body_pos = None
response_kw = {&#39;decode_content&#39;: False, &#39;preload_content&#39;: False, &#39;request_method&#39;: &#39;GET&#39;}
parsed_url = Url(scheme=None, auth=None, host=None, port=None, path=&#34;/api1/x3/erp/QAL/AOBJEXT(&#39;WYXOHACT&#39;)&#34;, query=&#39;representation=AOBJEXT.%24details&#39;, fragment=None)
destination_scheme = None
conn = &lt;urllib3.connection.HTTPSConnection object at 0x7f34c1504250&gt;
release_this_conn = False, http_tunnel_required = True, err = None
clean_exit = True

    def urlopen(
        self,
        method,
        url,
        body=None,
        headers=None,
        retries=None,
        redirect=True,
        assert_same_host=True,
        timeout=_Default,
        pool_timeout=None,
        release_conn=None,
        chunked=False,
        body_pos=None,
        **response_kw
    ):
        &#34;&#34;&#34;
        Get a connection from the pool and perform an HTTP request. This is the
        lowest level call for making a request, so you&#39;ll need to specify all
        the raw details.
    
        .. note::
    
           More commonly, it&#39;s appropriate to use a convenience method provided
           by :class:`.RequestMethods`, such as :meth:`request`.
    
        .. note::
    
           `release_conn` will only behave as expected if
           `preload_content=False` because we want to make
           `preload_content=False` the default behaviour someday soon without
           breaking backwards compatibility.
    
        :param method:
            HTTP request method (such as GET, POST, PUT, etc.)
    
        :param url:
            The URL to perform the request on.
    
        :param body:
            Data to send in the request body, either :class:`str`, :class:`bytes`,
            an iterable of :class:`str`/:class:`bytes`, or a file-like object.
    
        :param headers:
            Dictionary of custom headers to send, such as User-Agent,
            If-None-Match, etc. If None, pool headers are used. If provided,
            these headers completely replace any pool-specific headers.
    
        :param retries:
            Configure the number of retries to allow before raising a
            :class:`~urllib3.exceptions.MaxRetryError` exception.
    
            Pass ``None`` to retry until you receive a response. Pass a
            :class:`~urllib3.util.retry.Retry` object for fine-grained control
            over different types of retries.
            Pass an integer number to retry connection errors that many times,
            but no other types of errors. Pass zero to never retry.
    
            If ``False``, then retries are disabled and any exception is raised
            immediately. Also, instead of raising a MaxRetryError on redirects,
            the redirect response will be returned.
    
        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.
    
        :param redirect:
            If True, automatically handle redirects (status codes 301, 302,
            303, 307, 308). Each redirect counts as a retry. Disabling retries
            will disable redirect, too.
    
        :param assert_same_host:
            If ``True``, will make sure that the host of the pool requests is
            consistent else will raise HostChangedError. When ``False``, you can
            use the pool on an HTTP proxy and request foreign hosts.
    
        :param timeout:
            If specified, overrides the default timeout for this one
            request. It may be a float (in seconds) or an instance of
            :class:`urllib3.util.Timeout`.
    
        :param pool_timeout:
            If set and the pool is set to block=True, then this method will
            block for ``pool_timeout`` seconds and raise EmptyPoolError if no
            connection is available within the time period.
    
        :param release_conn:
            If False, then the urlopen call will not release the connection
            back into the pool once a response is received (but will release if
            you read the entire contents of the response such as when
            `preload_content=True`). This is useful if you&#39;re not preloading
            the response&#39;s content immediately. You will need to call
            ``r.release_conn()`` on the response ``r`` to return the connection
            back into the pool. If None, it takes the value of
            ``response_kw.get(&#39;preload_content&#39;, True)``.
    
        :param chunked:
            If True, urllib3 will send the body using chunked transfer
            encoding. Otherwise, urllib3 will send the body using the standard
            content-length form. Defaults to False.
    
        :param int body_pos:
            Position to seek to in file-like body in the event of a retry or
            redirect. Typically this won&#39;t need to be set because urllib3 will
            auto-populate the value when needed.
    
        :param \\**response_kw:
            Additional parameters are passed to
            :meth:`urllib3.response.HTTPResponse.from_httplib`
        &#34;&#34;&#34;
    
        parsed_url = parse_url(url)
        destination_scheme = parsed_url.scheme
    
        if headers is None:
            headers = self.headers
    
        if not isinstance(retries, Retry):
            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)
    
        if release_conn is None:
            release_conn = response_kw.get(&#34;preload_content&#34;, True)
    
        # Check host
        if assert_same_host and not self.is_same_host(url):
            raise HostChangedError(self, url, retries)
    
        # Ensure that the URL we&#39;re connecting to is properly encoded
        if url.startswith(&#34;/&#34;):
            url = six.ensure_str(_encode_target(url))
        else:
            url = six.ensure_str(parsed_url.url)
    
        conn = None
    
        # Track whether `conn` needs to be released before
        # returning/raising/recursing. Update this variable if necessary, and
        # leave `release_conn` constant throughout the function. That way, if
        # the function recurses, the original value of `release_conn` will be
        # passed down into the recursive call, and its value will be respected.
        #
        # See issue #651 [1] for details.
        #
        # [1] &lt;https://github.com/urllib3/urllib3/issues/651&gt;
        release_this_conn = release_conn
    
        http_tunnel_required = connection_requires_http_tunnel(
            self.proxy, self.proxy_config, destination_scheme
        )
    
        # Merge the proxy headers. Only done when not using HTTP CONNECT. We
        # have to copy the headers dict so we can safely change it without those
        # changes being reflected in anyone else&#39;s copy.
        if not http_tunnel_required:
            headers = headers.copy()
            headers.update(self.proxy_headers)
    
        # Must keep the exception bound to a separate variable or else Python 3
        # complains about UnboundLocalError.
        err = None
    
        # Keep track of whether we cleanly exited the except block. This
        # ensures we do proper cleanup in finally.
        clean_exit = False
    
        # Rewind body position, if needed. Record current position
        # for future rewinds in the event of a redirect/retry.
        body_pos = set_file_position(body, body_pos)
    
        try:
            # Request a connection from the queue.
            timeout_obj = self._get_timeout(timeout)
            conn = self._get_conn(timeout=pool_timeout)
    
            conn.timeout = timeout_obj.connect_timeout
    
            is_new_proxy_conn = self.proxy is not None and not getattr(
                conn, &#34;sock&#34;, None
            )
            if is_new_proxy_conn and http_tunnel_required:
                self._prepare_proxy(conn)
    
            # Make the request on the httplib connection object.
            httplib_response = self._make_request(
                conn,
                method,
                url,
                timeout=timeout_obj,
                body=body,
                headers=headers,
                chunked=chunked,
            )
    
            # If we&#39;re going to release the connection in ``finally:``, then
            # the response doesn&#39;t need to know about the connection. Otherwise
            # it will also try to release it and we&#39;ll have a double-release
            # mess.
            response_conn = conn if not release_conn else None
    
            # Pass method to Response for length checking
            response_kw[&#34;request_method&#34;] = method
    
            # Import httplib&#39;s response into our own wrapper object
            response = self.ResponseCls.from_httplib(
                httplib_response,
                pool=self,
                connection=response_conn,
                retries=retries,
                **response_kw
            )
    
            # Everything went great!
            clean_exit = True
    
        except EmptyPoolError:
            # Didn&#39;t get a connection from the pool, no need to clean up
            clean_exit = True
            release_this_conn = False
            raise
    
        except (
            TimeoutError,
            HTTPException,
            SocketError,
            ProtocolError,
            BaseSSLError,
            SSLError,
            CertificateError,
        ) as e:
            # Discard the connection for these exceptions. It will be
            # replaced during the next _get_conn() call.
            clean_exit = False
    
            def _is_ssl_error_message_from_http_proxy(ssl_error):
                # We&#39;re trying to detect the message &#39;WRONG_VERSION_NUMBER&#39; but
                # SSLErrors are kinda all over the place when it comes to the message,
                # so we try to cover our bases here!
                message = &#34; &#34;.join(re.split(&#34;[^a-z]&#34;, str(ssl_error).lower()))
                return (
                    &#34;wrong version number&#34; in message or &#34;unknown protocol&#34; in message
                )
    
            # Try to detect a common user error with proxies which is to
            # set an HTTP proxy to be HTTPS when it should be &#39;http://&#39;
            # (ie {&#39;http&#39;: &#39;http://proxy&#39;, &#39;https&#39;: &#39;https://proxy&#39;})
            # Instead we add a nice error message and point to a URL.
            if (
                isinstance(e, BaseSSLError)
                and self.proxy
                and _is_ssl_error_message_from_http_proxy(e)
                and conn.proxy
                and conn.proxy.scheme == &#34;https&#34;
            ):
                e = ProxyError(
                    &#34;Your proxy appears to only use HTTP and not HTTPS, &#34;
                    &#34;try changing your proxy URL to be HTTP. See: &#34;
                    &#34;https://urllib3.readthedocs.io/en/1.26.x/advanced-usage.html&#34;
                    &#34;#https-proxy-error-http-proxy&#34;,
                    SSLError(e),
                )
            elif isinstance(e, (BaseSSLError, CertificateError)):
                e = SSLError(e)
            elif isinstance(e, (SocketError, NewConnectionError)) and self.proxy:
                e = ProxyError(&#34;Cannot connect to proxy.&#34;, e)
            elif isinstance(e, (SocketError, HTTPException)):
                e = ProtocolError(&#34;Connection aborted.&#34;, e)
    
            retries = retries.increment(
                method, url, error=e, _pool=self, _stacktrace=sys.exc_info()[2]
            )
            retries.sleep()
    
            # Keep track of the error for the retry warning.
            err = e
    
        finally:
            if not clean_exit:
                # We hit some kind of exception, handled or otherwise. We need
                # to throw the connection away unless explicitly told not to.
                # Close the connection, set the variable to None, and make sure
                # we put the None back in the pool to avoid leaking it.
                conn = conn and conn.close()
                release_this_conn = True
    
            if release_this_conn:
                # Put the connection back to be reused. If the connection is
                # expired then it will be None, which will get replaced with a
                # fresh connection during _get_conn.
                self._put_conn(conn)
    
        if not conn:
            # Try again
            log.warning(
                &#34;Retrying (%r) after connection broken by &#39;%r&#39;: %s&#34;, retries, err, url
            )
            return self.urlopen(
                method,
                url,
                body,
                headers,
                retries,
                redirect,
                assert_same_host,
                timeout=timeout,
                pool_timeout=pool_timeout,
                release_conn=release_conn,
                chunked=chunked,
                body_pos=body_pos,
                **response_kw
            )
    
        # Handle redirect?
        redirect_location = redirect and response.get_redirect_location()
        if redirect_location:
            if response.status == 303:
                method = &#34;GET&#34;
    
            try:
                retries = retries.increment(method, url, response=response, _pool=self)
            except MaxRetryError:
                if retries.raise_on_redirect:
                    response.drain_conn()
                    raise
                return response
    
            response.drain_conn()
            retries.sleep_for_retry(response)
            log.debug(&#34;Redirecting %s -&gt; %s&#34;, url, redirect_location)
            return self.urlopen(
                method,
                redirect_location,
                body,
                headers,
                retries=retries,
                redirect=redirect,
                assert_same_host=assert_same_host,
                timeout=timeout,
                pool_timeout=pool_timeout,
                release_conn=release_conn,
                chunked=chunked,
                body_pos=body_pos,
                **response_kw
            )
    
        # Check if we should retry the HTTP response.
        has_retry_after = bool(response.getheader(&#34;Retry-After&#34;))
        if retries.is_retry(method, response.status, has_retry_after):
            try:
                retries = retries.increment(method, url, response=response, _pool=self)
            except MaxRetryError:
                if retries.raise_on_status:
                    response.drain_conn()
                    raise
                return response
    
            response.drain_conn()
            retries.sleep(response)
            log.debug(&#34;Retry: %s&#34;, url)
&gt;           return self.urlopen(
                method,
                url,
                body,
                headers,
                retries=retries,
                redirect=redirect,
                assert_same_host=assert_same_host,
                timeout=timeout,
                pool_timeout=pool_timeout,
                release_conn=release_conn,
                chunked=chunked,
                body_pos=body_pos,
                **response_kw
            )

/usr/local/lib/python3.8/site-packages/urllib3/connectionpool.py:878: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connectionpool.HTTPSConnectionPool object at 0x7f34c1504610&gt;
method = &#39;GET&#39;
url = &#34;/api1/x3/erp/QAL/AOBJEXT(&#39;WYXOHACT&#39;)?representation=AOBJEXT.%24details&#34;
body = None
headers = {&#39;User-Agent&#39;: &#39;python-requests/2.28.1&#39;, &#39;Accept-Encoding&#39;: &#39;gzip, deflate&#39;, &#39;Accept&#39;: &#39;*/*&#39;, &#39;Connection&#39;: &#39;keep-alive&#39;, &#39;Content-Type&#39;: &#39;application/json&#39;, &#39;Authorization&#39;: &#39;Basic aW50cmFjbzpXYXNzaW1Db3ZhZ2VA&#39;}
retries = Retry(total=0, connect=None, read=None, redirect=None, status=None)
redirect = False, assert_same_host = False
timeout = Timeout(connect=None, read=None, total=None), pool_timeout = None
release_conn = False, chunked = False, body_pos = None
response_kw = {&#39;decode_content&#39;: False, &#39;preload_content&#39;: False, &#39;request_method&#39;: &#39;GET&#39;}
parsed_url = Url(scheme=None, auth=None, host=None, port=None, path=&#34;/api1/x3/erp/QAL/AOBJEXT(&#39;WYXOHACT&#39;)&#34;, query=&#39;representation=AOBJEXT.%24details&#39;, fragment=None)
destination_scheme = None
conn = &lt;urllib3.connection.HTTPSConnection object at 0x7f34c1504250&gt;
release_this_conn = False, http_tunnel_required = True, err = None
clean_exit = True

    def urlopen(
        self,
        method,
        url,
        body=None,
        headers=None,
        retries=None,
        redirect=True,
        assert_same_host=True,
        timeout=_Default,
        pool_timeout=None,
        release_conn=None,
        chunked=False,
        body_pos=None,
        **response_kw
    ):
        &#34;&#34;&#34;
        Get a connection from the pool and perform an HTTP request. This is the
        lowest level call for making a request, so you&#39;ll need to specify all
        the raw details.
    
        .. note::
    
           More commonly, it&#39;s appropriate to use a convenience method provided
           by :class:`.RequestMethods`, such as :meth:`request`.
    
        .. note::
    
           `release_conn` will only behave as expected if
           `preload_content=False` because we want to make
           `preload_content=False` the default behaviour someday soon without
           breaking backwards compatibility.
    
        :param method:
            HTTP request method (such as GET, POST, PUT, etc.)
    
        :param url:
            The URL to perform the request on.
    
        :param body:
            Data to send in the request body, either :class:`str`, :class:`bytes`,
            an iterable of :class:`str`/:class:`bytes`, or a file-like object.
    
        :param headers:
            Dictionary of custom headers to send, such as User-Agent,
            If-None-Match, etc. If None, pool headers are used. If provided,
            these headers completely replace any pool-specific headers.
    
        :param retries:
            Configure the number of retries to allow before raising a
            :class:`~urllib3.exceptions.MaxRetryError` exception.
    
            Pass ``None`` to retry until you receive a response. Pass a
            :class:`~urllib3.util.retry.Retry` object for fine-grained control
            over different types of retries.
            Pass an integer number to retry connection errors that many times,
            but no other types of errors. Pass zero to never retry.
    
            If ``False``, then retries are disabled and any exception is raised
            immediately. Also, instead of raising a MaxRetryError on redirects,
            the redirect response will be returned.
    
        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.
    
        :param redirect:
            If True, automatically handle redirects (status codes 301, 302,
            303, 307, 308). Each redirect counts as a retry. Disabling retries
            will disable redirect, too.
    
        :param assert_same_host:
            If ``True``, will make sure that the host of the pool requests is
            consistent else will raise HostChangedError. When ``False``, you can
            use the pool on an HTTP proxy and request foreign hosts.
    
        :param timeout:
            If specified, overrides the default timeout for this one
            request. It may be a float (in seconds) or an instance of
            :class:`urllib3.util.Timeout`.
    
        :param pool_timeout:
            If set and the pool is set to block=True, then this method will
            block for ``pool_timeout`` seconds and raise EmptyPoolError if no
            connection is available within the time period.
    
        :param release_conn:
            If False, then the urlopen call will not release the connection
            back into the pool once a response is received (but will release if
            you read the entire contents of the response such as when
            `preload_content=True`). This is useful if you&#39;re not preloading
            the response&#39;s content immediately. You will need to call
            ``r.release_conn()`` on the response ``r`` to return the connection
            back into the pool. If None, it takes the value of
            ``response_kw.get(&#39;preload_content&#39;, True)``.
    
        :param chunked:
            If True, urllib3 will send the body using chunked transfer
            encoding. Otherwise, urllib3 will send the body using the standard
            content-length form. Defaults to False.
    
        :param int body_pos:
            Position to seek to in file-like body in the event of a retry or
            redirect. Typically this won&#39;t need to be set because urllib3 will
            auto-populate the value when needed.
    
        :param \\**response_kw:
            Additional parameters are passed to
            :meth:`urllib3.response.HTTPResponse.from_httplib`
        &#34;&#34;&#34;
    
        parsed_url = parse_url(url)
        destination_scheme = parsed_url.scheme
    
        if headers is None:
            headers = self.headers
    
        if not isinstance(retries, Retry):
            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)
    
        if release_conn is None:
            release_conn = response_kw.get(&#34;preload_content&#34;, True)
    
        # Check host
        if assert_same_host and not self.is_same_host(url):
            raise HostChangedError(self, url, retries)
    
        # Ensure that the URL we&#39;re connecting to is properly encoded
        if url.startswith(&#34;/&#34;):
            url = six.ensure_str(_encode_target(url))
        else:
            url = six.ensure_str(parsed_url.url)
    
        conn = None
    
        # Track whether `conn` needs to be released before
        # returning/raising/recursing. Update this variable if necessary, and
        # leave `release_conn` constant throughout the function. That way, if
        # the function recurses, the original value of `release_conn` will be
        # passed down into the recursive call, and its value will be respected.
        #
        # See issue #651 [1] for details.
        #
        # [1] &lt;https://github.com/urllib3/urllib3/issues/651&gt;
        release_this_conn = release_conn
    
        http_tunnel_required = connection_requires_http_tunnel(
            self.proxy, self.proxy_config, destination_scheme
        )
    
        # Merge the proxy headers. Only done when not using HTTP CONNECT. We
        # have to copy the headers dict so we can safely change it without those
        # changes being reflected in anyone else&#39;s copy.
        if not http_tunnel_required:
            headers = headers.copy()
            headers.update(self.proxy_headers)
    
        # Must keep the exception bound to a separate variable or else Python 3
        # complains about UnboundLocalError.
        err = None
    
        # Keep track of whether we cleanly exited the except block. This
        # ensures we do proper cleanup in finally.
        clean_exit = False
    
        # Rewind body position, if needed. Record current position
        # for future rewinds in the event of a redirect/retry.
        body_pos = set_file_position(body, body_pos)
    
        try:
            # Request a connection from the queue.
            timeout_obj = self._get_timeout(timeout)
            conn = self._get_conn(timeout=pool_timeout)
    
            conn.timeout = timeout_obj.connect_timeout
    
            is_new_proxy_conn = self.proxy is not None and not getattr(
                conn, &#34;sock&#34;, None
            )
            if is_new_proxy_conn and http_tunnel_required:
                self._prepare_proxy(conn)
    
            # Make the request on the httplib connection object.
            httplib_response = self._make_request(
                conn,
                method,
                url,
                timeout=timeout_obj,
                body=body,
                headers=headers,
                chunked=chunked,
            )
    
            # If we&#39;re going to release the connection in ``finally:``, then
            # the response doesn&#39;t need to know about the connection. Otherwise
            # it will also try to release it and we&#39;ll have a double-release
            # mess.
            response_conn = conn if not release_conn else None
    
            # Pass method to Response for length checking
            response_kw[&#34;request_method&#34;] = method
    
            # Import httplib&#39;s response into our own wrapper object
            response = self.ResponseCls.from_httplib(
                httplib_response,
                pool=self,
                connection=response_conn,
                retries=retries,
                **response_kw
            )
    
            # Everything went great!
            clean_exit = True
    
        except EmptyPoolError:
            # Didn&#39;t get a connection from the pool, no need to clean up
            clean_exit = True
            release_this_conn = False
            raise
    
        except (
            TimeoutError,
            HTTPException,
            SocketError,
            ProtocolError,
            BaseSSLError,
            SSLError,
            CertificateError,
        ) as e:
            # Discard the connection for these exceptions. It will be
            # replaced during the next _get_conn() call.
            clean_exit = False
    
            def _is_ssl_error_message_from_http_proxy(ssl_error):
                # We&#39;re trying to detect the message &#39;WRONG_VERSION_NUMBER&#39; but
                # SSLErrors are kinda all over the place when it comes to the message,
                # so we try to cover our bases here!
                message = &#34; &#34;.join(re.split(&#34;[^a-z]&#34;, str(ssl_error).lower()))
                return (
                    &#34;wrong version number&#34; in message or &#34;unknown protocol&#34; in message
                )
    
            # Try to detect a common user error with proxies which is to
            # set an HTTP proxy to be HTTPS when it should be &#39;http://&#39;
            # (ie {&#39;http&#39;: &#39;http://proxy&#39;, &#39;https&#39;: &#39;https://proxy&#39;})
            # Instead we add a nice error message and point to a URL.
            if (
                isinstance(e, BaseSSLError)
                and self.proxy
                and _is_ssl_error_message_from_http_proxy(e)
                and conn.proxy
                and conn.proxy.scheme == &#34;https&#34;
            ):
                e = ProxyError(
                    &#34;Your proxy appears to only use HTTP and not HTTPS, &#34;
                    &#34;try changing your proxy URL to be HTTP. See: &#34;
                    &#34;https://urllib3.readthedocs.io/en/1.26.x/advanced-usage.html&#34;
                    &#34;#https-proxy-error-http-proxy&#34;,
                    SSLError(e),
                )
            elif isinstance(e, (BaseSSLError, CertificateError)):
                e = SSLError(e)
            elif isinstance(e, (SocketError, NewConnectionError)) and self.proxy:
                e = ProxyError(&#34;Cannot connect to proxy.&#34;, e)
            elif isinstance(e, (SocketError, HTTPException)):
                e = ProtocolError(&#34;Connection aborted.&#34;, e)
    
            retries = retries.increment(
                method, url, error=e, _pool=self, _stacktrace=sys.exc_info()[2]
            )
            retries.sleep()
    
            # Keep track of the error for the retry warning.
            err = e
    
        finally:
            if not clean_exit:
                # We hit some kind of exception, handled or otherwise. We need
                # to throw the connection away unless explicitly told not to.
                # Close the connection, set the variable to None, and make sure
                # we put the None back in the pool to avoid leaking it.
                conn = conn and conn.close()
                release_this_conn = True
    
            if release_this_conn:
                # Put the connection back to be reused. If the connection is
                # expired then it will be None, which will get replaced with a
                # fresh connection during _get_conn.
                self._put_conn(conn)
    
        if not conn:
            # Try again
            log.warning(
                &#34;Retrying (%r) after connection broken by &#39;%r&#39;: %s&#34;, retries, err, url
            )
            return self.urlopen(
                method,
                url,
                body,
                headers,
                retries,
                redirect,
                assert_same_host,
                timeout=timeout,
                pool_timeout=pool_timeout,
                release_conn=release_conn,
                chunked=chunked,
                body_pos=body_pos,
                **response_kw
            )
    
        # Handle redirect?
        redirect_location = redirect and response.get_redirect_location()
        if redirect_location:
            if response.status == 303:
                method = &#34;GET&#34;
    
            try:
                retries = retries.increment(method, url, response=response, _pool=self)
            except MaxRetryError:
                if retries.raise_on_redirect:
                    response.drain_conn()
                    raise
                return response
    
            response.drain_conn()
            retries.sleep_for_retry(response)
            log.debug(&#34;Redirecting %s -&gt; %s&#34;, url, redirect_location)
            return self.urlopen(
                method,
                redirect_location,
                body,
                headers,
                retries=retries,
                redirect=redirect,
                assert_same_host=assert_same_host,
                timeout=timeout,
                pool_timeout=pool_timeout,
                release_conn=release_conn,
                chunked=chunked,
                body_pos=body_pos,
                **response_kw
            )
    
        # Check if we should retry the HTTP response.
        has_retry_after = bool(response.getheader(&#34;Retry-After&#34;))
        if retries.is_retry(method, response.status, has_retry_after):
            try:
&gt;               retries = retries.increment(method, url, response=response, _pool=self)

/usr/local/lib/python3.8/site-packages/urllib3/connectionpool.py:868: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Retry(total=0, connect=None, read=None, redirect=None, status=None)
method = &#39;GET&#39;
url = &#34;/api1/x3/erp/QAL/AOBJEXT(&#39;WYXOHACT&#39;)?representation=AOBJEXT.%24details&#34;
response = &lt;urllib3.response.HTTPResponse object at 0x7f34c14eaca0&gt;
error = None
_pool = &lt;urllib3.connectionpool.HTTPSConnectionPool object at 0x7f34c1504610&gt;
_stacktrace = None

    def increment(
        self,
        method=None,
        url=None,
        response=None,
        error=None,
        _pool=None,
        _stacktrace=None,
    ):
        &#34;&#34;&#34;Return a new Retry object with incremented retry counters.
    
        :param response: A response object, or None, if the server did not
            return a response.
        :type response: :class:`~urllib3.response.HTTPResponse`
        :param Exception error: An error encountered during the request, or
            None if the response was received successfully.
    
        :return: A new ``Retry`` object.
        &#34;&#34;&#34;
        if self.total is False and error:
            # Disabled, indicate to re-raise the error.
            raise six.reraise(type(error), error, _stacktrace)
    
        total = self.total
        if total is not None:
            total -= 1
    
        connect = self.connect
        read = self.read
        redirect = self.redirect
        status_count = self.status
        other = self.other
        cause = &#34;unknown&#34;
        status = None
        redirect_location = None
    
        if error and self._is_connection_error(error):
            # Connect retry?
            if connect is False:
                raise six.reraise(type(error), error, _stacktrace)
            elif connect is not None:
                connect -= 1
    
        elif error and self._is_read_error(error):
            # Read retry?
            if read is False or not self._is_method_retryable(method):
                raise six.reraise(type(error), error, _stacktrace)
            elif read is not None:
                read -= 1
    
        elif error:
            # Other retry?
            if other is not None:
                other -= 1
    
        elif response and response.get_redirect_location():
            # Redirect retry?
            if redirect is not None:
                redirect -= 1
            cause = &#34;too many redirects&#34;
            redirect_location = response.get_redirect_location()
            status = response.status
    
        else:
            # Incrementing because of a server error like a 500 in
            # status_forcelist and the given method is in the allowed_methods
            cause = ResponseError.GENERIC_ERROR
            if response and response.status:
                if status_count is not None:
                    status_count -= 1
                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)
                status = response.status
    
        history = self.history + (
            RequestHistory(method, url, error, status, redirect_location),
        )
    
        new_retry = self.new(
            total=total,
            connect=connect,
            read=read,
            redirect=redirect,
            status=status_count,
            other=other,
            history=history,
        )
    
        if new_retry.is_exhausted():
&gt;           raise MaxRetryError(_pool, url, error or ResponseError(cause))
E           urllib3.exceptions.MaxRetryError: HTTPSConnectionPool(host=&#39;sagex3-horsprod.covage.com&#39;, port=443): Max retries exceeded with url: /api1/x3/erp/QAL/AOBJEXT(&#39;WYXOHACT&#39;)?representation=AOBJEXT.%24details (Caused by ResponseError(&#39;too many 502 error responses&#39;))

/usr/local/lib/python3.8/site-packages/urllib3/util/retry.py:592: MaxRetryError

During handling of the above exception, another exception occurred:

folder = &#39;QAL&#39;

    @pytest.mark.livetest
    @pytest.mark.xfail
    @pytest.mark.parametrize(&#34;folder&#34;, [os.environ[&#34;LIVE_TEST_X3_FOLDER&#34;]])
    def test_validate_schema_WYXOHACT(folder):
        &#34;&#34;&#34;
        Compare diff for `WYXOHACT` model between local snapshot and os.environ[&#34;LIVE_TEST_X3_FOLDER&#34;]\n
        WYXOHACT: Activate contract
        &#34;&#34;&#34;
&gt;       destination = get_model_schema_from_x3(&#34;WYXOHACT&#34;, folder=folder)

app/api/live_tests/test_validate_import_schema.py:81: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
app/api/live_tests/test_validate_import_schema.py:31: in get_model_schema_from_x3
    resp = client.get(class_name=&#34;AOBJEXT&#34;, representation=&#34;AOBJEXT&#34;, ref=model_name)
app/x3_wrapper/rest_client.py:109: in get
    resp = self._cal_x3(&#34;GET&#34;, url, query_params)
app/x3_wrapper/rest_client.py:70: in _cal_x3
    resp = self.client.request(method, url, params=query_params)
/usr/local/lib/python3.8/site-packages/requests/sessions.py:587: in request
    resp = self.send(prep, **send_kwargs)
/usr/local/lib/python3.8/site-packages/requests/sessions.py:701: in send
    r = adapter.send(request, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;requests.adapters.HTTPAdapter object at 0x7f34c15042e0&gt;
request = &lt;PreparedRequest [GET]&gt;, stream = False
timeout = Timeout(connect=None, read=None, total=None), verify = True
cert = None
proxies = OrderedDict([(&#39;no&#39;, &#39;gitlab-runner-cache-01-prd.nut.covage.com&#39;), (&#39;http&#39;, &#39;http://squid.kosc.net:3128&#39;), (&#39;https&#39;, &#39;http://squid.kosc.net:3128&#39;)])

    def send(
        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None
    ):
        &#34;&#34;&#34;Sends PreparedRequest object. Returns Response object.
    
        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.
        :param stream: (optional) Whether to stream the request content.
        :param timeout: (optional) How long to wait for the server to send
            data before giving up, as a float, or a :ref:`(connect timeout,
            read timeout) &lt;timeouts&gt;` tuple.
        :type timeout: float or tuple or urllib3 Timeout object
        :param verify: (optional) Either a boolean, in which case it controls whether
            we verify the server&#39;s TLS certificate, or a string, in which case it
            must be a path to a CA bundle to use
        :param cert: (optional) Any user-provided SSL certificate to be trusted.
        :param proxies: (optional) The proxies dictionary to apply to the request.
        :rtype: requests.Response
        &#34;&#34;&#34;
    
        try:
            conn = self.get_connection(request.url, proxies)
        except LocationValueError as e:
            raise InvalidURL(e, request=request)
    
        self.cert_verify(conn, request.url, verify, cert)
        url = self.request_url(request, proxies)
        self.add_headers(
            request,
            stream=stream,
            timeout=timeout,
            verify=verify,
            cert=cert,
            proxies=proxies,
        )
    
        chunked = not (request.body is None or &#34;Content-Length&#34; in request.headers)
    
        if isinstance(timeout, tuple):
            try:
                connect, read = timeout
                timeout = TimeoutSauce(connect=connect, read=read)
            except ValueError:
                raise ValueError(
                    f&#34;Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, &#34;
                    f&#34;or a single float to set both timeouts to the same value.&#34;
                )
        elif isinstance(timeout, TimeoutSauce):
            pass
        else:
            timeout = TimeoutSauce(connect=timeout, read=timeout)
    
        try:
            if not chunked:
                resp = conn.urlopen(
                    method=request.method,
                    url=url,
                    body=request.body,
                    headers=request.headers,
                    redirect=False,
                    assert_same_host=False,
                    preload_content=False,
                    decode_content=False,
                    retries=self.max_retries,
                    timeout=timeout,
                )
    
            # Send the request.
            else:
                if hasattr(conn, &#34;proxy_pool&#34;):
                    conn = conn.proxy_pool
    
                low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)
    
                try:
                    skip_host = &#34;Host&#34; in request.headers
                    low_conn.putrequest(
                        request.method,
                        url,
                        skip_accept_encoding=True,
                        skip_host=skip_host,
                    )
    
                    for header, value in request.headers.items():
                        low_conn.putheader(header, value)
    
                    low_conn.endheaders()
    
                    for i in request.body:
                        low_conn.send(hex(len(i))[2:].encode(&#34;utf-8&#34;))
                        low_conn.send(b&#34;\r\n&#34;)
                        low_conn.send(i)
                        low_conn.send(b&#34;\r\n&#34;)
                    low_conn.send(b&#34;0\r\n\r\n&#34;)
    
                    # Receive the response from the server
                    r = low_conn.getresponse()
    
                    resp = HTTPResponse.from_httplib(
                        r,
                        pool=conn,
                        connection=low_conn,
                        preload_content=False,
                        decode_content=False,
                    )
                except Exception:
                    # If we hit any problems here, clean up the connection.
                    # Then, raise so that we can handle the actual exception.
                    low_conn.close()
                    raise
    
        except (ProtocolError, OSError) as err:
            raise ConnectionError(err, request=request)
    
        except MaxRetryError as e:
            if isinstance(e.reason, ConnectTimeoutError):
                # TODO: Remove this in 3.0.0: see #2811
                if not isinstance(e.reason, NewConnectionError):
                    raise ConnectTimeout(e, request=request)
    
            if isinstance(e.reason, ResponseError):
&gt;               raise RetryError(e, request=request)
E               requests.exceptions.RetryError: HTTPSConnectionPool(host=&#39;sagex3-horsprod.covage.com&#39;, port=443): Max retries exceeded with url: /api1/x3/erp/QAL/AOBJEXT(&#39;WYXOHACT&#39;)?representation=AOBJEXT.%24details (Caused by ResponseError(&#39;too many 502 error responses&#39;))

/usr/local/lib/python3.8/site-packages/requests/adapters.py:556: RetryError</pre> </div> </div> </details> <details class="phase teardown "> <summary> <h4 class=title> <span class=phase-name>Teardown</span> </h4> </summary> <div class=content> </div> </details> </div> </div> </details> <details class="test xfailed"> <summary> <h3 class="title test-title"> <span class="status badge xfailed ">XFAIL</span> <span class=test-name> <span class=funcname>test_validate_schema_WYXOHRESIL</span><span class=params>[QAL]</span> </span> <span class=duration>0:00:00.655387</span> </h3> </summary> <div class=content> <div class=documentation> <p>Compare diff for <cite>WYXOHRESIL</cite> model between local snapshot and os.environ[&quot;LIVE_TEST_X3_FOLDER&quot;]</p> <p>WYXOHRESIL: Terminate contract</p> </div> <table class=metadata> <tr> <th>Started</th> <td>2023-06-30 01:14:37</td> </tr> <tr> <th>Ended</th> <td>2023-06-30 01:14:38</td> </tr> <tr> <th>Duration</th> <td>0:00:00.655387</td> </tr> <tr> <th>Markers</th> <td> <div class=marker> <span class="marker-name badge">xfail</span> <span class=marker-args> </span> </div> <div class=marker> <span class="marker-name badge">livetest</span> <span class=marker-args> </span> </div> </td> </tr> <tr> <th>Fixtures</th> <td> <span class="badge fixturename"> django_test_environment </span> <span class="badge fixturename"> django_db_blocker </span> <span class="badge fixturename"> folder </span> <span class="badge fixturename"> request </span> </td> </tr> </table> <div class=repr> <pre>requests.exceptions.RetryError: HTTPSConnectionPool(host=&#39;sagex3-horsprod.covage.com&#39;, port=443): Max retries exceeded with url: /api1/x3/erp/QAL/AOBJEXT(&#39;WYXOHRESIL&#39;)?representation=AOBJEXT.%24details (Caused by ResponseError(&#39;too many 502 error responses&#39;))</pre> </div> <div class=test-phases> <details class="phase setup "> <summary> <h4 class=title> <span class=phase-name>Setup</span> </h4> </summary> <div class=content> </div> </details> <details class="phase call xfailed" open> <summary> <h4 class=title> <span class="status  xfailed"></span> <span class=phase-name>Call</span> </h4> </summary> <div class=content> <div class=repr> <pre>self = &lt;requests.adapters.HTTPAdapter object at 0x7f34bbb7daf0&gt;
request = &lt;PreparedRequest [GET]&gt;, stream = False
timeout = Timeout(connect=None, read=None, total=None), verify = True
cert = None
proxies = OrderedDict([(&#39;no&#39;, &#39;gitlab-runner-cache-01-prd.nut.covage.com&#39;), (&#39;http&#39;, &#39;http://squid.kosc.net:3128&#39;), (&#39;https&#39;, &#39;http://squid.kosc.net:3128&#39;)])

    def send(
        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None
    ):
        &#34;&#34;&#34;Sends PreparedRequest object. Returns Response object.
    
        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.
        :param stream: (optional) Whether to stream the request content.
        :param timeout: (optional) How long to wait for the server to send
            data before giving up, as a float, or a :ref:`(connect timeout,
            read timeout) &lt;timeouts&gt;` tuple.
        :type timeout: float or tuple or urllib3 Timeout object
        :param verify: (optional) Either a boolean, in which case it controls whether
            we verify the server&#39;s TLS certificate, or a string, in which case it
            must be a path to a CA bundle to use
        :param cert: (optional) Any user-provided SSL certificate to be trusted.
        :param proxies: (optional) The proxies dictionary to apply to the request.
        :rtype: requests.Response
        &#34;&#34;&#34;
    
        try:
            conn = self.get_connection(request.url, proxies)
        except LocationValueError as e:
            raise InvalidURL(e, request=request)
    
        self.cert_verify(conn, request.url, verify, cert)
        url = self.request_url(request, proxies)
        self.add_headers(
            request,
            stream=stream,
            timeout=timeout,
            verify=verify,
            cert=cert,
            proxies=proxies,
        )
    
        chunked = not (request.body is None or &#34;Content-Length&#34; in request.headers)
    
        if isinstance(timeout, tuple):
            try:
                connect, read = timeout
                timeout = TimeoutSauce(connect=connect, read=read)
            except ValueError:
                raise ValueError(
                    f&#34;Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, &#34;
                    f&#34;or a single float to set both timeouts to the same value.&#34;
                )
        elif isinstance(timeout, TimeoutSauce):
            pass
        else:
            timeout = TimeoutSauce(connect=timeout, read=timeout)
    
        try:
            if not chunked:
&gt;               resp = conn.urlopen(
                    method=request.method,
                    url=url,
                    body=request.body,
                    headers=request.headers,
                    redirect=False,
                    assert_same_host=False,
                    preload_content=False,
                    decode_content=False,
                    retries=self.max_retries,
                    timeout=timeout,
                )

/usr/local/lib/python3.8/site-packages/requests/adapters.py:489: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connectionpool.HTTPSConnectionPool object at 0x7f34bbb7db80&gt;
method = &#39;GET&#39;
url = &#34;/api1/x3/erp/QAL/AOBJEXT(&#39;WYXOHRESIL&#39;)?representation=AOBJEXT.%24details&#34;
body = None
headers = {&#39;User-Agent&#39;: &#39;python-requests/2.28.1&#39;, &#39;Accept-Encoding&#39;: &#39;gzip, deflate&#39;, &#39;Accept&#39;: &#39;*/*&#39;, &#39;Connection&#39;: &#39;keep-alive&#39;, &#39;Content-Type&#39;: &#39;application/json&#39;, &#39;Authorization&#39;: &#39;Basic aW50cmFjbzpXYXNzaW1Db3ZhZ2VA&#39;}
retries = Retry(total=2, connect=None, read=None, redirect=None, status=None)
redirect = False, assert_same_host = False
timeout = Timeout(connect=None, read=None, total=None), pool_timeout = None
release_conn = False, chunked = False, body_pos = None
response_kw = {&#39;decode_content&#39;: False, &#39;preload_content&#39;: False, &#39;request_method&#39;: &#39;GET&#39;}
parsed_url = Url(scheme=None, auth=None, host=None, port=None, path=&#34;/api1/x3/erp/QAL/AOBJEXT(&#39;WYXOHRESIL&#39;)&#34;, query=&#39;representation=AOBJEXT.%24details&#39;, fragment=None)
destination_scheme = None
conn = &lt;urllib3.connection.HTTPSConnection object at 0x7f34bbae7d90&gt;
release_this_conn = False, http_tunnel_required = True, err = None
clean_exit = True

    def urlopen(
        self,
        method,
        url,
        body=None,
        headers=None,
        retries=None,
        redirect=True,
        assert_same_host=True,
        timeout=_Default,
        pool_timeout=None,
        release_conn=None,
        chunked=False,
        body_pos=None,
        **response_kw
    ):
        &#34;&#34;&#34;
        Get a connection from the pool and perform an HTTP request. This is the
        lowest level call for making a request, so you&#39;ll need to specify all
        the raw details.
    
        .. note::
    
           More commonly, it&#39;s appropriate to use a convenience method provided
           by :class:`.RequestMethods`, such as :meth:`request`.
    
        .. note::
    
           `release_conn` will only behave as expected if
           `preload_content=False` because we want to make
           `preload_content=False` the default behaviour someday soon without
           breaking backwards compatibility.
    
        :param method:
            HTTP request method (such as GET, POST, PUT, etc.)
    
        :param url:
            The URL to perform the request on.
    
        :param body:
            Data to send in the request body, either :class:`str`, :class:`bytes`,
            an iterable of :class:`str`/:class:`bytes`, or a file-like object.
    
        :param headers:
            Dictionary of custom headers to send, such as User-Agent,
            If-None-Match, etc. If None, pool headers are used. If provided,
            these headers completely replace any pool-specific headers.
    
        :param retries:
            Configure the number of retries to allow before raising a
            :class:`~urllib3.exceptions.MaxRetryError` exception.
    
            Pass ``None`` to retry until you receive a response. Pass a
            :class:`~urllib3.util.retry.Retry` object for fine-grained control
            over different types of retries.
            Pass an integer number to retry connection errors that many times,
            but no other types of errors. Pass zero to never retry.
    
            If ``False``, then retries are disabled and any exception is raised
            immediately. Also, instead of raising a MaxRetryError on redirects,
            the redirect response will be returned.
    
        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.
    
        :param redirect:
            If True, automatically handle redirects (status codes 301, 302,
            303, 307, 308). Each redirect counts as a retry. Disabling retries
            will disable redirect, too.
    
        :param assert_same_host:
            If ``True``, will make sure that the host of the pool requests is
            consistent else will raise HostChangedError. When ``False``, you can
            use the pool on an HTTP proxy and request foreign hosts.
    
        :param timeout:
            If specified, overrides the default timeout for this one
            request. It may be a float (in seconds) or an instance of
            :class:`urllib3.util.Timeout`.
    
        :param pool_timeout:
            If set and the pool is set to block=True, then this method will
            block for ``pool_timeout`` seconds and raise EmptyPoolError if no
            connection is available within the time period.
    
        :param release_conn:
            If False, then the urlopen call will not release the connection
            back into the pool once a response is received (but will release if
            you read the entire contents of the response such as when
            `preload_content=True`). This is useful if you&#39;re not preloading
            the response&#39;s content immediately. You will need to call
            ``r.release_conn()`` on the response ``r`` to return the connection
            back into the pool. If None, it takes the value of
            ``response_kw.get(&#39;preload_content&#39;, True)``.
    
        :param chunked:
            If True, urllib3 will send the body using chunked transfer
            encoding. Otherwise, urllib3 will send the body using the standard
            content-length form. Defaults to False.
    
        :param int body_pos:
            Position to seek to in file-like body in the event of a retry or
            redirect. Typically this won&#39;t need to be set because urllib3 will
            auto-populate the value when needed.
    
        :param \\**response_kw:
            Additional parameters are passed to
            :meth:`urllib3.response.HTTPResponse.from_httplib`
        &#34;&#34;&#34;
    
        parsed_url = parse_url(url)
        destination_scheme = parsed_url.scheme
    
        if headers is None:
            headers = self.headers
    
        if not isinstance(retries, Retry):
            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)
    
        if release_conn is None:
            release_conn = response_kw.get(&#34;preload_content&#34;, True)
    
        # Check host
        if assert_same_host and not self.is_same_host(url):
            raise HostChangedError(self, url, retries)
    
        # Ensure that the URL we&#39;re connecting to is properly encoded
        if url.startswith(&#34;/&#34;):
            url = six.ensure_str(_encode_target(url))
        else:
            url = six.ensure_str(parsed_url.url)
    
        conn = None
    
        # Track whether `conn` needs to be released before
        # returning/raising/recursing. Update this variable if necessary, and
        # leave `release_conn` constant throughout the function. That way, if
        # the function recurses, the original value of `release_conn` will be
        # passed down into the recursive call, and its value will be respected.
        #
        # See issue #651 [1] for details.
        #
        # [1] &lt;https://github.com/urllib3/urllib3/issues/651&gt;
        release_this_conn = release_conn
    
        http_tunnel_required = connection_requires_http_tunnel(
            self.proxy, self.proxy_config, destination_scheme
        )
    
        # Merge the proxy headers. Only done when not using HTTP CONNECT. We
        # have to copy the headers dict so we can safely change it without those
        # changes being reflected in anyone else&#39;s copy.
        if not http_tunnel_required:
            headers = headers.copy()
            headers.update(self.proxy_headers)
    
        # Must keep the exception bound to a separate variable or else Python 3
        # complains about UnboundLocalError.
        err = None
    
        # Keep track of whether we cleanly exited the except block. This
        # ensures we do proper cleanup in finally.
        clean_exit = False
    
        # Rewind body position, if needed. Record current position
        # for future rewinds in the event of a redirect/retry.
        body_pos = set_file_position(body, body_pos)
    
        try:
            # Request a connection from the queue.
            timeout_obj = self._get_timeout(timeout)
            conn = self._get_conn(timeout=pool_timeout)
    
            conn.timeout = timeout_obj.connect_timeout
    
            is_new_proxy_conn = self.proxy is not None and not getattr(
                conn, &#34;sock&#34;, None
            )
            if is_new_proxy_conn and http_tunnel_required:
                self._prepare_proxy(conn)
    
            # Make the request on the httplib connection object.
            httplib_response = self._make_request(
                conn,
                method,
                url,
                timeout=timeout_obj,
                body=body,
                headers=headers,
                chunked=chunked,
            )
    
            # If we&#39;re going to release the connection in ``finally:``, then
            # the response doesn&#39;t need to know about the connection. Otherwise
            # it will also try to release it and we&#39;ll have a double-release
            # mess.
            response_conn = conn if not release_conn else None
    
            # Pass method to Response for length checking
            response_kw[&#34;request_method&#34;] = method
    
            # Import httplib&#39;s response into our own wrapper object
            response = self.ResponseCls.from_httplib(
                httplib_response,
                pool=self,
                connection=response_conn,
                retries=retries,
                **response_kw
            )
    
            # Everything went great!
            clean_exit = True
    
        except EmptyPoolError:
            # Didn&#39;t get a connection from the pool, no need to clean up
            clean_exit = True
            release_this_conn = False
            raise
    
        except (
            TimeoutError,
            HTTPException,
            SocketError,
            ProtocolError,
            BaseSSLError,
            SSLError,
            CertificateError,
        ) as e:
            # Discard the connection for these exceptions. It will be
            # replaced during the next _get_conn() call.
            clean_exit = False
    
            def _is_ssl_error_message_from_http_proxy(ssl_error):
                # We&#39;re trying to detect the message &#39;WRONG_VERSION_NUMBER&#39; but
                # SSLErrors are kinda all over the place when it comes to the message,
                # so we try to cover our bases here!
                message = &#34; &#34;.join(re.split(&#34;[^a-z]&#34;, str(ssl_error).lower()))
                return (
                    &#34;wrong version number&#34; in message or &#34;unknown protocol&#34; in message
                )
    
            # Try to detect a common user error with proxies which is to
            # set an HTTP proxy to be HTTPS when it should be &#39;http://&#39;
            # (ie {&#39;http&#39;: &#39;http://proxy&#39;, &#39;https&#39;: &#39;https://proxy&#39;})
            # Instead we add a nice error message and point to a URL.
            if (
                isinstance(e, BaseSSLError)
                and self.proxy
                and _is_ssl_error_message_from_http_proxy(e)
                and conn.proxy
                and conn.proxy.scheme == &#34;https&#34;
            ):
                e = ProxyError(
                    &#34;Your proxy appears to only use HTTP and not HTTPS, &#34;
                    &#34;try changing your proxy URL to be HTTP. See: &#34;
                    &#34;https://urllib3.readthedocs.io/en/1.26.x/advanced-usage.html&#34;
                    &#34;#https-proxy-error-http-proxy&#34;,
                    SSLError(e),
                )
            elif isinstance(e, (BaseSSLError, CertificateError)):
                e = SSLError(e)
            elif isinstance(e, (SocketError, NewConnectionError)) and self.proxy:
                e = ProxyError(&#34;Cannot connect to proxy.&#34;, e)
            elif isinstance(e, (SocketError, HTTPException)):
                e = ProtocolError(&#34;Connection aborted.&#34;, e)
    
            retries = retries.increment(
                method, url, error=e, _pool=self, _stacktrace=sys.exc_info()[2]
            )
            retries.sleep()
    
            # Keep track of the error for the retry warning.
            err = e
    
        finally:
            if not clean_exit:
                # We hit some kind of exception, handled or otherwise. We need
                # to throw the connection away unless explicitly told not to.
                # Close the connection, set the variable to None, and make sure
                # we put the None back in the pool to avoid leaking it.
                conn = conn and conn.close()
                release_this_conn = True
    
            if release_this_conn:
                # Put the connection back to be reused. If the connection is
                # expired then it will be None, which will get replaced with a
                # fresh connection during _get_conn.
                self._put_conn(conn)
    
        if not conn:
            # Try again
            log.warning(
                &#34;Retrying (%r) after connection broken by &#39;%r&#39;: %s&#34;, retries, err, url
            )
            return self.urlopen(
                method,
                url,
                body,
                headers,
                retries,
                redirect,
                assert_same_host,
                timeout=timeout,
                pool_timeout=pool_timeout,
                release_conn=release_conn,
                chunked=chunked,
                body_pos=body_pos,
                **response_kw
            )
    
        # Handle redirect?
        redirect_location = redirect and response.get_redirect_location()
        if redirect_location:
            if response.status == 303:
                method = &#34;GET&#34;
    
            try:
                retries = retries.increment(method, url, response=response, _pool=self)
            except MaxRetryError:
                if retries.raise_on_redirect:
                    response.drain_conn()
                    raise
                return response
    
            response.drain_conn()
            retries.sleep_for_retry(response)
            log.debug(&#34;Redirecting %s -&gt; %s&#34;, url, redirect_location)
            return self.urlopen(
                method,
                redirect_location,
                body,
                headers,
                retries=retries,
                redirect=redirect,
                assert_same_host=assert_same_host,
                timeout=timeout,
                pool_timeout=pool_timeout,
                release_conn=release_conn,
                chunked=chunked,
                body_pos=body_pos,
                **response_kw
            )
    
        # Check if we should retry the HTTP response.
        has_retry_after = bool(response.getheader(&#34;Retry-After&#34;))
        if retries.is_retry(method, response.status, has_retry_after):
            try:
                retries = retries.increment(method, url, response=response, _pool=self)
            except MaxRetryError:
                if retries.raise_on_status:
                    response.drain_conn()
                    raise
                return response
    
            response.drain_conn()
            retries.sleep(response)
            log.debug(&#34;Retry: %s&#34;, url)
&gt;           return self.urlopen(
                method,
                url,
                body,
                headers,
                retries=retries,
                redirect=redirect,
                assert_same_host=assert_same_host,
                timeout=timeout,
                pool_timeout=pool_timeout,
                release_conn=release_conn,
                chunked=chunked,
                body_pos=body_pos,
                **response_kw
            )

/usr/local/lib/python3.8/site-packages/urllib3/connectionpool.py:878: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connectionpool.HTTPSConnectionPool object at 0x7f34bbb7db80&gt;
method = &#39;GET&#39;
url = &#34;/api1/x3/erp/QAL/AOBJEXT(&#39;WYXOHRESIL&#39;)?representation=AOBJEXT.%24details&#34;
body = None
headers = {&#39;User-Agent&#39;: &#39;python-requests/2.28.1&#39;, &#39;Accept-Encoding&#39;: &#39;gzip, deflate&#39;, &#39;Accept&#39;: &#39;*/*&#39;, &#39;Connection&#39;: &#39;keep-alive&#39;, &#39;Content-Type&#39;: &#39;application/json&#39;, &#39;Authorization&#39;: &#39;Basic aW50cmFjbzpXYXNzaW1Db3ZhZ2VA&#39;}
retries = Retry(total=1, connect=None, read=None, redirect=None, status=None)
redirect = False, assert_same_host = False
timeout = Timeout(connect=None, read=None, total=None), pool_timeout = None
release_conn = False, chunked = False, body_pos = None
response_kw = {&#39;decode_content&#39;: False, &#39;preload_content&#39;: False, &#39;request_method&#39;: &#39;GET&#39;}
parsed_url = Url(scheme=None, auth=None, host=None, port=None, path=&#34;/api1/x3/erp/QAL/AOBJEXT(&#39;WYXOHRESIL&#39;)&#34;, query=&#39;representation=AOBJEXT.%24details&#39;, fragment=None)
destination_scheme = None
conn = &lt;urllib3.connection.HTTPSConnection object at 0x7f34bbae7d90&gt;
release_this_conn = False, http_tunnel_required = True, err = None
clean_exit = True

    def urlopen(
        self,
        method,
        url,
        body=None,
        headers=None,
        retries=None,
        redirect=True,
        assert_same_host=True,
        timeout=_Default,
        pool_timeout=None,
        release_conn=None,
        chunked=False,
        body_pos=None,
        **response_kw
    ):
        &#34;&#34;&#34;
        Get a connection from the pool and perform an HTTP request. This is the
        lowest level call for making a request, so you&#39;ll need to specify all
        the raw details.
    
        .. note::
    
           More commonly, it&#39;s appropriate to use a convenience method provided
           by :class:`.RequestMethods`, such as :meth:`request`.
    
        .. note::
    
           `release_conn` will only behave as expected if
           `preload_content=False` because we want to make
           `preload_content=False` the default behaviour someday soon without
           breaking backwards compatibility.
    
        :param method:
            HTTP request method (such as GET, POST, PUT, etc.)
    
        :param url:
            The URL to perform the request on.
    
        :param body:
            Data to send in the request body, either :class:`str`, :class:`bytes`,
            an iterable of :class:`str`/:class:`bytes`, or a file-like object.
    
        :param headers:
            Dictionary of custom headers to send, such as User-Agent,
            If-None-Match, etc. If None, pool headers are used. If provided,
            these headers completely replace any pool-specific headers.
    
        :param retries:
            Configure the number of retries to allow before raising a
            :class:`~urllib3.exceptions.MaxRetryError` exception.
    
            Pass ``None`` to retry until you receive a response. Pass a
            :class:`~urllib3.util.retry.Retry` object for fine-grained control
            over different types of retries.
            Pass an integer number to retry connection errors that many times,
            but no other types of errors. Pass zero to never retry.
    
            If ``False``, then retries are disabled and any exception is raised
            immediately. Also, instead of raising a MaxRetryError on redirects,
            the redirect response will be returned.
    
        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.
    
        :param redirect:
            If True, automatically handle redirects (status codes 301, 302,
            303, 307, 308). Each redirect counts as a retry. Disabling retries
            will disable redirect, too.
    
        :param assert_same_host:
            If ``True``, will make sure that the host of the pool requests is
            consistent else will raise HostChangedError. When ``False``, you can
            use the pool on an HTTP proxy and request foreign hosts.
    
        :param timeout:
            If specified, overrides the default timeout for this one
            request. It may be a float (in seconds) or an instance of
            :class:`urllib3.util.Timeout`.
    
        :param pool_timeout:
            If set and the pool is set to block=True, then this method will
            block for ``pool_timeout`` seconds and raise EmptyPoolError if no
            connection is available within the time period.
    
        :param release_conn:
            If False, then the urlopen call will not release the connection
            back into the pool once a response is received (but will release if
            you read the entire contents of the response such as when
            `preload_content=True`). This is useful if you&#39;re not preloading
            the response&#39;s content immediately. You will need to call
            ``r.release_conn()`` on the response ``r`` to return the connection
            back into the pool. If None, it takes the value of
            ``response_kw.get(&#39;preload_content&#39;, True)``.
    
        :param chunked:
            If True, urllib3 will send the body using chunked transfer
            encoding. Otherwise, urllib3 will send the body using the standard
            content-length form. Defaults to False.
    
        :param int body_pos:
            Position to seek to in file-like body in the event of a retry or
            redirect. Typically this won&#39;t need to be set because urllib3 will
            auto-populate the value when needed.
    
        :param \\**response_kw:
            Additional parameters are passed to
            :meth:`urllib3.response.HTTPResponse.from_httplib`
        &#34;&#34;&#34;
    
        parsed_url = parse_url(url)
        destination_scheme = parsed_url.scheme
    
        if headers is None:
            headers = self.headers
    
        if not isinstance(retries, Retry):
            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)
    
        if release_conn is None:
            release_conn = response_kw.get(&#34;preload_content&#34;, True)
    
        # Check host
        if assert_same_host and not self.is_same_host(url):
            raise HostChangedError(self, url, retries)
    
        # Ensure that the URL we&#39;re connecting to is properly encoded
        if url.startswith(&#34;/&#34;):
            url = six.ensure_str(_encode_target(url))
        else:
            url = six.ensure_str(parsed_url.url)
    
        conn = None
    
        # Track whether `conn` needs to be released before
        # returning/raising/recursing. Update this variable if necessary, and
        # leave `release_conn` constant throughout the function. That way, if
        # the function recurses, the original value of `release_conn` will be
        # passed down into the recursive call, and its value will be respected.
        #
        # See issue #651 [1] for details.
        #
        # [1] &lt;https://github.com/urllib3/urllib3/issues/651&gt;
        release_this_conn = release_conn
    
        http_tunnel_required = connection_requires_http_tunnel(
            self.proxy, self.proxy_config, destination_scheme
        )
    
        # Merge the proxy headers. Only done when not using HTTP CONNECT. We
        # have to copy the headers dict so we can safely change it without those
        # changes being reflected in anyone else&#39;s copy.
        if not http_tunnel_required:
            headers = headers.copy()
            headers.update(self.proxy_headers)
    
        # Must keep the exception bound to a separate variable or else Python 3
        # complains about UnboundLocalError.
        err = None
    
        # Keep track of whether we cleanly exited the except block. This
        # ensures we do proper cleanup in finally.
        clean_exit = False
    
        # Rewind body position, if needed. Record current position
        # for future rewinds in the event of a redirect/retry.
        body_pos = set_file_position(body, body_pos)
    
        try:
            # Request a connection from the queue.
            timeout_obj = self._get_timeout(timeout)
            conn = self._get_conn(timeout=pool_timeout)
    
            conn.timeout = timeout_obj.connect_timeout
    
            is_new_proxy_conn = self.proxy is not None and not getattr(
                conn, &#34;sock&#34;, None
            )
            if is_new_proxy_conn and http_tunnel_required:
                self._prepare_proxy(conn)
    
            # Make the request on the httplib connection object.
            httplib_response = self._make_request(
                conn,
                method,
                url,
                timeout=timeout_obj,
                body=body,
                headers=headers,
                chunked=chunked,
            )
    
            # If we&#39;re going to release the connection in ``finally:``, then
            # the response doesn&#39;t need to know about the connection. Otherwise
            # it will also try to release it and we&#39;ll have a double-release
            # mess.
            response_conn = conn if not release_conn else None
    
            # Pass method to Response for length checking
            response_kw[&#34;request_method&#34;] = method
    
            # Import httplib&#39;s response into our own wrapper object
            response = self.ResponseCls.from_httplib(
                httplib_response,
                pool=self,
                connection=response_conn,
                retries=retries,
                **response_kw
            )
    
            # Everything went great!
            clean_exit = True
    
        except EmptyPoolError:
            # Didn&#39;t get a connection from the pool, no need to clean up
            clean_exit = True
            release_this_conn = False
            raise
    
        except (
            TimeoutError,
            HTTPException,
            SocketError,
            ProtocolError,
            BaseSSLError,
            SSLError,
            CertificateError,
        ) as e:
            # Discard the connection for these exceptions. It will be
            # replaced during the next _get_conn() call.
            clean_exit = False
    
            def _is_ssl_error_message_from_http_proxy(ssl_error):
                # We&#39;re trying to detect the message &#39;WRONG_VERSION_NUMBER&#39; but
                # SSLErrors are kinda all over the place when it comes to the message,
                # so we try to cover our bases here!
                message = &#34; &#34;.join(re.split(&#34;[^a-z]&#34;, str(ssl_error).lower()))
                return (
                    &#34;wrong version number&#34; in message or &#34;unknown protocol&#34; in message
                )
    
            # Try to detect a common user error with proxies which is to
            # set an HTTP proxy to be HTTPS when it should be &#39;http://&#39;
            # (ie {&#39;http&#39;: &#39;http://proxy&#39;, &#39;https&#39;: &#39;https://proxy&#39;})
            # Instead we add a nice error message and point to a URL.
            if (
                isinstance(e, BaseSSLError)
                and self.proxy
                and _is_ssl_error_message_from_http_proxy(e)
                and conn.proxy
                and conn.proxy.scheme == &#34;https&#34;
            ):
                e = ProxyError(
                    &#34;Your proxy appears to only use HTTP and not HTTPS, &#34;
                    &#34;try changing your proxy URL to be HTTP. See: &#34;
                    &#34;https://urllib3.readthedocs.io/en/1.26.x/advanced-usage.html&#34;
                    &#34;#https-proxy-error-http-proxy&#34;,
                    SSLError(e),
                )
            elif isinstance(e, (BaseSSLError, CertificateError)):
                e = SSLError(e)
            elif isinstance(e, (SocketError, NewConnectionError)) and self.proxy:
                e = ProxyError(&#34;Cannot connect to proxy.&#34;, e)
            elif isinstance(e, (SocketError, HTTPException)):
                e = ProtocolError(&#34;Connection aborted.&#34;, e)
    
            retries = retries.increment(
                method, url, error=e, _pool=self, _stacktrace=sys.exc_info()[2]
            )
            retries.sleep()
    
            # Keep track of the error for the retry warning.
            err = e
    
        finally:
            if not clean_exit:
                # We hit some kind of exception, handled or otherwise. We need
                # to throw the connection away unless explicitly told not to.
                # Close the connection, set the variable to None, and make sure
                # we put the None back in the pool to avoid leaking it.
                conn = conn and conn.close()
                release_this_conn = True
    
            if release_this_conn:
                # Put the connection back to be reused. If the connection is
                # expired then it will be None, which will get replaced with a
                # fresh connection during _get_conn.
                self._put_conn(conn)
    
        if not conn:
            # Try again
            log.warning(
                &#34;Retrying (%r) after connection broken by &#39;%r&#39;: %s&#34;, retries, err, url
            )
            return self.urlopen(
                method,
                url,
                body,
                headers,
                retries,
                redirect,
                assert_same_host,
                timeout=timeout,
                pool_timeout=pool_timeout,
                release_conn=release_conn,
                chunked=chunked,
                body_pos=body_pos,
                **response_kw
            )
    
        # Handle redirect?
        redirect_location = redirect and response.get_redirect_location()
        if redirect_location:
            if response.status == 303:
                method = &#34;GET&#34;
    
            try:
                retries = retries.increment(method, url, response=response, _pool=self)
            except MaxRetryError:
                if retries.raise_on_redirect:
                    response.drain_conn()
                    raise
                return response
    
            response.drain_conn()
            retries.sleep_for_retry(response)
            log.debug(&#34;Redirecting %s -&gt; %s&#34;, url, redirect_location)
            return self.urlopen(
                method,
                redirect_location,
                body,
                headers,
                retries=retries,
                redirect=redirect,
                assert_same_host=assert_same_host,
                timeout=timeout,
                pool_timeout=pool_timeout,
                release_conn=release_conn,
                chunked=chunked,
                body_pos=body_pos,
                **response_kw
            )
    
        # Check if we should retry the HTTP response.
        has_retry_after = bool(response.getheader(&#34;Retry-After&#34;))
        if retries.is_retry(method, response.status, has_retry_after):
            try:
                retries = retries.increment(method, url, response=response, _pool=self)
            except MaxRetryError:
                if retries.raise_on_status:
                    response.drain_conn()
                    raise
                return response
    
            response.drain_conn()
            retries.sleep(response)
            log.debug(&#34;Retry: %s&#34;, url)
&gt;           return self.urlopen(
                method,
                url,
                body,
                headers,
                retries=retries,
                redirect=redirect,
                assert_same_host=assert_same_host,
                timeout=timeout,
                pool_timeout=pool_timeout,
                release_conn=release_conn,
                chunked=chunked,
                body_pos=body_pos,
                **response_kw
            )

/usr/local/lib/python3.8/site-packages/urllib3/connectionpool.py:878: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connectionpool.HTTPSConnectionPool object at 0x7f34bbb7db80&gt;
method = &#39;GET&#39;
url = &#34;/api1/x3/erp/QAL/AOBJEXT(&#39;WYXOHRESIL&#39;)?representation=AOBJEXT.%24details&#34;
body = None
headers = {&#39;User-Agent&#39;: &#39;python-requests/2.28.1&#39;, &#39;Accept-Encoding&#39;: &#39;gzip, deflate&#39;, &#39;Accept&#39;: &#39;*/*&#39;, &#39;Connection&#39;: &#39;keep-alive&#39;, &#39;Content-Type&#39;: &#39;application/json&#39;, &#39;Authorization&#39;: &#39;Basic aW50cmFjbzpXYXNzaW1Db3ZhZ2VA&#39;}
retries = Retry(total=0, connect=None, read=None, redirect=None, status=None)
redirect = False, assert_same_host = False
timeout = Timeout(connect=None, read=None, total=None), pool_timeout = None
release_conn = False, chunked = False, body_pos = None
response_kw = {&#39;decode_content&#39;: False, &#39;preload_content&#39;: False, &#39;request_method&#39;: &#39;GET&#39;}
parsed_url = Url(scheme=None, auth=None, host=None, port=None, path=&#34;/api1/x3/erp/QAL/AOBJEXT(&#39;WYXOHRESIL&#39;)&#34;, query=&#39;representation=AOBJEXT.%24details&#39;, fragment=None)
destination_scheme = None
conn = &lt;urllib3.connection.HTTPSConnection object at 0x7f34bbae7d90&gt;
release_this_conn = False, http_tunnel_required = True, err = None
clean_exit = True

    def urlopen(
        self,
        method,
        url,
        body=None,
        headers=None,
        retries=None,
        redirect=True,
        assert_same_host=True,
        timeout=_Default,
        pool_timeout=None,
        release_conn=None,
        chunked=False,
        body_pos=None,
        **response_kw
    ):
        &#34;&#34;&#34;
        Get a connection from the pool and perform an HTTP request. This is the
        lowest level call for making a request, so you&#39;ll need to specify all
        the raw details.
    
        .. note::
    
           More commonly, it&#39;s appropriate to use a convenience method provided
           by :class:`.RequestMethods`, such as :meth:`request`.
    
        .. note::
    
           `release_conn` will only behave as expected if
           `preload_content=False` because we want to make
           `preload_content=False` the default behaviour someday soon without
           breaking backwards compatibility.
    
        :param method:
            HTTP request method (such as GET, POST, PUT, etc.)
    
        :param url:
            The URL to perform the request on.
    
        :param body:
            Data to send in the request body, either :class:`str`, :class:`bytes`,
            an iterable of :class:`str`/:class:`bytes`, or a file-like object.
    
        :param headers:
            Dictionary of custom headers to send, such as User-Agent,
            If-None-Match, etc. If None, pool headers are used. If provided,
            these headers completely replace any pool-specific headers.
    
        :param retries:
            Configure the number of retries to allow before raising a
            :class:`~urllib3.exceptions.MaxRetryError` exception.
    
            Pass ``None`` to retry until you receive a response. Pass a
            :class:`~urllib3.util.retry.Retry` object for fine-grained control
            over different types of retries.
            Pass an integer number to retry connection errors that many times,
            but no other types of errors. Pass zero to never retry.
    
            If ``False``, then retries are disabled and any exception is raised
            immediately. Also, instead of raising a MaxRetryError on redirects,
            the redirect response will be returned.
    
        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.
    
        :param redirect:
            If True, automatically handle redirects (status codes 301, 302,
            303, 307, 308). Each redirect counts as a retry. Disabling retries
            will disable redirect, too.
    
        :param assert_same_host:
            If ``True``, will make sure that the host of the pool requests is
            consistent else will raise HostChangedError. When ``False``, you can
            use the pool on an HTTP proxy and request foreign hosts.
    
        :param timeout:
            If specified, overrides the default timeout for this one
            request. It may be a float (in seconds) or an instance of
            :class:`urllib3.util.Timeout`.
    
        :param pool_timeout:
            If set and the pool is set to block=True, then this method will
            block for ``pool_timeout`` seconds and raise EmptyPoolError if no
            connection is available within the time period.
    
        :param release_conn:
            If False, then the urlopen call will not release the connection
            back into the pool once a response is received (but will release if
            you read the entire contents of the response such as when
            `preload_content=True`). This is useful if you&#39;re not preloading
            the response&#39;s content immediately. You will need to call
            ``r.release_conn()`` on the response ``r`` to return the connection
            back into the pool. If None, it takes the value of
            ``response_kw.get(&#39;preload_content&#39;, True)``.
    
        :param chunked:
            If True, urllib3 will send the body using chunked transfer
            encoding. Otherwise, urllib3 will send the body using the standard
            content-length form. Defaults to False.
    
        :param int body_pos:
            Position to seek to in file-like body in the event of a retry or
            redirect. Typically this won&#39;t need to be set because urllib3 will
            auto-populate the value when needed.
    
        :param \\**response_kw:
            Additional parameters are passed to
            :meth:`urllib3.response.HTTPResponse.from_httplib`
        &#34;&#34;&#34;
    
        parsed_url = parse_url(url)
        destination_scheme = parsed_url.scheme
    
        if headers is None:
            headers = self.headers
    
        if not isinstance(retries, Retry):
            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)
    
        if release_conn is None:
            release_conn = response_kw.get(&#34;preload_content&#34;, True)
    
        # Check host
        if assert_same_host and not self.is_same_host(url):
            raise HostChangedError(self, url, retries)
    
        # Ensure that the URL we&#39;re connecting to is properly encoded
        if url.startswith(&#34;/&#34;):
            url = six.ensure_str(_encode_target(url))
        else:
            url = six.ensure_str(parsed_url.url)
    
        conn = None
    
        # Track whether `conn` needs to be released before
        # returning/raising/recursing. Update this variable if necessary, and
        # leave `release_conn` constant throughout the function. That way, if
        # the function recurses, the original value of `release_conn` will be
        # passed down into the recursive call, and its value will be respected.
        #
        # See issue #651 [1] for details.
        #
        # [1] &lt;https://github.com/urllib3/urllib3/issues/651&gt;
        release_this_conn = release_conn
    
        http_tunnel_required = connection_requires_http_tunnel(
            self.proxy, self.proxy_config, destination_scheme
        )
    
        # Merge the proxy headers. Only done when not using HTTP CONNECT. We
        # have to copy the headers dict so we can safely change it without those
        # changes being reflected in anyone else&#39;s copy.
        if not http_tunnel_required:
            headers = headers.copy()
            headers.update(self.proxy_headers)
    
        # Must keep the exception bound to a separate variable or else Python 3
        # complains about UnboundLocalError.
        err = None
    
        # Keep track of whether we cleanly exited the except block. This
        # ensures we do proper cleanup in finally.
        clean_exit = False
    
        # Rewind body position, if needed. Record current position
        # for future rewinds in the event of a redirect/retry.
        body_pos = set_file_position(body, body_pos)
    
        try:
            # Request a connection from the queue.
            timeout_obj = self._get_timeout(timeout)
            conn = self._get_conn(timeout=pool_timeout)
    
            conn.timeout = timeout_obj.connect_timeout
    
            is_new_proxy_conn = self.proxy is not None and not getattr(
                conn, &#34;sock&#34;, None
            )
            if is_new_proxy_conn and http_tunnel_required:
                self._prepare_proxy(conn)
    
            # Make the request on the httplib connection object.
            httplib_response = self._make_request(
                conn,
                method,
                url,
                timeout=timeout_obj,
                body=body,
                headers=headers,
                chunked=chunked,
            )
    
            # If we&#39;re going to release the connection in ``finally:``, then
            # the response doesn&#39;t need to know about the connection. Otherwise
            # it will also try to release it and we&#39;ll have a double-release
            # mess.
            response_conn = conn if not release_conn else None
    
            # Pass method to Response for length checking
            response_kw[&#34;request_method&#34;] = method
    
            # Import httplib&#39;s response into our own wrapper object
            response = self.ResponseCls.from_httplib(
                httplib_response,
                pool=self,
                connection=response_conn,
                retries=retries,
                **response_kw
            )
    
            # Everything went great!
            clean_exit = True
    
        except EmptyPoolError:
            # Didn&#39;t get a connection from the pool, no need to clean up
            clean_exit = True
            release_this_conn = False
            raise
    
        except (
            TimeoutError,
            HTTPException,
            SocketError,
            ProtocolError,
            BaseSSLError,
            SSLError,
            CertificateError,
        ) as e:
            # Discard the connection for these exceptions. It will be
            # replaced during the next _get_conn() call.
            clean_exit = False
    
            def _is_ssl_error_message_from_http_proxy(ssl_error):
                # We&#39;re trying to detect the message &#39;WRONG_VERSION_NUMBER&#39; but
                # SSLErrors are kinda all over the place when it comes to the message,
                # so we try to cover our bases here!
                message = &#34; &#34;.join(re.split(&#34;[^a-z]&#34;, str(ssl_error).lower()))
                return (
                    &#34;wrong version number&#34; in message or &#34;unknown protocol&#34; in message
                )
    
            # Try to detect a common user error with proxies which is to
            # set an HTTP proxy to be HTTPS when it should be &#39;http://&#39;
            # (ie {&#39;http&#39;: &#39;http://proxy&#39;, &#39;https&#39;: &#39;https://proxy&#39;})
            # Instead we add a nice error message and point to a URL.
            if (
                isinstance(e, BaseSSLError)
                and self.proxy
                and _is_ssl_error_message_from_http_proxy(e)
                and conn.proxy
                and conn.proxy.scheme == &#34;https&#34;
            ):
                e = ProxyError(
                    &#34;Your proxy appears to only use HTTP and not HTTPS, &#34;
                    &#34;try changing your proxy URL to be HTTP. See: &#34;
                    &#34;https://urllib3.readthedocs.io/en/1.26.x/advanced-usage.html&#34;
                    &#34;#https-proxy-error-http-proxy&#34;,
                    SSLError(e),
                )
            elif isinstance(e, (BaseSSLError, CertificateError)):
                e = SSLError(e)
            elif isinstance(e, (SocketError, NewConnectionError)) and self.proxy:
                e = ProxyError(&#34;Cannot connect to proxy.&#34;, e)
            elif isinstance(e, (SocketError, HTTPException)):
                e = ProtocolError(&#34;Connection aborted.&#34;, e)
    
            retries = retries.increment(
                method, url, error=e, _pool=self, _stacktrace=sys.exc_info()[2]
            )
            retries.sleep()
    
            # Keep track of the error for the retry warning.
            err = e
    
        finally:
            if not clean_exit:
                # We hit some kind of exception, handled or otherwise. We need
                # to throw the connection away unless explicitly told not to.
                # Close the connection, set the variable to None, and make sure
                # we put the None back in the pool to avoid leaking it.
                conn = conn and conn.close()
                release_this_conn = True
    
            if release_this_conn:
                # Put the connection back to be reused. If the connection is
                # expired then it will be None, which will get replaced with a
                # fresh connection during _get_conn.
                self._put_conn(conn)
    
        if not conn:
            # Try again
            log.warning(
                &#34;Retrying (%r) after connection broken by &#39;%r&#39;: %s&#34;, retries, err, url
            )
            return self.urlopen(
                method,
                url,
                body,
                headers,
                retries,
                redirect,
                assert_same_host,
                timeout=timeout,
                pool_timeout=pool_timeout,
                release_conn=release_conn,
                chunked=chunked,
                body_pos=body_pos,
                **response_kw
            )
    
        # Handle redirect?
        redirect_location = redirect and response.get_redirect_location()
        if redirect_location:
            if response.status == 303:
                method = &#34;GET&#34;
    
            try:
                retries = retries.increment(method, url, response=response, _pool=self)
            except MaxRetryError:
                if retries.raise_on_redirect:
                    response.drain_conn()
                    raise
                return response
    
            response.drain_conn()
            retries.sleep_for_retry(response)
            log.debug(&#34;Redirecting %s -&gt; %s&#34;, url, redirect_location)
            return self.urlopen(
                method,
                redirect_location,
                body,
                headers,
                retries=retries,
                redirect=redirect,
                assert_same_host=assert_same_host,
                timeout=timeout,
                pool_timeout=pool_timeout,
                release_conn=release_conn,
                chunked=chunked,
                body_pos=body_pos,
                **response_kw
            )
    
        # Check if we should retry the HTTP response.
        has_retry_after = bool(response.getheader(&#34;Retry-After&#34;))
        if retries.is_retry(method, response.status, has_retry_after):
            try:
                retries = retries.increment(method, url, response=response, _pool=self)
            except MaxRetryError:
                if retries.raise_on_status:
                    response.drain_conn()
                    raise
                return response
    
            response.drain_conn()
            retries.sleep(response)
            log.debug(&#34;Retry: %s&#34;, url)
&gt;           return self.urlopen(
                method,
                url,
                body,
                headers,
                retries=retries,
                redirect=redirect,
                assert_same_host=assert_same_host,
                timeout=timeout,
                pool_timeout=pool_timeout,
                release_conn=release_conn,
                chunked=chunked,
                body_pos=body_pos,
                **response_kw
            )

/usr/local/lib/python3.8/site-packages/urllib3/connectionpool.py:878: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connectionpool.HTTPSConnectionPool object at 0x7f34bbb7db80&gt;
method = &#39;GET&#39;
url = &#34;/api1/x3/erp/QAL/AOBJEXT(&#39;WYXOHRESIL&#39;)?representation=AOBJEXT.%24details&#34;
body = None
headers = {&#39;User-Agent&#39;: &#39;python-requests/2.28.1&#39;, &#39;Accept-Encoding&#39;: &#39;gzip, deflate&#39;, &#39;Accept&#39;: &#39;*/*&#39;, &#39;Connection&#39;: &#39;keep-alive&#39;, &#39;Content-Type&#39;: &#39;application/json&#39;, &#39;Authorization&#39;: &#39;Basic aW50cmFjbzpXYXNzaW1Db3ZhZ2VA&#39;}
retries = Retry(total=0, connect=None, read=None, redirect=None, status=None)
redirect = False, assert_same_host = False
timeout = Timeout(connect=None, read=None, total=None), pool_timeout = None
release_conn = False, chunked = False, body_pos = None
response_kw = {&#39;decode_content&#39;: False, &#39;preload_content&#39;: False, &#39;request_method&#39;: &#39;GET&#39;}
parsed_url = Url(scheme=None, auth=None, host=None, port=None, path=&#34;/api1/x3/erp/QAL/AOBJEXT(&#39;WYXOHRESIL&#39;)&#34;, query=&#39;representation=AOBJEXT.%24details&#39;, fragment=None)
destination_scheme = None
conn = &lt;urllib3.connection.HTTPSConnection object at 0x7f34bbae7d90&gt;
release_this_conn = False, http_tunnel_required = True, err = None
clean_exit = True

    def urlopen(
        self,
        method,
        url,
        body=None,
        headers=None,
        retries=None,
        redirect=True,
        assert_same_host=True,
        timeout=_Default,
        pool_timeout=None,
        release_conn=None,
        chunked=False,
        body_pos=None,
        **response_kw
    ):
        &#34;&#34;&#34;
        Get a connection from the pool and perform an HTTP request. This is the
        lowest level call for making a request, so you&#39;ll need to specify all
        the raw details.
    
        .. note::
    
           More commonly, it&#39;s appropriate to use a convenience method provided
           by :class:`.RequestMethods`, such as :meth:`request`.
    
        .. note::
    
           `release_conn` will only behave as expected if
           `preload_content=False` because we want to make
           `preload_content=False` the default behaviour someday soon without
           breaking backwards compatibility.
    
        :param method:
            HTTP request method (such as GET, POST, PUT, etc.)
    
        :param url:
            The URL to perform the request on.
    
        :param body:
            Data to send in the request body, either :class:`str`, :class:`bytes`,
            an iterable of :class:`str`/:class:`bytes`, or a file-like object.
    
        :param headers:
            Dictionary of custom headers to send, such as User-Agent,
            If-None-Match, etc. If None, pool headers are used. If provided,
            these headers completely replace any pool-specific headers.
    
        :param retries:
            Configure the number of retries to allow before raising a
            :class:`~urllib3.exceptions.MaxRetryError` exception.
    
            Pass ``None`` to retry until you receive a response. Pass a
            :class:`~urllib3.util.retry.Retry` object for fine-grained control
            over different types of retries.
            Pass an integer number to retry connection errors that many times,
            but no other types of errors. Pass zero to never retry.
    
            If ``False``, then retries are disabled and any exception is raised
            immediately. Also, instead of raising a MaxRetryError on redirects,
            the redirect response will be returned.
    
        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.
    
        :param redirect:
            If True, automatically handle redirects (status codes 301, 302,
            303, 307, 308). Each redirect counts as a retry. Disabling retries
            will disable redirect, too.
    
        :param assert_same_host:
            If ``True``, will make sure that the host of the pool requests is
            consistent else will raise HostChangedError. When ``False``, you can
            use the pool on an HTTP proxy and request foreign hosts.
    
        :param timeout:
            If specified, overrides the default timeout for this one
            request. It may be a float (in seconds) or an instance of
            :class:`urllib3.util.Timeout`.
    
        :param pool_timeout:
            If set and the pool is set to block=True, then this method will
            block for ``pool_timeout`` seconds and raise EmptyPoolError if no
            connection is available within the time period.
    
        :param release_conn:
            If False, then the urlopen call will not release the connection
            back into the pool once a response is received (but will release if
            you read the entire contents of the response such as when
            `preload_content=True`). This is useful if you&#39;re not preloading
            the response&#39;s content immediately. You will need to call
            ``r.release_conn()`` on the response ``r`` to return the connection
            back into the pool. If None, it takes the value of
            ``response_kw.get(&#39;preload_content&#39;, True)``.
    
        :param chunked:
            If True, urllib3 will send the body using chunked transfer
            encoding. Otherwise, urllib3 will send the body using the standard
            content-length form. Defaults to False.
    
        :param int body_pos:
            Position to seek to in file-like body in the event of a retry or
            redirect. Typically this won&#39;t need to be set because urllib3 will
            auto-populate the value when needed.
    
        :param \\**response_kw:
            Additional parameters are passed to
            :meth:`urllib3.response.HTTPResponse.from_httplib`
        &#34;&#34;&#34;
    
        parsed_url = parse_url(url)
        destination_scheme = parsed_url.scheme
    
        if headers is None:
            headers = self.headers
    
        if not isinstance(retries, Retry):
            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)
    
        if release_conn is None:
            release_conn = response_kw.get(&#34;preload_content&#34;, True)
    
        # Check host
        if assert_same_host and not self.is_same_host(url):
            raise HostChangedError(self, url, retries)
    
        # Ensure that the URL we&#39;re connecting to is properly encoded
        if url.startswith(&#34;/&#34;):
            url = six.ensure_str(_encode_target(url))
        else:
            url = six.ensure_str(parsed_url.url)
    
        conn = None
    
        # Track whether `conn` needs to be released before
        # returning/raising/recursing. Update this variable if necessary, and
        # leave `release_conn` constant throughout the function. That way, if
        # the function recurses, the original value of `release_conn` will be
        # passed down into the recursive call, and its value will be respected.
        #
        # See issue #651 [1] for details.
        #
        # [1] &lt;https://github.com/urllib3/urllib3/issues/651&gt;
        release_this_conn = release_conn
    
        http_tunnel_required = connection_requires_http_tunnel(
            self.proxy, self.proxy_config, destination_scheme
        )
    
        # Merge the proxy headers. Only done when not using HTTP CONNECT. We
        # have to copy the headers dict so we can safely change it without those
        # changes being reflected in anyone else&#39;s copy.
        if not http_tunnel_required:
            headers = headers.copy()
            headers.update(self.proxy_headers)
    
        # Must keep the exception bound to a separate variable or else Python 3
        # complains about UnboundLocalError.
        err = None
    
        # Keep track of whether we cleanly exited the except block. This
        # ensures we do proper cleanup in finally.
        clean_exit = False
    
        # Rewind body position, if needed. Record current position
        # for future rewinds in the event of a redirect/retry.
        body_pos = set_file_position(body, body_pos)
    
        try:
            # Request a connection from the queue.
            timeout_obj = self._get_timeout(timeout)
            conn = self._get_conn(timeout=pool_timeout)
    
            conn.timeout = timeout_obj.connect_timeout
    
            is_new_proxy_conn = self.proxy is not None and not getattr(
                conn, &#34;sock&#34;, None
            )
            if is_new_proxy_conn and http_tunnel_required:
                self._prepare_proxy(conn)
    
            # Make the request on the httplib connection object.
            httplib_response = self._make_request(
                conn,
                method,
                url,
                timeout=timeout_obj,
                body=body,
                headers=headers,
                chunked=chunked,
            )
    
            # If we&#39;re going to release the connection in ``finally:``, then
            # the response doesn&#39;t need to know about the connection. Otherwise
            # it will also try to release it and we&#39;ll have a double-release
            # mess.
            response_conn = conn if not release_conn else None
    
            # Pass method to Response for length checking
            response_kw[&#34;request_method&#34;] = method
    
            # Import httplib&#39;s response into our own wrapper object
            response = self.ResponseCls.from_httplib(
                httplib_response,
                pool=self,
                connection=response_conn,
                retries=retries,
                **response_kw
            )
    
            # Everything went great!
            clean_exit = True
    
        except EmptyPoolError:
            # Didn&#39;t get a connection from the pool, no need to clean up
            clean_exit = True
            release_this_conn = False
            raise
    
        except (
            TimeoutError,
            HTTPException,
            SocketError,
            ProtocolError,
            BaseSSLError,
            SSLError,
            CertificateError,
        ) as e:
            # Discard the connection for these exceptions. It will be
            # replaced during the next _get_conn() call.
            clean_exit = False
    
            def _is_ssl_error_message_from_http_proxy(ssl_error):
                # We&#39;re trying to detect the message &#39;WRONG_VERSION_NUMBER&#39; but
                # SSLErrors are kinda all over the place when it comes to the message,
                # so we try to cover our bases here!
                message = &#34; &#34;.join(re.split(&#34;[^a-z]&#34;, str(ssl_error).lower()))
                return (
                    &#34;wrong version number&#34; in message or &#34;unknown protocol&#34; in message
                )
    
            # Try to detect a common user error with proxies which is to
            # set an HTTP proxy to be HTTPS when it should be &#39;http://&#39;
            # (ie {&#39;http&#39;: &#39;http://proxy&#39;, &#39;https&#39;: &#39;https://proxy&#39;})
            # Instead we add a nice error message and point to a URL.
            if (
                isinstance(e, BaseSSLError)
                and self.proxy
                and _is_ssl_error_message_from_http_proxy(e)
                and conn.proxy
                and conn.proxy.scheme == &#34;https&#34;
            ):
                e = ProxyError(
                    &#34;Your proxy appears to only use HTTP and not HTTPS, &#34;
                    &#34;try changing your proxy URL to be HTTP. See: &#34;
                    &#34;https://urllib3.readthedocs.io/en/1.26.x/advanced-usage.html&#34;
                    &#34;#https-proxy-error-http-proxy&#34;,
                    SSLError(e),
                )
            elif isinstance(e, (BaseSSLError, CertificateError)):
                e = SSLError(e)
            elif isinstance(e, (SocketError, NewConnectionError)) and self.proxy:
                e = ProxyError(&#34;Cannot connect to proxy.&#34;, e)
            elif isinstance(e, (SocketError, HTTPException)):
                e = ProtocolError(&#34;Connection aborted.&#34;, e)
    
            retries = retries.increment(
                method, url, error=e, _pool=self, _stacktrace=sys.exc_info()[2]
            )
            retries.sleep()
    
            # Keep track of the error for the retry warning.
            err = e
    
        finally:
            if not clean_exit:
                # We hit some kind of exception, handled or otherwise. We need
                # to throw the connection away unless explicitly told not to.
                # Close the connection, set the variable to None, and make sure
                # we put the None back in the pool to avoid leaking it.
                conn = conn and conn.close()
                release_this_conn = True
    
            if release_this_conn:
                # Put the connection back to be reused. If the connection is
                # expired then it will be None, which will get replaced with a
                # fresh connection during _get_conn.
                self._put_conn(conn)
    
        if not conn:
            # Try again
            log.warning(
                &#34;Retrying (%r) after connection broken by &#39;%r&#39;: %s&#34;, retries, err, url
            )
            return self.urlopen(
                method,
                url,
                body,
                headers,
                retries,
                redirect,
                assert_same_host,
                timeout=timeout,
                pool_timeout=pool_timeout,
                release_conn=release_conn,
                chunked=chunked,
                body_pos=body_pos,
                **response_kw
            )
    
        # Handle redirect?
        redirect_location = redirect and response.get_redirect_location()
        if redirect_location:
            if response.status == 303:
                method = &#34;GET&#34;
    
            try:
                retries = retries.increment(method, url, response=response, _pool=self)
            except MaxRetryError:
                if retries.raise_on_redirect:
                    response.drain_conn()
                    raise
                return response
    
            response.drain_conn()
            retries.sleep_for_retry(response)
            log.debug(&#34;Redirecting %s -&gt; %s&#34;, url, redirect_location)
            return self.urlopen(
                method,
                redirect_location,
                body,
                headers,
                retries=retries,
                redirect=redirect,
                assert_same_host=assert_same_host,
                timeout=timeout,
                pool_timeout=pool_timeout,
                release_conn=release_conn,
                chunked=chunked,
                body_pos=body_pos,
                **response_kw
            )
    
        # Check if we should retry the HTTP response.
        has_retry_after = bool(response.getheader(&#34;Retry-After&#34;))
        if retries.is_retry(method, response.status, has_retry_after):
            try:
&gt;               retries = retries.increment(method, url, response=response, _pool=self)

/usr/local/lib/python3.8/site-packages/urllib3/connectionpool.py:868: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Retry(total=0, connect=None, read=None, redirect=None, status=None)
method = &#39;GET&#39;
url = &#34;/api1/x3/erp/QAL/AOBJEXT(&#39;WYXOHRESIL&#39;)?representation=AOBJEXT.%24details&#34;
response = &lt;urllib3.response.HTTPResponse object at 0x7f34bbae7400&gt;
error = None
_pool = &lt;urllib3.connectionpool.HTTPSConnectionPool object at 0x7f34bbb7db80&gt;
_stacktrace = None

    def increment(
        self,
        method=None,
        url=None,
        response=None,
        error=None,
        _pool=None,
        _stacktrace=None,
    ):
        &#34;&#34;&#34;Return a new Retry object with incremented retry counters.
    
        :param response: A response object, or None, if the server did not
            return a response.
        :type response: :class:`~urllib3.response.HTTPResponse`
        :param Exception error: An error encountered during the request, or
            None if the response was received successfully.
    
        :return: A new ``Retry`` object.
        &#34;&#34;&#34;
        if self.total is False and error:
            # Disabled, indicate to re-raise the error.
            raise six.reraise(type(error), error, _stacktrace)
    
        total = self.total
        if total is not None:
            total -= 1
    
        connect = self.connect
        read = self.read
        redirect = self.redirect
        status_count = self.status
        other = self.other
        cause = &#34;unknown&#34;
        status = None
        redirect_location = None
    
        if error and self._is_connection_error(error):
            # Connect retry?
            if connect is False:
                raise six.reraise(type(error), error, _stacktrace)
            elif connect is not None:
                connect -= 1
    
        elif error and self._is_read_error(error):
            # Read retry?
            if read is False or not self._is_method_retryable(method):
                raise six.reraise(type(error), error, _stacktrace)
            elif read is not None:
                read -= 1
    
        elif error:
            # Other retry?
            if other is not None:
                other -= 1
    
        elif response and response.get_redirect_location():
            # Redirect retry?
            if redirect is not None:
                redirect -= 1
            cause = &#34;too many redirects&#34;
            redirect_location = response.get_redirect_location()
            status = response.status
    
        else:
            # Incrementing because of a server error like a 500 in
            # status_forcelist and the given method is in the allowed_methods
            cause = ResponseError.GENERIC_ERROR
            if response and response.status:
                if status_count is not None:
                    status_count -= 1
                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)
                status = response.status
    
        history = self.history + (
            RequestHistory(method, url, error, status, redirect_location),
        )
    
        new_retry = self.new(
            total=total,
            connect=connect,
            read=read,
            redirect=redirect,
            status=status_count,
            other=other,
            history=history,
        )
    
        if new_retry.is_exhausted():
&gt;           raise MaxRetryError(_pool, url, error or ResponseError(cause))
E           urllib3.exceptions.MaxRetryError: HTTPSConnectionPool(host=&#39;sagex3-horsprod.covage.com&#39;, port=443): Max retries exceeded with url: /api1/x3/erp/QAL/AOBJEXT(&#39;WYXOHRESIL&#39;)?representation=AOBJEXT.%24details (Caused by ResponseError(&#39;too many 502 error responses&#39;))

/usr/local/lib/python3.8/site-packages/urllib3/util/retry.py:592: MaxRetryError

During handling of the above exception, another exception occurred:

folder = &#39;QAL&#39;

    @pytest.mark.livetest
    @pytest.mark.xfail
    @pytest.mark.parametrize(&#34;folder&#34;, [os.environ[&#34;LIVE_TEST_X3_FOLDER&#34;]])
    def test_validate_schema_WYXOHRESIL(folder):
        &#34;&#34;&#34;
        Compare diff for `WYXOHRESIL` model between local snapshot and os.environ[&#34;LIVE_TEST_X3_FOLDER&#34;]\n
        WYXOHRESIL: Terminate contract
        &#34;&#34;&#34;
&gt;       destination = get_model_schema_from_x3(&#34;WYXOHRESIL&#34;, folder=folder)

app/api/live_tests/test_validate_import_schema.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
app/api/live_tests/test_validate_import_schema.py:31: in get_model_schema_from_x3
    resp = client.get(class_name=&#34;AOBJEXT&#34;, representation=&#34;AOBJEXT&#34;, ref=model_name)
app/x3_wrapper/rest_client.py:109: in get
    resp = self._cal_x3(&#34;GET&#34;, url, query_params)
app/x3_wrapper/rest_client.py:70: in _cal_x3
    resp = self.client.request(method, url, params=query_params)
/usr/local/lib/python3.8/site-packages/requests/sessions.py:587: in request
    resp = self.send(prep, **send_kwargs)
/usr/local/lib/python3.8/site-packages/requests/sessions.py:701: in send
    r = adapter.send(request, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;requests.adapters.HTTPAdapter object at 0x7f34bbb7daf0&gt;
request = &lt;PreparedRequest [GET]&gt;, stream = False
timeout = Timeout(connect=None, read=None, total=None), verify = True
cert = None
proxies = OrderedDict([(&#39;no&#39;, &#39;gitlab-runner-cache-01-prd.nut.covage.com&#39;), (&#39;http&#39;, &#39;http://squid.kosc.net:3128&#39;), (&#39;https&#39;, &#39;http://squid.kosc.net:3128&#39;)])

    def send(
        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None
    ):
        &#34;&#34;&#34;Sends PreparedRequest object. Returns Response object.
    
        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.
        :param stream: (optional) Whether to stream the request content.
        :param timeout: (optional) How long to wait for the server to send
            data before giving up, as a float, or a :ref:`(connect timeout,
            read timeout) &lt;timeouts&gt;` tuple.
        :type timeout: float or tuple or urllib3 Timeout object
        :param verify: (optional) Either a boolean, in which case it controls whether
            we verify the server&#39;s TLS certificate, or a string, in which case it
            must be a path to a CA bundle to use
        :param cert: (optional) Any user-provided SSL certificate to be trusted.
        :param proxies: (optional) The proxies dictionary to apply to the request.
        :rtype: requests.Response
        &#34;&#34;&#34;
    
        try:
            conn = self.get_connection(request.url, proxies)
        except LocationValueError as e:
            raise InvalidURL(e, request=request)
    
        self.cert_verify(conn, request.url, verify, cert)
        url = self.request_url(request, proxies)
        self.add_headers(
            request,
            stream=stream,
            timeout=timeout,
            verify=verify,
            cert=cert,
            proxies=proxies,
        )
    
        chunked = not (request.body is None or &#34;Content-Length&#34; in request.headers)
    
        if isinstance(timeout, tuple):
            try:
                connect, read = timeout
                timeout = TimeoutSauce(connect=connect, read=read)
            except ValueError:
                raise ValueError(
                    f&#34;Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, &#34;
                    f&#34;or a single float to set both timeouts to the same value.&#34;
                )
        elif isinstance(timeout, TimeoutSauce):
            pass
        else:
            timeout = TimeoutSauce(connect=timeout, read=timeout)
    
        try:
            if not chunked:
                resp = conn.urlopen(
                    method=request.method,
                    url=url,
                    body=request.body,
                    headers=request.headers,
                    redirect=False,
                    assert_same_host=False,
                    preload_content=False,
                    decode_content=False,
                    retries=self.max_retries,
                    timeout=timeout,
                )
    
            # Send the request.
            else:
                if hasattr(conn, &#34;proxy_pool&#34;):
                    conn = conn.proxy_pool
    
                low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)
    
                try:
                    skip_host = &#34;Host&#34; in request.headers
                    low_conn.putrequest(
                        request.method,
                        url,
                        skip_accept_encoding=True,
                        skip_host=skip_host,
                    )
    
                    for header, value in request.headers.items():
                        low_conn.putheader(header, value)
    
                    low_conn.endheaders()
    
                    for i in request.body:
                        low_conn.send(hex(len(i))[2:].encode(&#34;utf-8&#34;))
                        low_conn.send(b&#34;\r\n&#34;)
                        low_conn.send(i)
                        low_conn.send(b&#34;\r\n&#34;)
                    low_conn.send(b&#34;0\r\n\r\n&#34;)
    
                    # Receive the response from the server
                    r = low_conn.getresponse()
    
                    resp = HTTPResponse.from_httplib(
                        r,
                        pool=conn,
                        connection=low_conn,
                        preload_content=False,
                        decode_content=False,
                    )
                except Exception:
                    # If we hit any problems here, clean up the connection.
                    # Then, raise so that we can handle the actual exception.
                    low_conn.close()
                    raise
    
        except (ProtocolError, OSError) as err:
            raise ConnectionError(err, request=request)
    
        except MaxRetryError as e:
            if isinstance(e.reason, ConnectTimeoutError):
                # TODO: Remove this in 3.0.0: see #2811
                if not isinstance(e.reason, NewConnectionError):
                    raise ConnectTimeout(e, request=request)
    
            if isinstance(e.reason, ResponseError):
&gt;               raise RetryError(e, request=request)
E               requests.exceptions.RetryError: HTTPSConnectionPool(host=&#39;sagex3-horsprod.covage.com&#39;, port=443): Max retries exceeded with url: /api1/x3/erp/QAL/AOBJEXT(&#39;WYXOHRESIL&#39;)?representation=AOBJEXT.%24details (Caused by ResponseError(&#39;too many 502 error responses&#39;))

/usr/local/lib/python3.8/site-packages/requests/adapters.py:556: RetryError</pre> </div> </div> </details> <details class="phase teardown "> <summary> <h4 class=title> <span class=phase-name>Teardown</span> </h4> </summary> <div class=content> </div> </details> </div> </div> </details> <details class="test xfailed"> <summary> <h3 class="title test-title"> <span class="status badge xfailed ">XFAIL</span> <span class=test-name> <span class=funcname>test_validate_schema_WYXOHADD</span><span class=params>[QAL]</span> </span> <span class=duration>0:00:00.654355</span> </h3> </summary> <div class=content> <div class=documentation> <p>Compare diff for <cite>WYXOHUPGRA</cite> model between local snapshot and os.environ[&quot;LIVE_TEST_X3_FOLDER&quot;]</p> <p>WYXOHUPGRA: Ajouter options contract</p> </div> <table class=metadata> <tr> <th>Started</th> <td>2023-06-30 01:14:38</td> </tr> <tr> <th>Ended</th> <td>2023-06-30 01:14:39</td> </tr> <tr> <th>Duration</th> <td>0:00:00.654355</td> </tr> <tr> <th>Markers</th> <td> <div class=marker> <span class="marker-name badge">xfail</span> <span class=marker-args> </span> </div> <div class=marker> <span class="marker-name badge">livetest</span> <span class=marker-args> </span> </div> </td> </tr> <tr> <th>Fixtures</th> <td> <span class="badge fixturename"> django_test_environment </span> <span class="badge fixturename"> django_db_blocker </span> <span class="badge fixturename"> folder </span> <span class="badge fixturename"> request </span> </td> </tr> </table> <div class=repr> <pre>requests.exceptions.RetryError: HTTPSConnectionPool(host=&#39;sagex3-horsprod.covage.com&#39;, port=443): Max retries exceeded with url: /api1/x3/erp/QAL/AOBJEXT(&#39;WYXOHADD&#39;)?representation=AOBJEXT.%24details (Caused by ResponseError(&#39;too many 502 error responses&#39;))</pre> </div> <div class=test-phases> <details class="phase setup "> <summary> <h4 class=title> <span class=phase-name>Setup</span> </h4> </summary> <div class=content> </div> </details> <details class="phase call xfailed" open> <summary> <h4 class=title> <span class="status  xfailed"></span> <span class=phase-name>Call</span> </h4> </summary> <div class=content> <div class=repr> <pre>self = &lt;requests.adapters.HTTPAdapter object at 0x7f34c007b640&gt;
request = &lt;PreparedRequest [GET]&gt;, stream = False
timeout = Timeout(connect=None, read=None, total=None), verify = True
cert = None
proxies = OrderedDict([(&#39;no&#39;, &#39;gitlab-runner-cache-01-prd.nut.covage.com&#39;), (&#39;http&#39;, &#39;http://squid.kosc.net:3128&#39;), (&#39;https&#39;, &#39;http://squid.kosc.net:3128&#39;)])

    def send(
        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None
    ):
        &#34;&#34;&#34;Sends PreparedRequest object. Returns Response object.
    
        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.
        :param stream: (optional) Whether to stream the request content.
        :param timeout: (optional) How long to wait for the server to send
            data before giving up, as a float, or a :ref:`(connect timeout,
            read timeout) &lt;timeouts&gt;` tuple.
        :type timeout: float or tuple or urllib3 Timeout object
        :param verify: (optional) Either a boolean, in which case it controls whether
            we verify the server&#39;s TLS certificate, or a string, in which case it
            must be a path to a CA bundle to use
        :param cert: (optional) Any user-provided SSL certificate to be trusted.
        :param proxies: (optional) The proxies dictionary to apply to the request.
        :rtype: requests.Response
        &#34;&#34;&#34;
    
        try:
            conn = self.get_connection(request.url, proxies)
        except LocationValueError as e:
            raise InvalidURL(e, request=request)
    
        self.cert_verify(conn, request.url, verify, cert)
        url = self.request_url(request, proxies)
        self.add_headers(
            request,
            stream=stream,
            timeout=timeout,
            verify=verify,
            cert=cert,
            proxies=proxies,
        )
    
        chunked = not (request.body is None or &#34;Content-Length&#34; in request.headers)
    
        if isinstance(timeout, tuple):
            try:
                connect, read = timeout
                timeout = TimeoutSauce(connect=connect, read=read)
            except ValueError:
                raise ValueError(
                    f&#34;Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, &#34;
                    f&#34;or a single float to set both timeouts to the same value.&#34;
                )
        elif isinstance(timeout, TimeoutSauce):
            pass
        else:
            timeout = TimeoutSauce(connect=timeout, read=timeout)
    
        try:
            if not chunked:
&gt;               resp = conn.urlopen(
                    method=request.method,
                    url=url,
                    body=request.body,
                    headers=request.headers,
                    redirect=False,
                    assert_same_host=False,
                    preload_content=False,
                    decode_content=False,
                    retries=self.max_retries,
                    timeout=timeout,
                )

/usr/local/lib/python3.8/site-packages/requests/adapters.py:489: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connectionpool.HTTPSConnectionPool object at 0x7f34c007bfa0&gt;
method = &#39;GET&#39;
url = &#34;/api1/x3/erp/QAL/AOBJEXT(&#39;WYXOHADD&#39;)?representation=AOBJEXT.%24details&#34;
body = None
headers = {&#39;User-Agent&#39;: &#39;python-requests/2.28.1&#39;, &#39;Accept-Encoding&#39;: &#39;gzip, deflate&#39;, &#39;Accept&#39;: &#39;*/*&#39;, &#39;Connection&#39;: &#39;keep-alive&#39;, &#39;Content-Type&#39;: &#39;application/json&#39;, &#39;Authorization&#39;: &#39;Basic aW50cmFjbzpXYXNzaW1Db3ZhZ2VA&#39;}
retries = Retry(total=2, connect=None, read=None, redirect=None, status=None)
redirect = False, assert_same_host = False
timeout = Timeout(connect=None, read=None, total=None), pool_timeout = None
release_conn = False, chunked = False, body_pos = None
response_kw = {&#39;decode_content&#39;: False, &#39;preload_content&#39;: False, &#39;request_method&#39;: &#39;GET&#39;}
parsed_url = Url(scheme=None, auth=None, host=None, port=None, path=&#34;/api1/x3/erp/QAL/AOBJEXT(&#39;WYXOHADD&#39;)&#34;, query=&#39;representation=AOBJEXT.%24details&#39;, fragment=None)
destination_scheme = None
conn = &lt;urllib3.connection.HTTPSConnection object at 0x7f34bbd8baf0&gt;
release_this_conn = False, http_tunnel_required = True, err = None
clean_exit = True

    def urlopen(
        self,
        method,
        url,
        body=None,
        headers=None,
        retries=None,
        redirect=True,
        assert_same_host=True,
        timeout=_Default,
        pool_timeout=None,
        release_conn=None,
        chunked=False,
        body_pos=None,
        **response_kw
    ):
        &#34;&#34;&#34;
        Get a connection from the pool and perform an HTTP request. This is the
        lowest level call for making a request, so you&#39;ll need to specify all
        the raw details.
    
        .. note::
    
           More commonly, it&#39;s appropriate to use a convenience method provided
           by :class:`.RequestMethods`, such as :meth:`request`.
    
        .. note::
    
           `release_conn` will only behave as expected if
           `preload_content=False` because we want to make
           `preload_content=False` the default behaviour someday soon without
           breaking backwards compatibility.
    
        :param method:
            HTTP request method (such as GET, POST, PUT, etc.)
    
        :param url:
            The URL to perform the request on.
    
        :param body:
            Data to send in the request body, either :class:`str`, :class:`bytes`,
            an iterable of :class:`str`/:class:`bytes`, or a file-like object.
    
        :param headers:
            Dictionary of custom headers to send, such as User-Agent,
            If-None-Match, etc. If None, pool headers are used. If provided,
            these headers completely replace any pool-specific headers.
    
        :param retries:
            Configure the number of retries to allow before raising a
            :class:`~urllib3.exceptions.MaxRetryError` exception.
    
            Pass ``None`` to retry until you receive a response. Pass a
            :class:`~urllib3.util.retry.Retry` object for fine-grained control
            over different types of retries.
            Pass an integer number to retry connection errors that many times,
            but no other types of errors. Pass zero to never retry.
    
            If ``False``, then retries are disabled and any exception is raised
            immediately. Also, instead of raising a MaxRetryError on redirects,
            the redirect response will be returned.
    
        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.
    
        :param redirect:
            If True, automatically handle redirects (status codes 301, 302,
            303, 307, 308). Each redirect counts as a retry. Disabling retries
            will disable redirect, too.
    
        :param assert_same_host:
            If ``True``, will make sure that the host of the pool requests is
            consistent else will raise HostChangedError. When ``False``, you can
            use the pool on an HTTP proxy and request foreign hosts.
    
        :param timeout:
            If specified, overrides the default timeout for this one
            request. It may be a float (in seconds) or an instance of
            :class:`urllib3.util.Timeout`.
    
        :param pool_timeout:
            If set and the pool is set to block=True, then this method will
            block for ``pool_timeout`` seconds and raise EmptyPoolError if no
            connection is available within the time period.
    
        :param release_conn:
            If False, then the urlopen call will not release the connection
            back into the pool once a response is received (but will release if
            you read the entire contents of the response such as when
            `preload_content=True`). This is useful if you&#39;re not preloading
            the response&#39;s content immediately. You will need to call
            ``r.release_conn()`` on the response ``r`` to return the connection
            back into the pool. If None, it takes the value of
            ``response_kw.get(&#39;preload_content&#39;, True)``.
    
        :param chunked:
            If True, urllib3 will send the body using chunked transfer
            encoding. Otherwise, urllib3 will send the body using the standard
            content-length form. Defaults to False.
    
        :param int body_pos:
            Position to seek to in file-like body in the event of a retry or
            redirect. Typically this won&#39;t need to be set because urllib3 will
            auto-populate the value when needed.
    
        :param \\**response_kw:
            Additional parameters are passed to
            :meth:`urllib3.response.HTTPResponse.from_httplib`
        &#34;&#34;&#34;
    
        parsed_url = parse_url(url)
        destination_scheme = parsed_url.scheme
    
        if headers is None:
            headers = self.headers
    
        if not isinstance(retries, Retry):
            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)
    
        if release_conn is None:
            release_conn = response_kw.get(&#34;preload_content&#34;, True)
    
        # Check host
        if assert_same_host and not self.is_same_host(url):
            raise HostChangedError(self, url, retries)
    
        # Ensure that the URL we&#39;re connecting to is properly encoded
        if url.startswith(&#34;/&#34;):
            url = six.ensure_str(_encode_target(url))
        else:
            url = six.ensure_str(parsed_url.url)
    
        conn = None
    
        # Track whether `conn` needs to be released before
        # returning/raising/recursing. Update this variable if necessary, and
        # leave `release_conn` constant throughout the function. That way, if
        # the function recurses, the original value of `release_conn` will be
        # passed down into the recursive call, and its value will be respected.
        #
        # See issue #651 [1] for details.
        #
        # [1] &lt;https://github.com/urllib3/urllib3/issues/651&gt;
        release_this_conn = release_conn
    
        http_tunnel_required = connection_requires_http_tunnel(
            self.proxy, self.proxy_config, destination_scheme
        )
    
        # Merge the proxy headers. Only done when not using HTTP CONNECT. We
        # have to copy the headers dict so we can safely change it without those
        # changes being reflected in anyone else&#39;s copy.
        if not http_tunnel_required:
            headers = headers.copy()
            headers.update(self.proxy_headers)
    
        # Must keep the exception bound to a separate variable or else Python 3
        # complains about UnboundLocalError.
        err = None
    
        # Keep track of whether we cleanly exited the except block. This
        # ensures we do proper cleanup in finally.
        clean_exit = False
    
        # Rewind body position, if needed. Record current position
        # for future rewinds in the event of a redirect/retry.
        body_pos = set_file_position(body, body_pos)
    
        try:
            # Request a connection from the queue.
            timeout_obj = self._get_timeout(timeout)
            conn = self._get_conn(timeout=pool_timeout)
    
            conn.timeout = timeout_obj.connect_timeout
    
            is_new_proxy_conn = self.proxy is not None and not getattr(
                conn, &#34;sock&#34;, None
            )
            if is_new_proxy_conn and http_tunnel_required:
                self._prepare_proxy(conn)
    
            # Make the request on the httplib connection object.
            httplib_response = self._make_request(
                conn,
                method,
                url,
                timeout=timeout_obj,
                body=body,
                headers=headers,
                chunked=chunked,
            )
    
            # If we&#39;re going to release the connection in ``finally:``, then
            # the response doesn&#39;t need to know about the connection. Otherwise
            # it will also try to release it and we&#39;ll have a double-release
            # mess.
            response_conn = conn if not release_conn else None
    
            # Pass method to Response for length checking
            response_kw[&#34;request_method&#34;] = method
    
            # Import httplib&#39;s response into our own wrapper object
            response = self.ResponseCls.from_httplib(
                httplib_response,
                pool=self,
                connection=response_conn,
                retries=retries,
                **response_kw
            )
    
            # Everything went great!
            clean_exit = True
    
        except EmptyPoolError:
            # Didn&#39;t get a connection from the pool, no need to clean up
            clean_exit = True
            release_this_conn = False
            raise
    
        except (
            TimeoutError,
            HTTPException,
            SocketError,
            ProtocolError,
            BaseSSLError,
            SSLError,
            CertificateError,
        ) as e:
            # Discard the connection for these exceptions. It will be
            # replaced during the next _get_conn() call.
            clean_exit = False
    
            def _is_ssl_error_message_from_http_proxy(ssl_error):
                # We&#39;re trying to detect the message &#39;WRONG_VERSION_NUMBER&#39; but
                # SSLErrors are kinda all over the place when it comes to the message,
                # so we try to cover our bases here!
                message = &#34; &#34;.join(re.split(&#34;[^a-z]&#34;, str(ssl_error).lower()))
                return (
                    &#34;wrong version number&#34; in message or &#34;unknown protocol&#34; in message
                )
    
            # Try to detect a common user error with proxies which is to
            # set an HTTP proxy to be HTTPS when it should be &#39;http://&#39;
            # (ie {&#39;http&#39;: &#39;http://proxy&#39;, &#39;https&#39;: &#39;https://proxy&#39;})
            # Instead we add a nice error message and point to a URL.
            if (
                isinstance(e, BaseSSLError)
                and self.proxy
                and _is_ssl_error_message_from_http_proxy(e)
                and conn.proxy
                and conn.proxy.scheme == &#34;https&#34;
            ):
                e = ProxyError(
                    &#34;Your proxy appears to only use HTTP and not HTTPS, &#34;
                    &#34;try changing your proxy URL to be HTTP. See: &#34;
                    &#34;https://urllib3.readthedocs.io/en/1.26.x/advanced-usage.html&#34;
                    &#34;#https-proxy-error-http-proxy&#34;,
                    SSLError(e),
                )
            elif isinstance(e, (BaseSSLError, CertificateError)):
                e = SSLError(e)
            elif isinstance(e, (SocketError, NewConnectionError)) and self.proxy:
                e = ProxyError(&#34;Cannot connect to proxy.&#34;, e)
            elif isinstance(e, (SocketError, HTTPException)):
                e = ProtocolError(&#34;Connection aborted.&#34;, e)
    
            retries = retries.increment(
                method, url, error=e, _pool=self, _stacktrace=sys.exc_info()[2]
            )
            retries.sleep()
    
            # Keep track of the error for the retry warning.
            err = e
    
        finally:
            if not clean_exit:
                # We hit some kind of exception, handled or otherwise. We need
                # to throw the connection away unless explicitly told not to.
                # Close the connection, set the variable to None, and make sure
                # we put the None back in the pool to avoid leaking it.
                conn = conn and conn.close()
                release_this_conn = True
    
            if release_this_conn:
                # Put the connection back to be reused. If the connection is
                # expired then it will be None, which will get replaced with a
                # fresh connection during _get_conn.
                self._put_conn(conn)
    
        if not conn:
            # Try again
            log.warning(
                &#34;Retrying (%r) after connection broken by &#39;%r&#39;: %s&#34;, retries, err, url
            )
            return self.urlopen(
                method,
                url,
                body,
                headers,
                retries,
                redirect,
                assert_same_host,
                timeout=timeout,
                pool_timeout=pool_timeout,
                release_conn=release_conn,
                chunked=chunked,
                body_pos=body_pos,
                **response_kw
            )
    
        # Handle redirect?
        redirect_location = redirect and response.get_redirect_location()
        if redirect_location:
            if response.status == 303:
                method = &#34;GET&#34;
    
            try:
                retries = retries.increment(method, url, response=response, _pool=self)
            except MaxRetryError:
                if retries.raise_on_redirect:
                    response.drain_conn()
                    raise
                return response
    
            response.drain_conn()
            retries.sleep_for_retry(response)
            log.debug(&#34;Redirecting %s -&gt; %s&#34;, url, redirect_location)
            return self.urlopen(
                method,
                redirect_location,
                body,
                headers,
                retries=retries,
                redirect=redirect,
                assert_same_host=assert_same_host,
                timeout=timeout,
                pool_timeout=pool_timeout,
                release_conn=release_conn,
                chunked=chunked,
                body_pos=body_pos,
                **response_kw
            )
    
        # Check if we should retry the HTTP response.
        has_retry_after = bool(response.getheader(&#34;Retry-After&#34;))
        if retries.is_retry(method, response.status, has_retry_after):
            try:
                retries = retries.increment(method, url, response=response, _pool=self)
            except MaxRetryError:
                if retries.raise_on_status:
                    response.drain_conn()
                    raise
                return response
    
            response.drain_conn()
            retries.sleep(response)
            log.debug(&#34;Retry: %s&#34;, url)
&gt;           return self.urlopen(
                method,
                url,
                body,
                headers,
                retries=retries,
                redirect=redirect,
                assert_same_host=assert_same_host,
                timeout=timeout,
                pool_timeout=pool_timeout,
                release_conn=release_conn,
                chunked=chunked,
                body_pos=body_pos,
                **response_kw
            )

/usr/local/lib/python3.8/site-packages/urllib3/connectionpool.py:878: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connectionpool.HTTPSConnectionPool object at 0x7f34c007bfa0&gt;
method = &#39;GET&#39;
url = &#34;/api1/x3/erp/QAL/AOBJEXT(&#39;WYXOHADD&#39;)?representation=AOBJEXT.%24details&#34;
body = None
headers = {&#39;User-Agent&#39;: &#39;python-requests/2.28.1&#39;, &#39;Accept-Encoding&#39;: &#39;gzip, deflate&#39;, &#39;Accept&#39;: &#39;*/*&#39;, &#39;Connection&#39;: &#39;keep-alive&#39;, &#39;Content-Type&#39;: &#39;application/json&#39;, &#39;Authorization&#39;: &#39;Basic aW50cmFjbzpXYXNzaW1Db3ZhZ2VA&#39;}
retries = Retry(total=1, connect=None, read=None, redirect=None, status=None)
redirect = False, assert_same_host = False
timeout = Timeout(connect=None, read=None, total=None), pool_timeout = None
release_conn = False, chunked = False, body_pos = None
response_kw = {&#39;decode_content&#39;: False, &#39;preload_content&#39;: False, &#39;request_method&#39;: &#39;GET&#39;}
parsed_url = Url(scheme=None, auth=None, host=None, port=None, path=&#34;/api1/x3/erp/QAL/AOBJEXT(&#39;WYXOHADD&#39;)&#34;, query=&#39;representation=AOBJEXT.%24details&#39;, fragment=None)
destination_scheme = None
conn = &lt;urllib3.connection.HTTPSConnection object at 0x7f34bbd8baf0&gt;
release_this_conn = False, http_tunnel_required = True, err = None
clean_exit = True

    def urlopen(
        self,
        method,
        url,
        body=None,
        headers=None,
        retries=None,
        redirect=True,
        assert_same_host=True,
        timeout=_Default,
        pool_timeout=None,
        release_conn=None,
        chunked=False,
        body_pos=None,
        **response_kw
    ):
        &#34;&#34;&#34;
        Get a connection from the pool and perform an HTTP request. This is the
        lowest level call for making a request, so you&#39;ll need to specify all
        the raw details.
    
        .. note::
    
           More commonly, it&#39;s appropriate to use a convenience method provided
           by :class:`.RequestMethods`, such as :meth:`request`.
    
        .. note::
    
           `release_conn` will only behave as expected if
           `preload_content=False` because we want to make
           `preload_content=False` the default behaviour someday soon without
           breaking backwards compatibility.
    
        :param method:
            HTTP request method (such as GET, POST, PUT, etc.)
    
        :param url:
            The URL to perform the request on.
    
        :param body:
            Data to send in the request body, either :class:`str`, :class:`bytes`,
            an iterable of :class:`str`/:class:`bytes`, or a file-like object.
    
        :param headers:
            Dictionary of custom headers to send, such as User-Agent,
            If-None-Match, etc. If None, pool headers are used. If provided,
            these headers completely replace any pool-specific headers.
    
        :param retries:
            Configure the number of retries to allow before raising a
            :class:`~urllib3.exceptions.MaxRetryError` exception.
    
            Pass ``None`` to retry until you receive a response. Pass a
            :class:`~urllib3.util.retry.Retry` object for fine-grained control
            over different types of retries.
            Pass an integer number to retry connection errors that many times,
            but no other types of errors. Pass zero to never retry.
    
            If ``False``, then retries are disabled and any exception is raised
            immediately. Also, instead of raising a MaxRetryError on redirects,
            the redirect response will be returned.
    
        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.
    
        :param redirect:
            If True, automatically handle redirects (status codes 301, 302,
            303, 307, 308). Each redirect counts as a retry. Disabling retries
            will disable redirect, too.
    
        :param assert_same_host:
            If ``True``, will make sure that the host of the pool requests is
            consistent else will raise HostChangedError. When ``False``, you can
            use the pool on an HTTP proxy and request foreign hosts.
    
        :param timeout:
            If specified, overrides the default timeout for this one
            request. It may be a float (in seconds) or an instance of
            :class:`urllib3.util.Timeout`.
    
        :param pool_timeout:
            If set and the pool is set to block=True, then this method will
            block for ``pool_timeout`` seconds and raise EmptyPoolError if no
            connection is available within the time period.
    
        :param release_conn:
            If False, then the urlopen call will not release the connection
            back into the pool once a response is received (but will release if
            you read the entire contents of the response such as when
            `preload_content=True`). This is useful if you&#39;re not preloading
            the response&#39;s content immediately. You will need to call
            ``r.release_conn()`` on the response ``r`` to return the connection
            back into the pool. If None, it takes the value of
            ``response_kw.get(&#39;preload_content&#39;, True)``.
    
        :param chunked:
            If True, urllib3 will send the body using chunked transfer
            encoding. Otherwise, urllib3 will send the body using the standard
            content-length form. Defaults to False.
    
        :param int body_pos:
            Position to seek to in file-like body in the event of a retry or
            redirect. Typically this won&#39;t need to be set because urllib3 will
            auto-populate the value when needed.
    
        :param \\**response_kw:
            Additional parameters are passed to
            :meth:`urllib3.response.HTTPResponse.from_httplib`
        &#34;&#34;&#34;
    
        parsed_url = parse_url(url)
        destination_scheme = parsed_url.scheme
    
        if headers is None:
            headers = self.headers
    
        if not isinstance(retries, Retry):
            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)
    
        if release_conn is None:
            release_conn = response_kw.get(&#34;preload_content&#34;, True)
    
        # Check host
        if assert_same_host and not self.is_same_host(url):
            raise HostChangedError(self, url, retries)
    
        # Ensure that the URL we&#39;re connecting to is properly encoded
        if url.startswith(&#34;/&#34;):
            url = six.ensure_str(_encode_target(url))
        else:
            url = six.ensure_str(parsed_url.url)
    
        conn = None
    
        # Track whether `conn` needs to be released before
        # returning/raising/recursing. Update this variable if necessary, and
        # leave `release_conn` constant throughout the function. That way, if
        # the function recurses, the original value of `release_conn` will be
        # passed down into the recursive call, and its value will be respected.
        #
        # See issue #651 [1] for details.
        #
        # [1] &lt;https://github.com/urllib3/urllib3/issues/651&gt;
        release_this_conn = release_conn
    
        http_tunnel_required = connection_requires_http_tunnel(
            self.proxy, self.proxy_config, destination_scheme
        )
    
        # Merge the proxy headers. Only done when not using HTTP CONNECT. We
        # have to copy the headers dict so we can safely change it without those
        # changes being reflected in anyone else&#39;s copy.
        if not http_tunnel_required:
            headers = headers.copy()
            headers.update(self.proxy_headers)
    
        # Must keep the exception bound to a separate variable or else Python 3
        # complains about UnboundLocalError.
        err = None
    
        # Keep track of whether we cleanly exited the except block. This
        # ensures we do proper cleanup in finally.
        clean_exit = False
    
        # Rewind body position, if needed. Record current position
        # for future rewinds in the event of a redirect/retry.
        body_pos = set_file_position(body, body_pos)
    
        try:
            # Request a connection from the queue.
            timeout_obj = self._get_timeout(timeout)
            conn = self._get_conn(timeout=pool_timeout)
    
            conn.timeout = timeout_obj.connect_timeout
    
            is_new_proxy_conn = self.proxy is not None and not getattr(
                conn, &#34;sock&#34;, None
            )
            if is_new_proxy_conn and http_tunnel_required:
                self._prepare_proxy(conn)
    
            # Make the request on the httplib connection object.
            httplib_response = self._make_request(
                conn,
                method,
                url,
                timeout=timeout_obj,
                body=body,
                headers=headers,
                chunked=chunked,
            )
    
            # If we&#39;re going to release the connection in ``finally:``, then
            # the response doesn&#39;t need to know about the connection. Otherwise
            # it will also try to release it and we&#39;ll have a double-release
            # mess.
            response_conn = conn if not release_conn else None
    
            # Pass method to Response for length checking
            response_kw[&#34;request_method&#34;] = method
    
            # Import httplib&#39;s response into our own wrapper object
            response = self.ResponseCls.from_httplib(
                httplib_response,
                pool=self,
                connection=response_conn,
                retries=retries,
                **response_kw
            )
    
            # Everything went great!
            clean_exit = True
    
        except EmptyPoolError:
            # Didn&#39;t get a connection from the pool, no need to clean up
            clean_exit = True
            release_this_conn = False
            raise
    
        except (
            TimeoutError,
            HTTPException,
            SocketError,
            ProtocolError,
            BaseSSLError,
            SSLError,
            CertificateError,
        ) as e:
            # Discard the connection for these exceptions. It will be
            # replaced during the next _get_conn() call.
            clean_exit = False
    
            def _is_ssl_error_message_from_http_proxy(ssl_error):
                # We&#39;re trying to detect the message &#39;WRONG_VERSION_NUMBER&#39; but
                # SSLErrors are kinda all over the place when it comes to the message,
                # so we try to cover our bases here!
                message = &#34; &#34;.join(re.split(&#34;[^a-z]&#34;, str(ssl_error).lower()))
                return (
                    &#34;wrong version number&#34; in message or &#34;unknown protocol&#34; in message
                )
    
            # Try to detect a common user error with proxies which is to
            # set an HTTP proxy to be HTTPS when it should be &#39;http://&#39;
            # (ie {&#39;http&#39;: &#39;http://proxy&#39;, &#39;https&#39;: &#39;https://proxy&#39;})
            # Instead we add a nice error message and point to a URL.
            if (
                isinstance(e, BaseSSLError)
                and self.proxy
                and _is_ssl_error_message_from_http_proxy(e)
                and conn.proxy
                and conn.proxy.scheme == &#34;https&#34;
            ):
                e = ProxyError(
                    &#34;Your proxy appears to only use HTTP and not HTTPS, &#34;
                    &#34;try changing your proxy URL to be HTTP. See: &#34;
                    &#34;https://urllib3.readthedocs.io/en/1.26.x/advanced-usage.html&#34;
                    &#34;#https-proxy-error-http-proxy&#34;,
                    SSLError(e),
                )
            elif isinstance(e, (BaseSSLError, CertificateError)):
                e = SSLError(e)
            elif isinstance(e, (SocketError, NewConnectionError)) and self.proxy:
                e = ProxyError(&#34;Cannot connect to proxy.&#34;, e)
            elif isinstance(e, (SocketError, HTTPException)):
                e = ProtocolError(&#34;Connection aborted.&#34;, e)
    
            retries = retries.increment(
                method, url, error=e, _pool=self, _stacktrace=sys.exc_info()[2]
            )
            retries.sleep()
    
            # Keep track of the error for the retry warning.
            err = e
    
        finally:
            if not clean_exit:
                # We hit some kind of exception, handled or otherwise. We need
                # to throw the connection away unless explicitly told not to.
                # Close the connection, set the variable to None, and make sure
                # we put the None back in the pool to avoid leaking it.
                conn = conn and conn.close()
                release_this_conn = True
    
            if release_this_conn:
                # Put the connection back to be reused. If the connection is
                # expired then it will be None, which will get replaced with a
                # fresh connection during _get_conn.
                self._put_conn(conn)
    
        if not conn:
            # Try again
            log.warning(
                &#34;Retrying (%r) after connection broken by &#39;%r&#39;: %s&#34;, retries, err, url
            )
            return self.urlopen(
                method,
                url,
                body,
                headers,
                retries,
                redirect,
                assert_same_host,
                timeout=timeout,
                pool_timeout=pool_timeout,
                release_conn=release_conn,
                chunked=chunked,
                body_pos=body_pos,
                **response_kw
            )
    
        # Handle redirect?
        redirect_location = redirect and response.get_redirect_location()
        if redirect_location:
            if response.status == 303:
                method = &#34;GET&#34;
    
            try:
                retries = retries.increment(method, url, response=response, _pool=self)
            except MaxRetryError:
                if retries.raise_on_redirect:
                    response.drain_conn()
                    raise
                return response
    
            response.drain_conn()
            retries.sleep_for_retry(response)
            log.debug(&#34;Redirecting %s -&gt; %s&#34;, url, redirect_location)
            return self.urlopen(
                method,
                redirect_location,
                body,
                headers,
                retries=retries,
                redirect=redirect,
                assert_same_host=assert_same_host,
                timeout=timeout,
                pool_timeout=pool_timeout,
                release_conn=release_conn,
                chunked=chunked,
                body_pos=body_pos,
                **response_kw
            )
    
        # Check if we should retry the HTTP response.
        has_retry_after = bool(response.getheader(&#34;Retry-After&#34;))
        if retries.is_retry(method, response.status, has_retry_after):
            try:
                retries = retries.increment(method, url, response=response, _pool=self)
            except MaxRetryError:
                if retries.raise_on_status:
                    response.drain_conn()
                    raise
                return response
    
            response.drain_conn()
            retries.sleep(response)
            log.debug(&#34;Retry: %s&#34;, url)
&gt;           return self.urlopen(
                method,
                url,
                body,
                headers,
                retries=retries,
                redirect=redirect,
                assert_same_host=assert_same_host,
                timeout=timeout,
                pool_timeout=pool_timeout,
                release_conn=release_conn,
                chunked=chunked,
                body_pos=body_pos,
                **response_kw
            )

/usr/local/lib/python3.8/site-packages/urllib3/connectionpool.py:878: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connectionpool.HTTPSConnectionPool object at 0x7f34c007bfa0&gt;
method = &#39;GET&#39;
url = &#34;/api1/x3/erp/QAL/AOBJEXT(&#39;WYXOHADD&#39;)?representation=AOBJEXT.%24details&#34;
body = None
headers = {&#39;User-Agent&#39;: &#39;python-requests/2.28.1&#39;, &#39;Accept-Encoding&#39;: &#39;gzip, deflate&#39;, &#39;Accept&#39;: &#39;*/*&#39;, &#39;Connection&#39;: &#39;keep-alive&#39;, &#39;Content-Type&#39;: &#39;application/json&#39;, &#39;Authorization&#39;: &#39;Basic aW50cmFjbzpXYXNzaW1Db3ZhZ2VA&#39;}
retries = Retry(total=0, connect=None, read=None, redirect=None, status=None)
redirect = False, assert_same_host = False
timeout = Timeout(connect=None, read=None, total=None), pool_timeout = None
release_conn = False, chunked = False, body_pos = None
response_kw = {&#39;decode_content&#39;: False, &#39;preload_content&#39;: False, &#39;request_method&#39;: &#39;GET&#39;}
parsed_url = Url(scheme=None, auth=None, host=None, port=None, path=&#34;/api1/x3/erp/QAL/AOBJEXT(&#39;WYXOHADD&#39;)&#34;, query=&#39;representation=AOBJEXT.%24details&#39;, fragment=None)
destination_scheme = None
conn = &lt;urllib3.connection.HTTPSConnection object at 0x7f34bbd8baf0&gt;
release_this_conn = False, http_tunnel_required = True, err = None
clean_exit = True

    def urlopen(
        self,
        method,
        url,
        body=None,
        headers=None,
        retries=None,
        redirect=True,
        assert_same_host=True,
        timeout=_Default,
        pool_timeout=None,
        release_conn=None,
        chunked=False,
        body_pos=None,
        **response_kw
    ):
        &#34;&#34;&#34;
        Get a connection from the pool and perform an HTTP request. This is the
        lowest level call for making a request, so you&#39;ll need to specify all
        the raw details.
    
        .. note::
    
           More commonly, it&#39;s appropriate to use a convenience method provided
           by :class:`.RequestMethods`, such as :meth:`request`.
    
        .. note::
    
           `release_conn` will only behave as expected if
           `preload_content=False` because we want to make
           `preload_content=False` the default behaviour someday soon without
           breaking backwards compatibility.
    
        :param method:
            HTTP request method (such as GET, POST, PUT, etc.)
    
        :param url:
            The URL to perform the request on.
    
        :param body:
            Data to send in the request body, either :class:`str`, :class:`bytes`,
            an iterable of :class:`str`/:class:`bytes`, or a file-like object.
    
        :param headers:
            Dictionary of custom headers to send, such as User-Agent,
            If-None-Match, etc. If None, pool headers are used. If provided,
            these headers completely replace any pool-specific headers.
    
        :param retries:
            Configure the number of retries to allow before raising a
            :class:`~urllib3.exceptions.MaxRetryError` exception.
    
            Pass ``None`` to retry until you receive a response. Pass a
            :class:`~urllib3.util.retry.Retry` object for fine-grained control
            over different types of retries.
            Pass an integer number to retry connection errors that many times,
            but no other types of errors. Pass zero to never retry.
    
            If ``False``, then retries are disabled and any exception is raised
            immediately. Also, instead of raising a MaxRetryError on redirects,
            the redirect response will be returned.
    
        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.
    
        :param redirect:
            If True, automatically handle redirects (status codes 301, 302,
            303, 307, 308). Each redirect counts as a retry. Disabling retries
            will disable redirect, too.
    
        :param assert_same_host:
            If ``True``, will make sure that the host of the pool requests is
            consistent else will raise HostChangedError. When ``False``, you can
            use the pool on an HTTP proxy and request foreign hosts.
    
        :param timeout:
            If specified, overrides the default timeout for this one
            request. It may be a float (in seconds) or an instance of
            :class:`urllib3.util.Timeout`.
    
        :param pool_timeout:
            If set and the pool is set to block=True, then this method will
            block for ``pool_timeout`` seconds and raise EmptyPoolError if no
            connection is available within the time period.
    
        :param release_conn:
            If False, then the urlopen call will not release the connection
            back into the pool once a response is received (but will release if
            you read the entire contents of the response such as when
            `preload_content=True`). This is useful if you&#39;re not preloading
            the response&#39;s content immediately. You will need to call
            ``r.release_conn()`` on the response ``r`` to return the connection
            back into the pool. If None, it takes the value of
            ``response_kw.get(&#39;preload_content&#39;, True)``.
    
        :param chunked:
            If True, urllib3 will send the body using chunked transfer
            encoding. Otherwise, urllib3 will send the body using the standard
            content-length form. Defaults to False.
    
        :param int body_pos:
            Position to seek to in file-like body in the event of a retry or
            redirect. Typically this won&#39;t need to be set because urllib3 will
            auto-populate the value when needed.
    
        :param \\**response_kw:
            Additional parameters are passed to
            :meth:`urllib3.response.HTTPResponse.from_httplib`
        &#34;&#34;&#34;
    
        parsed_url = parse_url(url)
        destination_scheme = parsed_url.scheme
    
        if headers is None:
            headers = self.headers
    
        if not isinstance(retries, Retry):
            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)
    
        if release_conn is None:
            release_conn = response_kw.get(&#34;preload_content&#34;, True)
    
        # Check host
        if assert_same_host and not self.is_same_host(url):
            raise HostChangedError(self, url, retries)
    
        # Ensure that the URL we&#39;re connecting to is properly encoded
        if url.startswith(&#34;/&#34;):
            url = six.ensure_str(_encode_target(url))
        else:
            url = six.ensure_str(parsed_url.url)
    
        conn = None
    
        # Track whether `conn` needs to be released before
        # returning/raising/recursing. Update this variable if necessary, and
        # leave `release_conn` constant throughout the function. That way, if
        # the function recurses, the original value of `release_conn` will be
        # passed down into the recursive call, and its value will be respected.
        #
        # See issue #651 [1] for details.
        #
        # [1] &lt;https://github.com/urllib3/urllib3/issues/651&gt;
        release_this_conn = release_conn
    
        http_tunnel_required = connection_requires_http_tunnel(
            self.proxy, self.proxy_config, destination_scheme
        )
    
        # Merge the proxy headers. Only done when not using HTTP CONNECT. We
        # have to copy the headers dict so we can safely change it without those
        # changes being reflected in anyone else&#39;s copy.
        if not http_tunnel_required:
            headers = headers.copy()
            headers.update(self.proxy_headers)
    
        # Must keep the exception bound to a separate variable or else Python 3
        # complains about UnboundLocalError.
        err = None
    
        # Keep track of whether we cleanly exited the except block. This
        # ensures we do proper cleanup in finally.
        clean_exit = False
    
        # Rewind body position, if needed. Record current position
        # for future rewinds in the event of a redirect/retry.
        body_pos = set_file_position(body, body_pos)
    
        try:
            # Request a connection from the queue.
            timeout_obj = self._get_timeout(timeout)
            conn = self._get_conn(timeout=pool_timeout)
    
            conn.timeout = timeout_obj.connect_timeout
    
            is_new_proxy_conn = self.proxy is not None and not getattr(
                conn, &#34;sock&#34;, None
            )
            if is_new_proxy_conn and http_tunnel_required:
                self._prepare_proxy(conn)
    
            # Make the request on the httplib connection object.
            httplib_response = self._make_request(
                conn,
                method,
                url,
                timeout=timeout_obj,
                body=body,
                headers=headers,
                chunked=chunked,
            )
    
            # If we&#39;re going to release the connection in ``finally:``, then
            # the response doesn&#39;t need to know about the connection. Otherwise
            # it will also try to release it and we&#39;ll have a double-release
            # mess.
            response_conn = conn if not release_conn else None
    
            # Pass method to Response for length checking
            response_kw[&#34;request_method&#34;] = method
    
            # Import httplib&#39;s response into our own wrapper object
            response = self.ResponseCls.from_httplib(
                httplib_response,
                pool=self,
                connection=response_conn,
                retries=retries,
                **response_kw
            )
    
            # Everything went great!
            clean_exit = True
    
        except EmptyPoolError:
            # Didn&#39;t get a connection from the pool, no need to clean up
            clean_exit = True
            release_this_conn = False
            raise
    
        except (
            TimeoutError,
            HTTPException,
            SocketError,
            ProtocolError,
            BaseSSLError,
            SSLError,
            CertificateError,
        ) as e:
            # Discard the connection for these exceptions. It will be
            # replaced during the next _get_conn() call.
            clean_exit = False
    
            def _is_ssl_error_message_from_http_proxy(ssl_error):
                # We&#39;re trying to detect the message &#39;WRONG_VERSION_NUMBER&#39; but
                # SSLErrors are kinda all over the place when it comes to the message,
                # so we try to cover our bases here!
                message = &#34; &#34;.join(re.split(&#34;[^a-z]&#34;, str(ssl_error).lower()))
                return (
                    &#34;wrong version number&#34; in message or &#34;unknown protocol&#34; in message
                )
    
            # Try to detect a common user error with proxies which is to
            # set an HTTP proxy to be HTTPS when it should be &#39;http://&#39;
            # (ie {&#39;http&#39;: &#39;http://proxy&#39;, &#39;https&#39;: &#39;https://proxy&#39;})
            # Instead we add a nice error message and point to a URL.
            if (
                isinstance(e, BaseSSLError)
                and self.proxy
                and _is_ssl_error_message_from_http_proxy(e)
                and conn.proxy
                and conn.proxy.scheme == &#34;https&#34;
            ):
                e = ProxyError(
                    &#34;Your proxy appears to only use HTTP and not HTTPS, &#34;
                    &#34;try changing your proxy URL to be HTTP. See: &#34;
                    &#34;https://urllib3.readthedocs.io/en/1.26.x/advanced-usage.html&#34;
                    &#34;#https-proxy-error-http-proxy&#34;,
                    SSLError(e),
                )
            elif isinstance(e, (BaseSSLError, CertificateError)):
                e = SSLError(e)
            elif isinstance(e, (SocketError, NewConnectionError)) and self.proxy:
                e = ProxyError(&#34;Cannot connect to proxy.&#34;, e)
            elif isinstance(e, (SocketError, HTTPException)):
                e = ProtocolError(&#34;Connection aborted.&#34;, e)
    
            retries = retries.increment(
                method, url, error=e, _pool=self, _stacktrace=sys.exc_info()[2]
            )
            retries.sleep()
    
            # Keep track of the error for the retry warning.
            err = e
    
        finally:
            if not clean_exit:
                # We hit some kind of exception, handled or otherwise. We need
                # to throw the connection away unless explicitly told not to.
                # Close the connection, set the variable to None, and make sure
                # we put the None back in the pool to avoid leaking it.
                conn = conn and conn.close()
                release_this_conn = True
    
            if release_this_conn:
                # Put the connection back to be reused. If the connection is
                # expired then it will be None, which will get replaced with a
                # fresh connection during _get_conn.
                self._put_conn(conn)
    
        if not conn:
            # Try again
            log.warning(
                &#34;Retrying (%r) after connection broken by &#39;%r&#39;: %s&#34;, retries, err, url
            )
            return self.urlopen(
                method,
                url,
                body,
                headers,
                retries,
                redirect,
                assert_same_host,
                timeout=timeout,
                pool_timeout=pool_timeout,
                release_conn=release_conn,
                chunked=chunked,
                body_pos=body_pos,
                **response_kw
            )
    
        # Handle redirect?
        redirect_location = redirect and response.get_redirect_location()
        if redirect_location:
            if response.status == 303:
                method = &#34;GET&#34;
    
            try:
                retries = retries.increment(method, url, response=response, _pool=self)
            except MaxRetryError:
                if retries.raise_on_redirect:
                    response.drain_conn()
                    raise
                return response
    
            response.drain_conn()
            retries.sleep_for_retry(response)
            log.debug(&#34;Redirecting %s -&gt; %s&#34;, url, redirect_location)
            return self.urlopen(
                method,
                redirect_location,
                body,
                headers,
                retries=retries,
                redirect=redirect,
                assert_same_host=assert_same_host,
                timeout=timeout,
                pool_timeout=pool_timeout,
                release_conn=release_conn,
                chunked=chunked,
                body_pos=body_pos,
                **response_kw
            )
    
        # Check if we should retry the HTTP response.
        has_retry_after = bool(response.getheader(&#34;Retry-After&#34;))
        if retries.is_retry(method, response.status, has_retry_after):
            try:
                retries = retries.increment(method, url, response=response, _pool=self)
            except MaxRetryError:
                if retries.raise_on_status:
                    response.drain_conn()
                    raise
                return response
    
            response.drain_conn()
            retries.sleep(response)
            log.debug(&#34;Retry: %s&#34;, url)
&gt;           return self.urlopen(
                method,
                url,
                body,
                headers,
                retries=retries,
                redirect=redirect,
                assert_same_host=assert_same_host,
                timeout=timeout,
                pool_timeout=pool_timeout,
                release_conn=release_conn,
                chunked=chunked,
                body_pos=body_pos,
                **response_kw
            )

/usr/local/lib/python3.8/site-packages/urllib3/connectionpool.py:878: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connectionpool.HTTPSConnectionPool object at 0x7f34c007bfa0&gt;
method = &#39;GET&#39;
url = &#34;/api1/x3/erp/QAL/AOBJEXT(&#39;WYXOHADD&#39;)?representation=AOBJEXT.%24details&#34;
body = None
headers = {&#39;User-Agent&#39;: &#39;python-requests/2.28.1&#39;, &#39;Accept-Encoding&#39;: &#39;gzip, deflate&#39;, &#39;Accept&#39;: &#39;*/*&#39;, &#39;Connection&#39;: &#39;keep-alive&#39;, &#39;Content-Type&#39;: &#39;application/json&#39;, &#39;Authorization&#39;: &#39;Basic aW50cmFjbzpXYXNzaW1Db3ZhZ2VA&#39;}
retries = Retry(total=0, connect=None, read=None, redirect=None, status=None)
redirect = False, assert_same_host = False
timeout = Timeout(connect=None, read=None, total=None), pool_timeout = None
release_conn = False, chunked = False, body_pos = None
response_kw = {&#39;decode_content&#39;: False, &#39;preload_content&#39;: False, &#39;request_method&#39;: &#39;GET&#39;}
parsed_url = Url(scheme=None, auth=None, host=None, port=None, path=&#34;/api1/x3/erp/QAL/AOBJEXT(&#39;WYXOHADD&#39;)&#34;, query=&#39;representation=AOBJEXT.%24details&#39;, fragment=None)
destination_scheme = None
conn = &lt;urllib3.connection.HTTPSConnection object at 0x7f34bbd8baf0&gt;
release_this_conn = False, http_tunnel_required = True, err = None
clean_exit = True

    def urlopen(
        self,
        method,
        url,
        body=None,
        headers=None,
        retries=None,
        redirect=True,
        assert_same_host=True,
        timeout=_Default,
        pool_timeout=None,
        release_conn=None,
        chunked=False,
        body_pos=None,
        **response_kw
    ):
        &#34;&#34;&#34;
        Get a connection from the pool and perform an HTTP request. This is the
        lowest level call for making a request, so you&#39;ll need to specify all
        the raw details.
    
        .. note::
    
           More commonly, it&#39;s appropriate to use a convenience method provided
           by :class:`.RequestMethods`, such as :meth:`request`.
    
        .. note::
    
           `release_conn` will only behave as expected if
           `preload_content=False` because we want to make
           `preload_content=False` the default behaviour someday soon without
           breaking backwards compatibility.
    
        :param method:
            HTTP request method (such as GET, POST, PUT, etc.)
    
        :param url:
            The URL to perform the request on.
    
        :param body:
            Data to send in the request body, either :class:`str`, :class:`bytes`,
            an iterable of :class:`str`/:class:`bytes`, or a file-like object.
    
        :param headers:
            Dictionary of custom headers to send, such as User-Agent,
            If-None-Match, etc. If None, pool headers are used. If provided,
            these headers completely replace any pool-specific headers.
    
        :param retries:
            Configure the number of retries to allow before raising a
            :class:`~urllib3.exceptions.MaxRetryError` exception.
    
            Pass ``None`` to retry until you receive a response. Pass a
            :class:`~urllib3.util.retry.Retry` object for fine-grained control
            over different types of retries.
            Pass an integer number to retry connection errors that many times,
            but no other types of errors. Pass zero to never retry.
    
            If ``False``, then retries are disabled and any exception is raised
            immediately. Also, instead of raising a MaxRetryError on redirects,
            the redirect response will be returned.
    
        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.
    
        :param redirect:
            If True, automatically handle redirects (status codes 301, 302,
            303, 307, 308). Each redirect counts as a retry. Disabling retries
            will disable redirect, too.
    
        :param assert_same_host:
            If ``True``, will make sure that the host of the pool requests is
            consistent else will raise HostChangedError. When ``False``, you can
            use the pool on an HTTP proxy and request foreign hosts.
    
        :param timeout:
            If specified, overrides the default timeout for this one
            request. It may be a float (in seconds) or an instance of
            :class:`urllib3.util.Timeout`.
    
        :param pool_timeout:
            If set and the pool is set to block=True, then this method will
            block for ``pool_timeout`` seconds and raise EmptyPoolError if no
            connection is available within the time period.
    
        :param release_conn:
            If False, then the urlopen call will not release the connection
            back into the pool once a response is received (but will release if
            you read the entire contents of the response such as when
            `preload_content=True`). This is useful if you&#39;re not preloading
            the response&#39;s content immediately. You will need to call
            ``r.release_conn()`` on the response ``r`` to return the connection
            back into the pool. If None, it takes the value of
            ``response_kw.get(&#39;preload_content&#39;, True)``.
    
        :param chunked:
            If True, urllib3 will send the body using chunked transfer
            encoding. Otherwise, urllib3 will send the body using the standard
            content-length form. Defaults to False.
    
        :param int body_pos:
            Position to seek to in file-like body in the event of a retry or
            redirect. Typically this won&#39;t need to be set because urllib3 will
            auto-populate the value when needed.
    
        :param \\**response_kw:
            Additional parameters are passed to
            :meth:`urllib3.response.HTTPResponse.from_httplib`
        &#34;&#34;&#34;
    
        parsed_url = parse_url(url)
        destination_scheme = parsed_url.scheme
    
        if headers is None:
            headers = self.headers
    
        if not isinstance(retries, Retry):
            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)
    
        if release_conn is None:
            release_conn = response_kw.get(&#34;preload_content&#34;, True)
    
        # Check host
        if assert_same_host and not self.is_same_host(url):
            raise HostChangedError(self, url, retries)
    
        # Ensure that the URL we&#39;re connecting to is properly encoded
        if url.startswith(&#34;/&#34;):
            url = six.ensure_str(_encode_target(url))
        else:
            url = six.ensure_str(parsed_url.url)
    
        conn = None
    
        # Track whether `conn` needs to be released before
        # returning/raising/recursing. Update this variable if necessary, and
        # leave `release_conn` constant throughout the function. That way, if
        # the function recurses, the original value of `release_conn` will be
        # passed down into the recursive call, and its value will be respected.
        #
        # See issue #651 [1] for details.
        #
        # [1] &lt;https://github.com/urllib3/urllib3/issues/651&gt;
        release_this_conn = release_conn
    
        http_tunnel_required = connection_requires_http_tunnel(
            self.proxy, self.proxy_config, destination_scheme
        )
    
        # Merge the proxy headers. Only done when not using HTTP CONNECT. We
        # have to copy the headers dict so we can safely change it without those
        # changes being reflected in anyone else&#39;s copy.
        if not http_tunnel_required:
            headers = headers.copy()
            headers.update(self.proxy_headers)
    
        # Must keep the exception bound to a separate variable or else Python 3
        # complains about UnboundLocalError.
        err = None
    
        # Keep track of whether we cleanly exited the except block. This
        # ensures we do proper cleanup in finally.
        clean_exit = False
    
        # Rewind body position, if needed. Record current position
        # for future rewinds in the event of a redirect/retry.
        body_pos = set_file_position(body, body_pos)
    
        try:
            # Request a connection from the queue.
            timeout_obj = self._get_timeout(timeout)
            conn = self._get_conn(timeout=pool_timeout)
    
            conn.timeout = timeout_obj.connect_timeout
    
            is_new_proxy_conn = self.proxy is not None and not getattr(
                conn, &#34;sock&#34;, None
            )
            if is_new_proxy_conn and http_tunnel_required:
                self._prepare_proxy(conn)
    
            # Make the request on the httplib connection object.
            httplib_response = self._make_request(
                conn,
                method,
                url,
                timeout=timeout_obj,
                body=body,
                headers=headers,
                chunked=chunked,
            )
    
            # If we&#39;re going to release the connection in ``finally:``, then
            # the response doesn&#39;t need to know about the connection. Otherwise
            # it will also try to release it and we&#39;ll have a double-release
            # mess.
            response_conn = conn if not release_conn else None
    
            # Pass method to Response for length checking
            response_kw[&#34;request_method&#34;] = method
    
            # Import httplib&#39;s response into our own wrapper object
            response = self.ResponseCls.from_httplib(
                httplib_response,
                pool=self,
                connection=response_conn,
                retries=retries,
                **response_kw
            )
    
            # Everything went great!
            clean_exit = True
    
        except EmptyPoolError:
            # Didn&#39;t get a connection from the pool, no need to clean up
            clean_exit = True
            release_this_conn = False
            raise
    
        except (
            TimeoutError,
            HTTPException,
            SocketError,
            ProtocolError,
            BaseSSLError,
            SSLError,
            CertificateError,
        ) as e:
            # Discard the connection for these exceptions. It will be
            # replaced during the next _get_conn() call.
            clean_exit = False
    
            def _is_ssl_error_message_from_http_proxy(ssl_error):
                # We&#39;re trying to detect the message &#39;WRONG_VERSION_NUMBER&#39; but
                # SSLErrors are kinda all over the place when it comes to the message,
                # so we try to cover our bases here!
                message = &#34; &#34;.join(re.split(&#34;[^a-z]&#34;, str(ssl_error).lower()))
                return (
                    &#34;wrong version number&#34; in message or &#34;unknown protocol&#34; in message
                )
    
            # Try to detect a common user error with proxies which is to
            # set an HTTP proxy to be HTTPS when it should be &#39;http://&#39;
            # (ie {&#39;http&#39;: &#39;http://proxy&#39;, &#39;https&#39;: &#39;https://proxy&#39;})
            # Instead we add a nice error message and point to a URL.
            if (
                isinstance(e, BaseSSLError)
                and self.proxy
                and _is_ssl_error_message_from_http_proxy(e)
                and conn.proxy
                and conn.proxy.scheme == &#34;https&#34;
            ):
                e = ProxyError(
                    &#34;Your proxy appears to only use HTTP and not HTTPS, &#34;
                    &#34;try changing your proxy URL to be HTTP. See: &#34;
                    &#34;https://urllib3.readthedocs.io/en/1.26.x/advanced-usage.html&#34;
                    &#34;#https-proxy-error-http-proxy&#34;,
                    SSLError(e),
                )
            elif isinstance(e, (BaseSSLError, CertificateError)):
                e = SSLError(e)
            elif isinstance(e, (SocketError, NewConnectionError)) and self.proxy:
                e = ProxyError(&#34;Cannot connect to proxy.&#34;, e)
            elif isinstance(e, (SocketError, HTTPException)):
                e = ProtocolError(&#34;Connection aborted.&#34;, e)
    
            retries = retries.increment(
                method, url, error=e, _pool=self, _stacktrace=sys.exc_info()[2]
            )
            retries.sleep()
    
            # Keep track of the error for the retry warning.
            err = e
    
        finally:
            if not clean_exit:
                # We hit some kind of exception, handled or otherwise. We need
                # to throw the connection away unless explicitly told not to.
                # Close the connection, set the variable to None, and make sure
                # we put the None back in the pool to avoid leaking it.
                conn = conn and conn.close()
                release_this_conn = True
    
            if release_this_conn:
                # Put the connection back to be reused. If the connection is
                # expired then it will be None, which will get replaced with a
                # fresh connection during _get_conn.
                self._put_conn(conn)
    
        if not conn:
            # Try again
            log.warning(
                &#34;Retrying (%r) after connection broken by &#39;%r&#39;: %s&#34;, retries, err, url
            )
            return self.urlopen(
                method,
                url,
                body,
                headers,
                retries,
                redirect,
                assert_same_host,
                timeout=timeout,
                pool_timeout=pool_timeout,
                release_conn=release_conn,
                chunked=chunked,
                body_pos=body_pos,
                **response_kw
            )
    
        # Handle redirect?
        redirect_location = redirect and response.get_redirect_location()
        if redirect_location:
            if response.status == 303:
                method = &#34;GET&#34;
    
            try:
                retries = retries.increment(method, url, response=response, _pool=self)
            except MaxRetryError:
                if retries.raise_on_redirect:
                    response.drain_conn()
                    raise
                return response
    
            response.drain_conn()
            retries.sleep_for_retry(response)
            log.debug(&#34;Redirecting %s -&gt; %s&#34;, url, redirect_location)
            return self.urlopen(
                method,
                redirect_location,
                body,
                headers,
                retries=retries,
                redirect=redirect,
                assert_same_host=assert_same_host,
                timeout=timeout,
                pool_timeout=pool_timeout,
                release_conn=release_conn,
                chunked=chunked,
                body_pos=body_pos,
                **response_kw
            )
    
        # Check if we should retry the HTTP response.
        has_retry_after = bool(response.getheader(&#34;Retry-After&#34;))
        if retries.is_retry(method, response.status, has_retry_after):
            try:
&gt;               retries = retries.increment(method, url, response=response, _pool=self)

/usr/local/lib/python3.8/site-packages/urllib3/connectionpool.py:868: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Retry(total=0, connect=None, read=None, redirect=None, status=None)
method = &#39;GET&#39;
url = &#34;/api1/x3/erp/QAL/AOBJEXT(&#39;WYXOHADD&#39;)?representation=AOBJEXT.%24details&#34;
response = &lt;urllib3.response.HTTPResponse object at 0x7f34bbd8b8e0&gt;
error = None
_pool = &lt;urllib3.connectionpool.HTTPSConnectionPool object at 0x7f34c007bfa0&gt;
_stacktrace = None

    def increment(
        self,
        method=None,
        url=None,
        response=None,
        error=None,
        _pool=None,
        _stacktrace=None,
    ):
        &#34;&#34;&#34;Return a new Retry object with incremented retry counters.
    
        :param response: A response object, or None, if the server did not
            return a response.
        :type response: :class:`~urllib3.response.HTTPResponse`
        :param Exception error: An error encountered during the request, or
            None if the response was received successfully.
    
        :return: A new ``Retry`` object.
        &#34;&#34;&#34;
        if self.total is False and error:
            # Disabled, indicate to re-raise the error.
            raise six.reraise(type(error), error, _stacktrace)
    
        total = self.total
        if total is not None:
            total -= 1
    
        connect = self.connect
        read = self.read
        redirect = self.redirect
        status_count = self.status
        other = self.other
        cause = &#34;unknown&#34;
        status = None
        redirect_location = None
    
        if error and self._is_connection_error(error):
            # Connect retry?
            if connect is False:
                raise six.reraise(type(error), error, _stacktrace)
            elif connect is not None:
                connect -= 1
    
        elif error and self._is_read_error(error):
            # Read retry?
            if read is False or not self._is_method_retryable(method):
                raise six.reraise(type(error), error, _stacktrace)
            elif read is not None:
                read -= 1
    
        elif error:
            # Other retry?
            if other is not None:
                other -= 1
    
        elif response and response.get_redirect_location():
            # Redirect retry?
            if redirect is not None:
                redirect -= 1
            cause = &#34;too many redirects&#34;
            redirect_location = response.get_redirect_location()
            status = response.status
    
        else:
            # Incrementing because of a server error like a 500 in
            # status_forcelist and the given method is in the allowed_methods
            cause = ResponseError.GENERIC_ERROR
            if response and response.status:
                if status_count is not None:
                    status_count -= 1
                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)
                status = response.status
    
        history = self.history + (
            RequestHistory(method, url, error, status, redirect_location),
        )
    
        new_retry = self.new(
            total=total,
            connect=connect,
            read=read,
            redirect=redirect,
            status=status_count,
            other=other,
            history=history,
        )
    
        if new_retry.is_exhausted():
&gt;           raise MaxRetryError(_pool, url, error or ResponseError(cause))
E           urllib3.exceptions.MaxRetryError: HTTPSConnectionPool(host=&#39;sagex3-horsprod.covage.com&#39;, port=443): Max retries exceeded with url: /api1/x3/erp/QAL/AOBJEXT(&#39;WYXOHADD&#39;)?representation=AOBJEXT.%24details (Caused by ResponseError(&#39;too many 502 error responses&#39;))

/usr/local/lib/python3.8/site-packages/urllib3/util/retry.py:592: MaxRetryError

During handling of the above exception, another exception occurred:

folder = &#39;QAL&#39;

    @pytest.mark.livetest
    @pytest.mark.xfail
    @pytest.mark.parametrize(&#34;folder&#34;, [os.environ[&#34;LIVE_TEST_X3_FOLDER&#34;]])
    def test_validate_schema_WYXOHADD(folder):
        &#34;&#34;&#34;
        Compare diff for `WYXOHUPGRA` model between local snapshot and os.environ[&#34;LIVE_TEST_X3_FOLDER&#34;]\n
        WYXOHUPGRA: Ajouter options contract
        &#34;&#34;&#34;
&gt;       destination = get_model_schema_from_x3(&#34;WYXOHADD&#34;, folder=folder)

app/api/live_tests/test_validate_import_schema.py:119: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
app/api/live_tests/test_validate_import_schema.py:31: in get_model_schema_from_x3
    resp = client.get(class_name=&#34;AOBJEXT&#34;, representation=&#34;AOBJEXT&#34;, ref=model_name)
app/x3_wrapper/rest_client.py:109: in get
    resp = self._cal_x3(&#34;GET&#34;, url, query_params)
app/x3_wrapper/rest_client.py:70: in _cal_x3
    resp = self.client.request(method, url, params=query_params)
/usr/local/lib/python3.8/site-packages/requests/sessions.py:587: in request
    resp = self.send(prep, **send_kwargs)
/usr/local/lib/python3.8/site-packages/requests/sessions.py:701: in send
    r = adapter.send(request, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;requests.adapters.HTTPAdapter object at 0x7f34c007b640&gt;
request = &lt;PreparedRequest [GET]&gt;, stream = False
timeout = Timeout(connect=None, read=None, total=None), verify = True
cert = None
proxies = OrderedDict([(&#39;no&#39;, &#39;gitlab-runner-cache-01-prd.nut.covage.com&#39;), (&#39;http&#39;, &#39;http://squid.kosc.net:3128&#39;), (&#39;https&#39;, &#39;http://squid.kosc.net:3128&#39;)])

    def send(
        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None
    ):
        &#34;&#34;&#34;Sends PreparedRequest object. Returns Response object.
    
        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.
        :param stream: (optional) Whether to stream the request content.
        :param timeout: (optional) How long to wait for the server to send
            data before giving up, as a float, or a :ref:`(connect timeout,
            read timeout) &lt;timeouts&gt;` tuple.
        :type timeout: float or tuple or urllib3 Timeout object
        :param verify: (optional) Either a boolean, in which case it controls whether
            we verify the server&#39;s TLS certificate, or a string, in which case it
            must be a path to a CA bundle to use
        :param cert: (optional) Any user-provided SSL certificate to be trusted.
        :param proxies: (optional) The proxies dictionary to apply to the request.
        :rtype: requests.Response
        &#34;&#34;&#34;
    
        try:
            conn = self.get_connection(request.url, proxies)
        except LocationValueError as e:
            raise InvalidURL(e, request=request)
    
        self.cert_verify(conn, request.url, verify, cert)
        url = self.request_url(request, proxies)
        self.add_headers(
            request,
            stream=stream,
            timeout=timeout,
            verify=verify,
            cert=cert,
            proxies=proxies,
        )
    
        chunked = not (request.body is None or &#34;Content-Length&#34; in request.headers)
    
        if isinstance(timeout, tuple):
            try:
                connect, read = timeout
                timeout = TimeoutSauce(connect=connect, read=read)
            except ValueError:
                raise ValueError(
                    f&#34;Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, &#34;
                    f&#34;or a single float to set both timeouts to the same value.&#34;
                )
        elif isinstance(timeout, TimeoutSauce):
            pass
        else:
            timeout = TimeoutSauce(connect=timeout, read=timeout)
    
        try:
            if not chunked:
                resp = conn.urlopen(
                    method=request.method,
                    url=url,
                    body=request.body,
                    headers=request.headers,
                    redirect=False,
                    assert_same_host=False,
                    preload_content=False,
                    decode_content=False,
                    retries=self.max_retries,
                    timeout=timeout,
                )
    
            # Send the request.
            else:
                if hasattr(conn, &#34;proxy_pool&#34;):
                    conn = conn.proxy_pool
    
                low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)
    
                try:
                    skip_host = &#34;Host&#34; in request.headers
                    low_conn.putrequest(
                        request.method,
                        url,
                        skip_accept_encoding=True,
                        skip_host=skip_host,
                    )
    
                    for header, value in request.headers.items():
                        low_conn.putheader(header, value)
    
                    low_conn.endheaders()
    
                    for i in request.body:
                        low_conn.send(hex(len(i))[2:].encode(&#34;utf-8&#34;))
                        low_conn.send(b&#34;\r\n&#34;)
                        low_conn.send(i)
                        low_conn.send(b&#34;\r\n&#34;)
                    low_conn.send(b&#34;0\r\n\r\n&#34;)
    
                    # Receive the response from the server
                    r = low_conn.getresponse()
    
                    resp = HTTPResponse.from_httplib(
                        r,
                        pool=conn,
                        connection=low_conn,
                        preload_content=False,
                        decode_content=False,
                    )
                except Exception:
                    # If we hit any problems here, clean up the connection.
                    # Then, raise so that we can handle the actual exception.
                    low_conn.close()
                    raise
    
        except (ProtocolError, OSError) as err:
            raise ConnectionError(err, request=request)
    
        except MaxRetryError as e:
            if isinstance(e.reason, ConnectTimeoutError):
                # TODO: Remove this in 3.0.0: see #2811
                if not isinstance(e.reason, NewConnectionError):
                    raise ConnectTimeout(e, request=request)
    
            if isinstance(e.reason, ResponseError):
&gt;               raise RetryError(e, request=request)
E               requests.exceptions.RetryError: HTTPSConnectionPool(host=&#39;sagex3-horsprod.covage.com&#39;, port=443): Max retries exceeded with url: /api1/x3/erp/QAL/AOBJEXT(&#39;WYXOHADD&#39;)?representation=AOBJEXT.%24details (Caused by ResponseError(&#39;too many 502 error responses&#39;))

/usr/local/lib/python3.8/site-packages/requests/adapters.py:556: RetryError</pre> </div> </div> </details> <details class="phase teardown "> <summary> <h4 class=title> <span class=phase-name>Teardown</span> </h4> </summary> <div class=content> </div> </details> </div> </div> </details> <details class="test xfailed"> <summary> <h3 class="title test-title"> <span class="status badge xfailed ">XFAIL</span> <span class=test-name> <span class=funcname>test_validate_schema_WYXOHTERM</span><span class=params>[QAL]</span> </span> <span class=duration>0:00:00.655294</span> </h3> </summary> <div class=content> <div class=documentation> <p>Compare diff for <cite>WYXOHUPGRA</cite> model between local snapshot and os.environ[&quot;LIVE_TEST_X3_FOLDER&quot;]</p> <p>WYXOHTERM: Resilier options contract</p> </div> <table class=metadata> <tr> <th>Started</th> <td>2023-06-30 01:14:39</td> </tr> <tr> <th>Ended</th> <td>2023-06-30 01:14:39</td> </tr> <tr> <th>Duration</th> <td>0:00:00.655294</td> </tr> <tr> <th>Markers</th> <td> <div class=marker> <span class="marker-name badge">xfail</span> <span class=marker-args> </span> </div> <div class=marker> <span class="marker-name badge">livetest</span> <span class=marker-args> </span> </div> </td> </tr> <tr> <th>Fixtures</th> <td> <span class="badge fixturename"> django_test_environment </span> <span class="badge fixturename"> django_db_blocker </span> <span class="badge fixturename"> folder </span> <span class="badge fixturename"> request </span> </td> </tr> </table> <div class=repr> <pre>requests.exceptions.RetryError: HTTPSConnectionPool(host=&#39;sagex3-horsprod.covage.com&#39;, port=443): Max retries exceeded with url: /api1/x3/erp/QAL/AOBJEXT(&#39;WYXOHTERM&#39;)?representation=AOBJEXT.%24details (Caused by ResponseError(&#39;too many 502 error responses&#39;))</pre> </div> <div class=test-phases> <details class="phase setup "> <summary> <h4 class=title> <span class=phase-name>Setup</span> </h4> </summary> <div class=content> </div> </details> <details class="phase call xfailed" open> <summary> <h4 class=title> <span class="status  xfailed"></span> <span class=phase-name>Call</span> </h4> </summary> <div class=content> <div class=repr> <pre>self = &lt;requests.adapters.HTTPAdapter object at 0x7f34c0383b50&gt;
request = &lt;PreparedRequest [GET]&gt;, stream = False
timeout = Timeout(connect=None, read=None, total=None), verify = True
cert = None
proxies = OrderedDict([(&#39;no&#39;, &#39;gitlab-runner-cache-01-prd.nut.covage.com&#39;), (&#39;http&#39;, &#39;http://squid.kosc.net:3128&#39;), (&#39;https&#39;, &#39;http://squid.kosc.net:3128&#39;)])

    def send(
        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None
    ):
        &#34;&#34;&#34;Sends PreparedRequest object. Returns Response object.
    
        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.
        :param stream: (optional) Whether to stream the request content.
        :param timeout: (optional) How long to wait for the server to send
            data before giving up, as a float, or a :ref:`(connect timeout,
            read timeout) &lt;timeouts&gt;` tuple.
        :type timeout: float or tuple or urllib3 Timeout object
        :param verify: (optional) Either a boolean, in which case it controls whether
            we verify the server&#39;s TLS certificate, or a string, in which case it
            must be a path to a CA bundle to use
        :param cert: (optional) Any user-provided SSL certificate to be trusted.
        :param proxies: (optional) The proxies dictionary to apply to the request.
        :rtype: requests.Response
        &#34;&#34;&#34;
    
        try:
            conn = self.get_connection(request.url, proxies)
        except LocationValueError as e:
            raise InvalidURL(e, request=request)
    
        self.cert_verify(conn, request.url, verify, cert)
        url = self.request_url(request, proxies)
        self.add_headers(
            request,
            stream=stream,
            timeout=timeout,
            verify=verify,
            cert=cert,
            proxies=proxies,
        )
    
        chunked = not (request.body is None or &#34;Content-Length&#34; in request.headers)
    
        if isinstance(timeout, tuple):
            try:
                connect, read = timeout
                timeout = TimeoutSauce(connect=connect, read=read)
            except ValueError:
                raise ValueError(
                    f&#34;Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, &#34;
                    f&#34;or a single float to set both timeouts to the same value.&#34;
                )
        elif isinstance(timeout, TimeoutSauce):
            pass
        else:
            timeout = TimeoutSauce(connect=timeout, read=timeout)
    
        try:
            if not chunked:
&gt;               resp = conn.urlopen(
                    method=request.method,
                    url=url,
                    body=request.body,
                    headers=request.headers,
                    redirect=False,
                    assert_same_host=False,
                    preload_content=False,
                    decode_content=False,
                    retries=self.max_retries,
                    timeout=timeout,
                )

/usr/local/lib/python3.8/site-packages/requests/adapters.py:489: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connectionpool.HTTPSConnectionPool object at 0x7f34c0383430&gt;
method = &#39;GET&#39;
url = &#34;/api1/x3/erp/QAL/AOBJEXT(&#39;WYXOHTERM&#39;)?representation=AOBJEXT.%24details&#34;
body = None
headers = {&#39;User-Agent&#39;: &#39;python-requests/2.28.1&#39;, &#39;Accept-Encoding&#39;: &#39;gzip, deflate&#39;, &#39;Accept&#39;: &#39;*/*&#39;, &#39;Connection&#39;: &#39;keep-alive&#39;, &#39;Content-Type&#39;: &#39;application/json&#39;, &#39;Authorization&#39;: &#39;Basic aW50cmFjbzpXYXNzaW1Db3ZhZ2VA&#39;}
retries = Retry(total=2, connect=None, read=None, redirect=None, status=None)
redirect = False, assert_same_host = False
timeout = Timeout(connect=None, read=None, total=None), pool_timeout = None
release_conn = False, chunked = False, body_pos = None
response_kw = {&#39;decode_content&#39;: False, &#39;preload_content&#39;: False, &#39;request_method&#39;: &#39;GET&#39;}
parsed_url = Url(scheme=None, auth=None, host=None, port=None, path=&#34;/api1/x3/erp/QAL/AOBJEXT(&#39;WYXOHTERM&#39;)&#34;, query=&#39;representation=AOBJEXT.%24details&#39;, fragment=None)
destination_scheme = None
conn = &lt;urllib3.connection.HTTPSConnection object at 0x7f34bbb16910&gt;
release_this_conn = False, http_tunnel_required = True, err = None
clean_exit = True

    def urlopen(
        self,
        method,
        url,
        body=None,
        headers=None,
        retries=None,
        redirect=True,
        assert_same_host=True,
        timeout=_Default,
        pool_timeout=None,
        release_conn=None,
        chunked=False,
        body_pos=None,
        **response_kw
    ):
        &#34;&#34;&#34;
        Get a connection from the pool and perform an HTTP request. This is the
        lowest level call for making a request, so you&#39;ll need to specify all
        the raw details.
    
        .. note::
    
           More commonly, it&#39;s appropriate to use a convenience method provided
           by :class:`.RequestMethods`, such as :meth:`request`.
    
        .. note::
    
           `release_conn` will only behave as expected if
           `preload_content=False` because we want to make
           `preload_content=False` the default behaviour someday soon without
           breaking backwards compatibility.
    
        :param method:
            HTTP request method (such as GET, POST, PUT, etc.)
    
        :param url:
            The URL to perform the request on.
    
        :param body:
            Data to send in the request body, either :class:`str`, :class:`bytes`,
            an iterable of :class:`str`/:class:`bytes`, or a file-like object.
    
        :param headers:
            Dictionary of custom headers to send, such as User-Agent,
            If-None-Match, etc. If None, pool headers are used. If provided,
            these headers completely replace any pool-specific headers.
    
        :param retries:
            Configure the number of retries to allow before raising a
            :class:`~urllib3.exceptions.MaxRetryError` exception.
    
            Pass ``None`` to retry until you receive a response. Pass a
            :class:`~urllib3.util.retry.Retry` object for fine-grained control
            over different types of retries.
            Pass an integer number to retry connection errors that many times,
            but no other types of errors. Pass zero to never retry.
    
            If ``False``, then retries are disabled and any exception is raised
            immediately. Also, instead of raising a MaxRetryError on redirects,
            the redirect response will be returned.
    
        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.
    
        :param redirect:
            If True, automatically handle redirects (status codes 301, 302,
            303, 307, 308). Each redirect counts as a retry. Disabling retries
            will disable redirect, too.
    
        :param assert_same_host:
            If ``True``, will make sure that the host of the pool requests is
            consistent else will raise HostChangedError. When ``False``, you can
            use the pool on an HTTP proxy and request foreign hosts.
    
        :param timeout:
            If specified, overrides the default timeout for this one
            request. It may be a float (in seconds) or an instance of
            :class:`urllib3.util.Timeout`.
    
        :param pool_timeout:
            If set and the pool is set to block=True, then this method will
            block for ``pool_timeout`` seconds and raise EmptyPoolError if no
            connection is available within the time period.
    
        :param release_conn:
            If False, then the urlopen call will not release the connection
            back into the pool once a response is received (but will release if
            you read the entire contents of the response such as when
            `preload_content=True`). This is useful if you&#39;re not preloading
            the response&#39;s content immediately. You will need to call
            ``r.release_conn()`` on the response ``r`` to return the connection
            back into the pool. If None, it takes the value of
            ``response_kw.get(&#39;preload_content&#39;, True)``.
    
        :param chunked:
            If True, urllib3 will send the body using chunked transfer
            encoding. Otherwise, urllib3 will send the body using the standard
            content-length form. Defaults to False.
    
        :param int body_pos:
            Position to seek to in file-like body in the event of a retry or
            redirect. Typically this won&#39;t need to be set because urllib3 will
            auto-populate the value when needed.
    
        :param \\**response_kw:
            Additional parameters are passed to
            :meth:`urllib3.response.HTTPResponse.from_httplib`
        &#34;&#34;&#34;
    
        parsed_url = parse_url(url)
        destination_scheme = parsed_url.scheme
    
        if headers is None:
            headers = self.headers
    
        if not isinstance(retries, Retry):
            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)
    
        if release_conn is None:
            release_conn = response_kw.get(&#34;preload_content&#34;, True)
    
        # Check host
        if assert_same_host and not self.is_same_host(url):
            raise HostChangedError(self, url, retries)
    
        # Ensure that the URL we&#39;re connecting to is properly encoded
        if url.startswith(&#34;/&#34;):
            url = six.ensure_str(_encode_target(url))
        else:
            url = six.ensure_str(parsed_url.url)
    
        conn = None
    
        # Track whether `conn` needs to be released before
        # returning/raising/recursing. Update this variable if necessary, and
        # leave `release_conn` constant throughout the function. That way, if
        # the function recurses, the original value of `release_conn` will be
        # passed down into the recursive call, and its value will be respected.
        #
        # See issue #651 [1] for details.
        #
        # [1] &lt;https://github.com/urllib3/urllib3/issues/651&gt;
        release_this_conn = release_conn
    
        http_tunnel_required = connection_requires_http_tunnel(
            self.proxy, self.proxy_config, destination_scheme
        )
    
        # Merge the proxy headers. Only done when not using HTTP CONNECT. We
        # have to copy the headers dict so we can safely change it without those
        # changes being reflected in anyone else&#39;s copy.
        if not http_tunnel_required:
            headers = headers.copy()
            headers.update(self.proxy_headers)
    
        # Must keep the exception bound to a separate variable or else Python 3
        # complains about UnboundLocalError.
        err = None
    
        # Keep track of whether we cleanly exited the except block. This
        # ensures we do proper cleanup in finally.
        clean_exit = False
    
        # Rewind body position, if needed. Record current position
        # for future rewinds in the event of a redirect/retry.
        body_pos = set_file_position(body, body_pos)
    
        try:
            # Request a connection from the queue.
            timeout_obj = self._get_timeout(timeout)
            conn = self._get_conn(timeout=pool_timeout)
    
            conn.timeout = timeout_obj.connect_timeout
    
            is_new_proxy_conn = self.proxy is not None and not getattr(
                conn, &#34;sock&#34;, None
            )
            if is_new_proxy_conn and http_tunnel_required:
                self._prepare_proxy(conn)
    
            # Make the request on the httplib connection object.
            httplib_response = self._make_request(
                conn,
                method,
                url,
                timeout=timeout_obj,
                body=body,
                headers=headers,
                chunked=chunked,
            )
    
            # If we&#39;re going to release the connection in ``finally:``, then
            # the response doesn&#39;t need to know about the connection. Otherwise
            # it will also try to release it and we&#39;ll have a double-release
            # mess.
            response_conn = conn if not release_conn else None
    
            # Pass method to Response for length checking
            response_kw[&#34;request_method&#34;] = method
    
            # Import httplib&#39;s response into our own wrapper object
            response = self.ResponseCls.from_httplib(
                httplib_response,
                pool=self,
                connection=response_conn,
                retries=retries,
                **response_kw
            )
    
            # Everything went great!
            clean_exit = True
    
        except EmptyPoolError:
            # Didn&#39;t get a connection from the pool, no need to clean up
            clean_exit = True
            release_this_conn = False
            raise
    
        except (
            TimeoutError,
            HTTPException,
            SocketError,
            ProtocolError,
            BaseSSLError,
            SSLError,
            CertificateError,
        ) as e:
            # Discard the connection for these exceptions. It will be
            # replaced during the next _get_conn() call.
            clean_exit = False
    
            def _is_ssl_error_message_from_http_proxy(ssl_error):
                # We&#39;re trying to detect the message &#39;WRONG_VERSION_NUMBER&#39; but
                # SSLErrors are kinda all over the place when it comes to the message,
                # so we try to cover our bases here!
                message = &#34; &#34;.join(re.split(&#34;[^a-z]&#34;, str(ssl_error).lower()))
                return (
                    &#34;wrong version number&#34; in message or &#34;unknown protocol&#34; in message
                )
    
            # Try to detect a common user error with proxies which is to
            # set an HTTP proxy to be HTTPS when it should be &#39;http://&#39;
            # (ie {&#39;http&#39;: &#39;http://proxy&#39;, &#39;https&#39;: &#39;https://proxy&#39;})
            # Instead we add a nice error message and point to a URL.
            if (
                isinstance(e, BaseSSLError)
                and self.proxy
                and _is_ssl_error_message_from_http_proxy(e)
                and conn.proxy
                and conn.proxy.scheme == &#34;https&#34;
            ):
                e = ProxyError(
                    &#34;Your proxy appears to only use HTTP and not HTTPS, &#34;
                    &#34;try changing your proxy URL to be HTTP. See: &#34;
                    &#34;https://urllib3.readthedocs.io/en/1.26.x/advanced-usage.html&#34;
                    &#34;#https-proxy-error-http-proxy&#34;,
                    SSLError(e),
                )
            elif isinstance(e, (BaseSSLError, CertificateError)):
                e = SSLError(e)
            elif isinstance(e, (SocketError, NewConnectionError)) and self.proxy:
                e = ProxyError(&#34;Cannot connect to proxy.&#34;, e)
            elif isinstance(e, (SocketError, HTTPException)):
                e = ProtocolError(&#34;Connection aborted.&#34;, e)
    
            retries = retries.increment(
                method, url, error=e, _pool=self, _stacktrace=sys.exc_info()[2]
            )
            retries.sleep()
    
            # Keep track of the error for the retry warning.
            err = e
    
        finally:
            if not clean_exit:
                # We hit some kind of exception, handled or otherwise. We need
                # to throw the connection away unless explicitly told not to.
                # Close the connection, set the variable to None, and make sure
                # we put the None back in the pool to avoid leaking it.
                conn = conn and conn.close()
                release_this_conn = True
    
            if release_this_conn:
                # Put the connection back to be reused. If the connection is
                # expired then it will be None, which will get replaced with a
                # fresh connection during _get_conn.
                self._put_conn(conn)
    
        if not conn:
            # Try again
            log.warning(
                &#34;Retrying (%r) after connection broken by &#39;%r&#39;: %s&#34;, retries, err, url
            )
            return self.urlopen(
                method,
                url,
                body,
                headers,
                retries,
                redirect,
                assert_same_host,
                timeout=timeout,
                pool_timeout=pool_timeout,
                release_conn=release_conn,
                chunked=chunked,
                body_pos=body_pos,
                **response_kw
            )
    
        # Handle redirect?
        redirect_location = redirect and response.get_redirect_location()
        if redirect_location:
            if response.status == 303:
                method = &#34;GET&#34;
    
            try:
                retries = retries.increment(method, url, response=response, _pool=self)
            except MaxRetryError:
                if retries.raise_on_redirect:
                    response.drain_conn()
                    raise
                return response
    
            response.drain_conn()
            retries.sleep_for_retry(response)
            log.debug(&#34;Redirecting %s -&gt; %s&#34;, url, redirect_location)
            return self.urlopen(
                method,
                redirect_location,
                body,
                headers,
                retries=retries,
                redirect=redirect,
                assert_same_host=assert_same_host,
                timeout=timeout,
                pool_timeout=pool_timeout,
                release_conn=release_conn,
                chunked=chunked,
                body_pos=body_pos,
                **response_kw
            )
    
        # Check if we should retry the HTTP response.
        has_retry_after = bool(response.getheader(&#34;Retry-After&#34;))
        if retries.is_retry(method, response.status, has_retry_after):
            try:
                retries = retries.increment(method, url, response=response, _pool=self)
            except MaxRetryError:
                if retries.raise_on_status:
                    response.drain_conn()
                    raise
                return response
    
            response.drain_conn()
            retries.sleep(response)
            log.debug(&#34;Retry: %s&#34;, url)
&gt;           return self.urlopen(
                method,
                url,
                body,
                headers,
                retries=retries,
                redirect=redirect,
                assert_same_host=assert_same_host,
                timeout=timeout,
                pool_timeout=pool_timeout,
                release_conn=release_conn,
                chunked=chunked,
                body_pos=body_pos,
                **response_kw
            )

/usr/local/lib/python3.8/site-packages/urllib3/connectionpool.py:878: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connectionpool.HTTPSConnectionPool object at 0x7f34c0383430&gt;
method = &#39;GET&#39;
url = &#34;/api1/x3/erp/QAL/AOBJEXT(&#39;WYXOHTERM&#39;)?representation=AOBJEXT.%24details&#34;
body = None
headers = {&#39;User-Agent&#39;: &#39;python-requests/2.28.1&#39;, &#39;Accept-Encoding&#39;: &#39;gzip, deflate&#39;, &#39;Accept&#39;: &#39;*/*&#39;, &#39;Connection&#39;: &#39;keep-alive&#39;, &#39;Content-Type&#39;: &#39;application/json&#39;, &#39;Authorization&#39;: &#39;Basic aW50cmFjbzpXYXNzaW1Db3ZhZ2VA&#39;}
retries = Retry(total=1, connect=None, read=None, redirect=None, status=None)
redirect = False, assert_same_host = False
timeout = Timeout(connect=None, read=None, total=None), pool_timeout = None
release_conn = False, chunked = False, body_pos = None
response_kw = {&#39;decode_content&#39;: False, &#39;preload_content&#39;: False, &#39;request_method&#39;: &#39;GET&#39;}
parsed_url = Url(scheme=None, auth=None, host=None, port=None, path=&#34;/api1/x3/erp/QAL/AOBJEXT(&#39;WYXOHTERM&#39;)&#34;, query=&#39;representation=AOBJEXT.%24details&#39;, fragment=None)
destination_scheme = None
conn = &lt;urllib3.connection.HTTPSConnection object at 0x7f34bbb16910&gt;
release_this_conn = False, http_tunnel_required = True, err = None
clean_exit = True

    def urlopen(
        self,
        method,
        url,
        body=None,
        headers=None,
        retries=None,
        redirect=True,
        assert_same_host=True,
        timeout=_Default,
        pool_timeout=None,
        release_conn=None,
        chunked=False,
        body_pos=None,
        **response_kw
    ):
        &#34;&#34;&#34;
        Get a connection from the pool and perform an HTTP request. This is the
        lowest level call for making a request, so you&#39;ll need to specify all
        the raw details.
    
        .. note::
    
           More commonly, it&#39;s appropriate to use a convenience method provided
           by :class:`.RequestMethods`, such as :meth:`request`.
    
        .. note::
    
           `release_conn` will only behave as expected if
           `preload_content=False` because we want to make
           `preload_content=False` the default behaviour someday soon without
           breaking backwards compatibility.
    
        :param method:
            HTTP request method (such as GET, POST, PUT, etc.)
    
        :param url:
            The URL to perform the request on.
    
        :param body:
            Data to send in the request body, either :class:`str`, :class:`bytes`,
            an iterable of :class:`str`/:class:`bytes`, or a file-like object.
    
        :param headers:
            Dictionary of custom headers to send, such as User-Agent,
            If-None-Match, etc. If None, pool headers are used. If provided,
            these headers completely replace any pool-specific headers.
    
        :param retries:
            Configure the number of retries to allow before raising a
            :class:`~urllib3.exceptions.MaxRetryError` exception.
    
            Pass ``None`` to retry until you receive a response. Pass a
            :class:`~urllib3.util.retry.Retry` object for fine-grained control
            over different types of retries.
            Pass an integer number to retry connection errors that many times,
            but no other types of errors. Pass zero to never retry.
    
            If ``False``, then retries are disabled and any exception is raised
            immediately. Also, instead of raising a MaxRetryError on redirects,
            the redirect response will be returned.
    
        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.
    
        :param redirect:
            If True, automatically handle redirects (status codes 301, 302,
            303, 307, 308). Each redirect counts as a retry. Disabling retries
            will disable redirect, too.
    
        :param assert_same_host:
            If ``True``, will make sure that the host of the pool requests is
            consistent else will raise HostChangedError. When ``False``, you can
            use the pool on an HTTP proxy and request foreign hosts.
    
        :param timeout:
            If specified, overrides the default timeout for this one
            request. It may be a float (in seconds) or an instance of
            :class:`urllib3.util.Timeout`.
    
        :param pool_timeout:
            If set and the pool is set to block=True, then this method will
            block for ``pool_timeout`` seconds and raise EmptyPoolError if no
            connection is available within the time period.
    
        :param release_conn:
            If False, then the urlopen call will not release the connection
            back into the pool once a response is received (but will release if
            you read the entire contents of the response such as when
            `preload_content=True`). This is useful if you&#39;re not preloading
            the response&#39;s content immediately. You will need to call
            ``r.release_conn()`` on the response ``r`` to return the connection
            back into the pool. If None, it takes the value of
            ``response_kw.get(&#39;preload_content&#39;, True)``.
    
        :param chunked:
            If True, urllib3 will send the body using chunked transfer
            encoding. Otherwise, urllib3 will send the body using the standard
            content-length form. Defaults to False.
    
        :param int body_pos:
            Position to seek to in file-like body in the event of a retry or
            redirect. Typically this won&#39;t need to be set because urllib3 will
            auto-populate the value when needed.
    
        :param \\**response_kw:
            Additional parameters are passed to
            :meth:`urllib3.response.HTTPResponse.from_httplib`
        &#34;&#34;&#34;
    
        parsed_url = parse_url(url)
        destination_scheme = parsed_url.scheme
    
        if headers is None:
            headers = self.headers
    
        if not isinstance(retries, Retry):
            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)
    
        if release_conn is None:
            release_conn = response_kw.get(&#34;preload_content&#34;, True)
    
        # Check host
        if assert_same_host and not self.is_same_host(url):
            raise HostChangedError(self, url, retries)
    
        # Ensure that the URL we&#39;re connecting to is properly encoded
        if url.startswith(&#34;/&#34;):
            url = six.ensure_str(_encode_target(url))
        else:
            url = six.ensure_str(parsed_url.url)
    
        conn = None
    
        # Track whether `conn` needs to be released before
        # returning/raising/recursing. Update this variable if necessary, and
        # leave `release_conn` constant throughout the function. That way, if
        # the function recurses, the original value of `release_conn` will be
        # passed down into the recursive call, and its value will be respected.
        #
        # See issue #651 [1] for details.
        #
        # [1] &lt;https://github.com/urllib3/urllib3/issues/651&gt;
        release_this_conn = release_conn
    
        http_tunnel_required = connection_requires_http_tunnel(
            self.proxy, self.proxy_config, destination_scheme
        )
    
        # Merge the proxy headers. Only done when not using HTTP CONNECT. We
        # have to copy the headers dict so we can safely change it without those
        # changes being reflected in anyone else&#39;s copy.
        if not http_tunnel_required:
            headers = headers.copy()
            headers.update(self.proxy_headers)
    
        # Must keep the exception bound to a separate variable or else Python 3
        # complains about UnboundLocalError.
        err = None
    
        # Keep track of whether we cleanly exited the except block. This
        # ensures we do proper cleanup in finally.
        clean_exit = False
    
        # Rewind body position, if needed. Record current position
        # for future rewinds in the event of a redirect/retry.
        body_pos = set_file_position(body, body_pos)
    
        try:
            # Request a connection from the queue.
            timeout_obj = self._get_timeout(timeout)
            conn = self._get_conn(timeout=pool_timeout)
    
            conn.timeout = timeout_obj.connect_timeout
    
            is_new_proxy_conn = self.proxy is not None and not getattr(
                conn, &#34;sock&#34;, None
            )
            if is_new_proxy_conn and http_tunnel_required:
                self._prepare_proxy(conn)
    
            # Make the request on the httplib connection object.
            httplib_response = self._make_request(
                conn,
                method,
                url,
                timeout=timeout_obj,
                body=body,
                headers=headers,
                chunked=chunked,
            )
    
            # If we&#39;re going to release the connection in ``finally:``, then
            # the response doesn&#39;t need to know about the connection. Otherwise
            # it will also try to release it and we&#39;ll have a double-release
            # mess.
            response_conn = conn if not release_conn else None
    
            # Pass method to Response for length checking
            response_kw[&#34;request_method&#34;] = method
    
            # Import httplib&#39;s response into our own wrapper object
            response = self.ResponseCls.from_httplib(
                httplib_response,
                pool=self,
                connection=response_conn,
                retries=retries,
                **response_kw
            )
    
            # Everything went great!
            clean_exit = True
    
        except EmptyPoolError:
            # Didn&#39;t get a connection from the pool, no need to clean up
            clean_exit = True
            release_this_conn = False
            raise
    
        except (
            TimeoutError,
            HTTPException,
            SocketError,
            ProtocolError,
            BaseSSLError,
            SSLError,
            CertificateError,
        ) as e:
            # Discard the connection for these exceptions. It will be
            # replaced during the next _get_conn() call.
            clean_exit = False
    
            def _is_ssl_error_message_from_http_proxy(ssl_error):
                # We&#39;re trying to detect the message &#39;WRONG_VERSION_NUMBER&#39; but
                # SSLErrors are kinda all over the place when it comes to the message,
                # so we try to cover our bases here!
                message = &#34; &#34;.join(re.split(&#34;[^a-z]&#34;, str(ssl_error).lower()))
                return (
                    &#34;wrong version number&#34; in message or &#34;unknown protocol&#34; in message
                )
    
            # Try to detect a common user error with proxies which is to
            # set an HTTP proxy to be HTTPS when it should be &#39;http://&#39;
            # (ie {&#39;http&#39;: &#39;http://proxy&#39;, &#39;https&#39;: &#39;https://proxy&#39;})
            # Instead we add a nice error message and point to a URL.
            if (
                isinstance(e, BaseSSLError)
                and self.proxy
                and _is_ssl_error_message_from_http_proxy(e)
                and conn.proxy
                and conn.proxy.scheme == &#34;https&#34;
            ):
                e = ProxyError(
                    &#34;Your proxy appears to only use HTTP and not HTTPS, &#34;
                    &#34;try changing your proxy URL to be HTTP. See: &#34;
                    &#34;https://urllib3.readthedocs.io/en/1.26.x/advanced-usage.html&#34;
                    &#34;#https-proxy-error-http-proxy&#34;,
                    SSLError(e),
                )
            elif isinstance(e, (BaseSSLError, CertificateError)):
                e = SSLError(e)
            elif isinstance(e, (SocketError, NewConnectionError)) and self.proxy:
                e = ProxyError(&#34;Cannot connect to proxy.&#34;, e)
            elif isinstance(e, (SocketError, HTTPException)):
                e = ProtocolError(&#34;Connection aborted.&#34;, e)
    
            retries = retries.increment(
                method, url, error=e, _pool=self, _stacktrace=sys.exc_info()[2]
            )
            retries.sleep()
    
            # Keep track of the error for the retry warning.
            err = e
    
        finally:
            if not clean_exit:
                # We hit some kind of exception, handled or otherwise. We need
                # to throw the connection away unless explicitly told not to.
                # Close the connection, set the variable to None, and make sure
                # we put the None back in the pool to avoid leaking it.
                conn = conn and conn.close()
                release_this_conn = True
    
            if release_this_conn:
                # Put the connection back to be reused. If the connection is
                # expired then it will be None, which will get replaced with a
                # fresh connection during _get_conn.
                self._put_conn(conn)
    
        if not conn:
            # Try again
            log.warning(
                &#34;Retrying (%r) after connection broken by &#39;%r&#39;: %s&#34;, retries, err, url
            )
            return self.urlopen(
                method,
                url,
                body,
                headers,
                retries,
                redirect,
                assert_same_host,
                timeout=timeout,
                pool_timeout=pool_timeout,
                release_conn=release_conn,
                chunked=chunked,
                body_pos=body_pos,
                **response_kw
            )
    
        # Handle redirect?
        redirect_location = redirect and response.get_redirect_location()
        if redirect_location:
            if response.status == 303:
                method = &#34;GET&#34;
    
            try:
                retries = retries.increment(method, url, response=response, _pool=self)
            except MaxRetryError:
                if retries.raise_on_redirect:
                    response.drain_conn()
                    raise
                return response
    
            response.drain_conn()
            retries.sleep_for_retry(response)
            log.debug(&#34;Redirecting %s -&gt; %s&#34;, url, redirect_location)
            return self.urlopen(
                method,
                redirect_location,
                body,
                headers,
                retries=retries,
                redirect=redirect,
                assert_same_host=assert_same_host,
                timeout=timeout,
                pool_timeout=pool_timeout,
                release_conn=release_conn,
                chunked=chunked,
                body_pos=body_pos,
                **response_kw
            )
    
        # Check if we should retry the HTTP response.
        has_retry_after = bool(response.getheader(&#34;Retry-After&#34;))
        if retries.is_retry(method, response.status, has_retry_after):
            try:
                retries = retries.increment(method, url, response=response, _pool=self)
            except MaxRetryError:
                if retries.raise_on_status:
                    response.drain_conn()
                    raise
                return response
    
            response.drain_conn()
            retries.sleep(response)
            log.debug(&#34;Retry: %s&#34;, url)
&gt;           return self.urlopen(
                method,
                url,
                body,
                headers,
                retries=retries,
                redirect=redirect,
                assert_same_host=assert_same_host,
                timeout=timeout,
                pool_timeout=pool_timeout,
                release_conn=release_conn,
                chunked=chunked,
                body_pos=body_pos,
                **response_kw
            )

/usr/local/lib/python3.8/site-packages/urllib3/connectionpool.py:878: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connectionpool.HTTPSConnectionPool object at 0x7f34c0383430&gt;
method = &#39;GET&#39;
url = &#34;/api1/x3/erp/QAL/AOBJEXT(&#39;WYXOHTERM&#39;)?representation=AOBJEXT.%24details&#34;
body = None
headers = {&#39;User-Agent&#39;: &#39;python-requests/2.28.1&#39;, &#39;Accept-Encoding&#39;: &#39;gzip, deflate&#39;, &#39;Accept&#39;: &#39;*/*&#39;, &#39;Connection&#39;: &#39;keep-alive&#39;, &#39;Content-Type&#39;: &#39;application/json&#39;, &#39;Authorization&#39;: &#39;Basic aW50cmFjbzpXYXNzaW1Db3ZhZ2VA&#39;}
retries = Retry(total=0, connect=None, read=None, redirect=None, status=None)
redirect = False, assert_same_host = False
timeout = Timeout(connect=None, read=None, total=None), pool_timeout = None
release_conn = False, chunked = False, body_pos = None
response_kw = {&#39;decode_content&#39;: False, &#39;preload_content&#39;: False, &#39;request_method&#39;: &#39;GET&#39;}
parsed_url = Url(scheme=None, auth=None, host=None, port=None, path=&#34;/api1/x3/erp/QAL/AOBJEXT(&#39;WYXOHTERM&#39;)&#34;, query=&#39;representation=AOBJEXT.%24details&#39;, fragment=None)
destination_scheme = None
conn = &lt;urllib3.connection.HTTPSConnection object at 0x7f34bbb16910&gt;
release_this_conn = False, http_tunnel_required = True, err = None
clean_exit = True

    def urlopen(
        self,
        method,
        url,
        body=None,
        headers=None,
        retries=None,
        redirect=True,
        assert_same_host=True,
        timeout=_Default,
        pool_timeout=None,
        release_conn=None,
        chunked=False,
        body_pos=None,
        **response_kw
    ):
        &#34;&#34;&#34;
        Get a connection from the pool and perform an HTTP request. This is the
        lowest level call for making a request, so you&#39;ll need to specify all
        the raw details.
    
        .. note::
    
           More commonly, it&#39;s appropriate to use a convenience method provided
           by :class:`.RequestMethods`, such as :meth:`request`.
    
        .. note::
    
           `release_conn` will only behave as expected if
           `preload_content=False` because we want to make
           `preload_content=False` the default behaviour someday soon without
           breaking backwards compatibility.
    
        :param method:
            HTTP request method (such as GET, POST, PUT, etc.)
    
        :param url:
            The URL to perform the request on.
    
        :param body:
            Data to send in the request body, either :class:`str`, :class:`bytes`,
            an iterable of :class:`str`/:class:`bytes`, or a file-like object.
    
        :param headers:
            Dictionary of custom headers to send, such as User-Agent,
            If-None-Match, etc. If None, pool headers are used. If provided,
            these headers completely replace any pool-specific headers.
    
        :param retries:
            Configure the number of retries to allow before raising a
            :class:`~urllib3.exceptions.MaxRetryError` exception.
    
            Pass ``None`` to retry until you receive a response. Pass a
            :class:`~urllib3.util.retry.Retry` object for fine-grained control
            over different types of retries.
            Pass an integer number to retry connection errors that many times,
            but no other types of errors. Pass zero to never retry.
    
            If ``False``, then retries are disabled and any exception is raised
            immediately. Also, instead of raising a MaxRetryError on redirects,
            the redirect response will be returned.
    
        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.
    
        :param redirect:
            If True, automatically handle redirects (status codes 301, 302,
            303, 307, 308). Each redirect counts as a retry. Disabling retries
            will disable redirect, too.
    
        :param assert_same_host:
            If ``True``, will make sure that the host of the pool requests is
            consistent else will raise HostChangedError. When ``False``, you can
            use the pool on an HTTP proxy and request foreign hosts.
    
        :param timeout:
            If specified, overrides the default timeout for this one
            request. It may be a float (in seconds) or an instance of
            :class:`urllib3.util.Timeout`.
    
        :param pool_timeout:
            If set and the pool is set to block=True, then this method will
            block for ``pool_timeout`` seconds and raise EmptyPoolError if no
            connection is available within the time period.
    
        :param release_conn:
            If False, then the urlopen call will not release the connection
            back into the pool once a response is received (but will release if
            you read the entire contents of the response such as when
            `preload_content=True`). This is useful if you&#39;re not preloading
            the response&#39;s content immediately. You will need to call
            ``r.release_conn()`` on the response ``r`` to return the connection
            back into the pool. If None, it takes the value of
            ``response_kw.get(&#39;preload_content&#39;, True)``.
    
        :param chunked:
            If True, urllib3 will send the body using chunked transfer
            encoding. Otherwise, urllib3 will send the body using the standard
            content-length form. Defaults to False.
    
        :param int body_pos:
            Position to seek to in file-like body in the event of a retry or
            redirect. Typically this won&#39;t need to be set because urllib3 will
            auto-populate the value when needed.
    
        :param \\**response_kw:
            Additional parameters are passed to
            :meth:`urllib3.response.HTTPResponse.from_httplib`
        &#34;&#34;&#34;
    
        parsed_url = parse_url(url)
        destination_scheme = parsed_url.scheme
    
        if headers is None:
            headers = self.headers
    
        if not isinstance(retries, Retry):
            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)
    
        if release_conn is None:
            release_conn = response_kw.get(&#34;preload_content&#34;, True)
    
        # Check host
        if assert_same_host and not self.is_same_host(url):
            raise HostChangedError(self, url, retries)
    
        # Ensure that the URL we&#39;re connecting to is properly encoded
        if url.startswith(&#34;/&#34;):
            url = six.ensure_str(_encode_target(url))
        else:
            url = six.ensure_str(parsed_url.url)
    
        conn = None
    
        # Track whether `conn` needs to be released before
        # returning/raising/recursing. Update this variable if necessary, and
        # leave `release_conn` constant throughout the function. That way, if
        # the function recurses, the original value of `release_conn` will be
        # passed down into the recursive call, and its value will be respected.
        #
        # See issue #651 [1] for details.
        #
        # [1] &lt;https://github.com/urllib3/urllib3/issues/651&gt;
        release_this_conn = release_conn
    
        http_tunnel_required = connection_requires_http_tunnel(
            self.proxy, self.proxy_config, destination_scheme
        )
    
        # Merge the proxy headers. Only done when not using HTTP CONNECT. We
        # have to copy the headers dict so we can safely change it without those
        # changes being reflected in anyone else&#39;s copy.
        if not http_tunnel_required:
            headers = headers.copy()
            headers.update(self.proxy_headers)
    
        # Must keep the exception bound to a separate variable or else Python 3
        # complains about UnboundLocalError.
        err = None
    
        # Keep track of whether we cleanly exited the except block. This
        # ensures we do proper cleanup in finally.
        clean_exit = False
    
        # Rewind body position, if needed. Record current position
        # for future rewinds in the event of a redirect/retry.
        body_pos = set_file_position(body, body_pos)
    
        try:
            # Request a connection from the queue.
            timeout_obj = self._get_timeout(timeout)
            conn = self._get_conn(timeout=pool_timeout)
    
            conn.timeout = timeout_obj.connect_timeout
    
            is_new_proxy_conn = self.proxy is not None and not getattr(
                conn, &#34;sock&#34;, None
            )
            if is_new_proxy_conn and http_tunnel_required:
                self._prepare_proxy(conn)
    
            # Make the request on the httplib connection object.
            httplib_response = self._make_request(
                conn,
                method,
                url,
                timeout=timeout_obj,
                body=body,
                headers=headers,
                chunked=chunked,
            )
    
            # If we&#39;re going to release the connection in ``finally:``, then
            # the response doesn&#39;t need to know about the connection. Otherwise
            # it will also try to release it and we&#39;ll have a double-release
            # mess.
            response_conn = conn if not release_conn else None
    
            # Pass method to Response for length checking
            response_kw[&#34;request_method&#34;] = method
    
            # Import httplib&#39;s response into our own wrapper object
            response = self.ResponseCls.from_httplib(
                httplib_response,
                pool=self,
                connection=response_conn,
                retries=retries,
                **response_kw
            )
    
            # Everything went great!
            clean_exit = True
    
        except EmptyPoolError:
            # Didn&#39;t get a connection from the pool, no need to clean up
            clean_exit = True
            release_this_conn = False
            raise
    
        except (
            TimeoutError,
            HTTPException,
            SocketError,
            ProtocolError,
            BaseSSLError,
            SSLError,
            CertificateError,
        ) as e:
            # Discard the connection for these exceptions. It will be
            # replaced during the next _get_conn() call.
            clean_exit = False
    
            def _is_ssl_error_message_from_http_proxy(ssl_error):
                # We&#39;re trying to detect the message &#39;WRONG_VERSION_NUMBER&#39; but
                # SSLErrors are kinda all over the place when it comes to the message,
                # so we try to cover our bases here!
                message = &#34; &#34;.join(re.split(&#34;[^a-z]&#34;, str(ssl_error).lower()))
                return (
                    &#34;wrong version number&#34; in message or &#34;unknown protocol&#34; in message
                )
    
            # Try to detect a common user error with proxies which is to
            # set an HTTP proxy to be HTTPS when it should be &#39;http://&#39;
            # (ie {&#39;http&#39;: &#39;http://proxy&#39;, &#39;https&#39;: &#39;https://proxy&#39;})
            # Instead we add a nice error message and point to a URL.
            if (
                isinstance(e, BaseSSLError)
                and self.proxy
                and _is_ssl_error_message_from_http_proxy(e)
                and conn.proxy
                and conn.proxy.scheme == &#34;https&#34;
            ):
                e = ProxyError(
                    &#34;Your proxy appears to only use HTTP and not HTTPS, &#34;
                    &#34;try changing your proxy URL to be HTTP. See: &#34;
                    &#34;https://urllib3.readthedocs.io/en/1.26.x/advanced-usage.html&#34;
                    &#34;#https-proxy-error-http-proxy&#34;,
                    SSLError(e),
                )
            elif isinstance(e, (BaseSSLError, CertificateError)):
                e = SSLError(e)
            elif isinstance(e, (SocketError, NewConnectionError)) and self.proxy:
                e = ProxyError(&#34;Cannot connect to proxy.&#34;, e)
            elif isinstance(e, (SocketError, HTTPException)):
                e = ProtocolError(&#34;Connection aborted.&#34;, e)
    
            retries = retries.increment(
                method, url, error=e, _pool=self, _stacktrace=sys.exc_info()[2]
            )
            retries.sleep()
    
            # Keep track of the error for the retry warning.
            err = e
    
        finally:
            if not clean_exit:
                # We hit some kind of exception, handled or otherwise. We need
                # to throw the connection away unless explicitly told not to.
                # Close the connection, set the variable to None, and make sure
                # we put the None back in the pool to avoid leaking it.
                conn = conn and conn.close()
                release_this_conn = True
    
            if release_this_conn:
                # Put the connection back to be reused. If the connection is
                # expired then it will be None, which will get replaced with a
                # fresh connection during _get_conn.
                self._put_conn(conn)
    
        if not conn:
            # Try again
            log.warning(
                &#34;Retrying (%r) after connection broken by &#39;%r&#39;: %s&#34;, retries, err, url
            )
            return self.urlopen(
                method,
                url,
                body,
                headers,
                retries,
                redirect,
                assert_same_host,
                timeout=timeout,
                pool_timeout=pool_timeout,
                release_conn=release_conn,
                chunked=chunked,
                body_pos=body_pos,
                **response_kw
            )
    
        # Handle redirect?
        redirect_location = redirect and response.get_redirect_location()
        if redirect_location:
            if response.status == 303:
                method = &#34;GET&#34;
    
            try:
                retries = retries.increment(method, url, response=response, _pool=self)
            except MaxRetryError:
                if retries.raise_on_redirect:
                    response.drain_conn()
                    raise
                return response
    
            response.drain_conn()
            retries.sleep_for_retry(response)
            log.debug(&#34;Redirecting %s -&gt; %s&#34;, url, redirect_location)
            return self.urlopen(
                method,
                redirect_location,
                body,
                headers,
                retries=retries,
                redirect=redirect,
                assert_same_host=assert_same_host,
                timeout=timeout,
                pool_timeout=pool_timeout,
                release_conn=release_conn,
                chunked=chunked,
                body_pos=body_pos,
                **response_kw
            )
    
        # Check if we should retry the HTTP response.
        has_retry_after = bool(response.getheader(&#34;Retry-After&#34;))
        if retries.is_retry(method, response.status, has_retry_after):
            try:
                retries = retries.increment(method, url, response=response, _pool=self)
            except MaxRetryError:
                if retries.raise_on_status:
                    response.drain_conn()
                    raise
                return response
    
            response.drain_conn()
            retries.sleep(response)
            log.debug(&#34;Retry: %s&#34;, url)
&gt;           return self.urlopen(
                method,
                url,
                body,
                headers,
                retries=retries,
                redirect=redirect,
                assert_same_host=assert_same_host,
                timeout=timeout,
                pool_timeout=pool_timeout,
                release_conn=release_conn,
                chunked=chunked,
                body_pos=body_pos,
                **response_kw
            )

/usr/local/lib/python3.8/site-packages/urllib3/connectionpool.py:878: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connectionpool.HTTPSConnectionPool object at 0x7f34c0383430&gt;
method = &#39;GET&#39;
url = &#34;/api1/x3/erp/QAL/AOBJEXT(&#39;WYXOHTERM&#39;)?representation=AOBJEXT.%24details&#34;
body = None
headers = {&#39;User-Agent&#39;: &#39;python-requests/2.28.1&#39;, &#39;Accept-Encoding&#39;: &#39;gzip, deflate&#39;, &#39;Accept&#39;: &#39;*/*&#39;, &#39;Connection&#39;: &#39;keep-alive&#39;, &#39;Content-Type&#39;: &#39;application/json&#39;, &#39;Authorization&#39;: &#39;Basic aW50cmFjbzpXYXNzaW1Db3ZhZ2VA&#39;}
retries = Retry(total=0, connect=None, read=None, redirect=None, status=None)
redirect = False, assert_same_host = False
timeout = Timeout(connect=None, read=None, total=None), pool_timeout = None
release_conn = False, chunked = False, body_pos = None
response_kw = {&#39;decode_content&#39;: False, &#39;preload_content&#39;: False, &#39;request_method&#39;: &#39;GET&#39;}
parsed_url = Url(scheme=None, auth=None, host=None, port=None, path=&#34;/api1/x3/erp/QAL/AOBJEXT(&#39;WYXOHTERM&#39;)&#34;, query=&#39;representation=AOBJEXT.%24details&#39;, fragment=None)
destination_scheme = None
conn = &lt;urllib3.connection.HTTPSConnection object at 0x7f34bbb16910&gt;
release_this_conn = False, http_tunnel_required = True, err = None
clean_exit = True

    def urlopen(
        self,
        method,
        url,
        body=None,
        headers=None,
        retries=None,
        redirect=True,
        assert_same_host=True,
        timeout=_Default,
        pool_timeout=None,
        release_conn=None,
        chunked=False,
        body_pos=None,
        **response_kw
    ):
        &#34;&#34;&#34;
        Get a connection from the pool and perform an HTTP request. This is the
        lowest level call for making a request, so you&#39;ll need to specify all
        the raw details.
    
        .. note::
    
           More commonly, it&#39;s appropriate to use a convenience method provided
           by :class:`.RequestMethods`, such as :meth:`request`.
    
        .. note::
    
           `release_conn` will only behave as expected if
           `preload_content=False` because we want to make
           `preload_content=False` the default behaviour someday soon without
           breaking backwards compatibility.
    
        :param method:
            HTTP request method (such as GET, POST, PUT, etc.)
    
        :param url:
            The URL to perform the request on.
    
        :param body:
            Data to send in the request body, either :class:`str`, :class:`bytes`,
            an iterable of :class:`str`/:class:`bytes`, or a file-like object.
    
        :param headers:
            Dictionary of custom headers to send, such as User-Agent,
            If-None-Match, etc. If None, pool headers are used. If provided,
            these headers completely replace any pool-specific headers.
    
        :param retries:
            Configure the number of retries to allow before raising a
            :class:`~urllib3.exceptions.MaxRetryError` exception.
    
            Pass ``None`` to retry until you receive a response. Pass a
            :class:`~urllib3.util.retry.Retry` object for fine-grained control
            over different types of retries.
            Pass an integer number to retry connection errors that many times,
            but no other types of errors. Pass zero to never retry.
    
            If ``False``, then retries are disabled and any exception is raised
            immediately. Also, instead of raising a MaxRetryError on redirects,
            the redirect response will be returned.
    
        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.
    
        :param redirect:
            If True, automatically handle redirects (status codes 301, 302,
            303, 307, 308). Each redirect counts as a retry. Disabling retries
            will disable redirect, too.
    
        :param assert_same_host:
            If ``True``, will make sure that the host of the pool requests is
            consistent else will raise HostChangedError. When ``False``, you can
            use the pool on an HTTP proxy and request foreign hosts.
    
        :param timeout:
            If specified, overrides the default timeout for this one
            request. It may be a float (in seconds) or an instance of
            :class:`urllib3.util.Timeout`.
    
        :param pool_timeout:
            If set and the pool is set to block=True, then this method will
            block for ``pool_timeout`` seconds and raise EmptyPoolError if no
            connection is available within the time period.
    
        :param release_conn:
            If False, then the urlopen call will not release the connection
            back into the pool once a response is received (but will release if
            you read the entire contents of the response such as when
            `preload_content=True`). This is useful if you&#39;re not preloading
            the response&#39;s content immediately. You will need to call
            ``r.release_conn()`` on the response ``r`` to return the connection
            back into the pool. If None, it takes the value of
            ``response_kw.get(&#39;preload_content&#39;, True)``.
    
        :param chunked:
            If True, urllib3 will send the body using chunked transfer
            encoding. Otherwise, urllib3 will send the body using the standard
            content-length form. Defaults to False.
    
        :param int body_pos:
            Position to seek to in file-like body in the event of a retry or
            redirect. Typically this won&#39;t need to be set because urllib3 will
            auto-populate the value when needed.
    
        :param \\**response_kw:
            Additional parameters are passed to
            :meth:`urllib3.response.HTTPResponse.from_httplib`
        &#34;&#34;&#34;
    
        parsed_url = parse_url(url)
        destination_scheme = parsed_url.scheme
    
        if headers is None:
            headers = self.headers
    
        if not isinstance(retries, Retry):
            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)
    
        if release_conn is None:
            release_conn = response_kw.get(&#34;preload_content&#34;, True)
    
        # Check host
        if assert_same_host and not self.is_same_host(url):
            raise HostChangedError(self, url, retries)
    
        # Ensure that the URL we&#39;re connecting to is properly encoded
        if url.startswith(&#34;/&#34;):
            url = six.ensure_str(_encode_target(url))
        else:
            url = six.ensure_str(parsed_url.url)
    
        conn = None
    
        # Track whether `conn` needs to be released before
        # returning/raising/recursing. Update this variable if necessary, and
        # leave `release_conn` constant throughout the function. That way, if
        # the function recurses, the original value of `release_conn` will be
        # passed down into the recursive call, and its value will be respected.
        #
        # See issue #651 [1] for details.
        #
        # [1] &lt;https://github.com/urllib3/urllib3/issues/651&gt;
        release_this_conn = release_conn
    
        http_tunnel_required = connection_requires_http_tunnel(
            self.proxy, self.proxy_config, destination_scheme
        )
    
        # Merge the proxy headers. Only done when not using HTTP CONNECT. We
        # have to copy the headers dict so we can safely change it without those
        # changes being reflected in anyone else&#39;s copy.
        if not http_tunnel_required:
            headers = headers.copy()
            headers.update(self.proxy_headers)
    
        # Must keep the exception bound to a separate variable or else Python 3
        # complains about UnboundLocalError.
        err = None
    
        # Keep track of whether we cleanly exited the except block. This
        # ensures we do proper cleanup in finally.
        clean_exit = False
    
        # Rewind body position, if needed. Record current position
        # for future rewinds in the event of a redirect/retry.
        body_pos = set_file_position(body, body_pos)
    
        try:
            # Request a connection from the queue.
            timeout_obj = self._get_timeout(timeout)
            conn = self._get_conn(timeout=pool_timeout)
    
            conn.timeout = timeout_obj.connect_timeout
    
            is_new_proxy_conn = self.proxy is not None and not getattr(
                conn, &#34;sock&#34;, None
            )
            if is_new_proxy_conn and http_tunnel_required:
                self._prepare_proxy(conn)
    
            # Make the request on the httplib connection object.
            httplib_response = self._make_request(
                conn,
                method,
                url,
                timeout=timeout_obj,
                body=body,
                headers=headers,
                chunked=chunked,
            )
    
            # If we&#39;re going to release the connection in ``finally:``, then
            # the response doesn&#39;t need to know about the connection. Otherwise
            # it will also try to release it and we&#39;ll have a double-release
            # mess.
            response_conn = conn if not release_conn else None
    
            # Pass method to Response for length checking
            response_kw[&#34;request_method&#34;] = method
    
            # Import httplib&#39;s response into our own wrapper object
            response = self.ResponseCls.from_httplib(
                httplib_response,
                pool=self,
                connection=response_conn,
                retries=retries,
                **response_kw
            )
    
            # Everything went great!
            clean_exit = True
    
        except EmptyPoolError:
            # Didn&#39;t get a connection from the pool, no need to clean up
            clean_exit = True
            release_this_conn = False
            raise
    
        except (
            TimeoutError,
            HTTPException,
            SocketError,
            ProtocolError,
            BaseSSLError,
            SSLError,
            CertificateError,
        ) as e:
            # Discard the connection for these exceptions. It will be
            # replaced during the next _get_conn() call.
            clean_exit = False
    
            def _is_ssl_error_message_from_http_proxy(ssl_error):
                # We&#39;re trying to detect the message &#39;WRONG_VERSION_NUMBER&#39; but
                # SSLErrors are kinda all over the place when it comes to the message,
                # so we try to cover our bases here!
                message = &#34; &#34;.join(re.split(&#34;[^a-z]&#34;, str(ssl_error).lower()))
                return (
                    &#34;wrong version number&#34; in message or &#34;unknown protocol&#34; in message
                )
    
            # Try to detect a common user error with proxies which is to
            # set an HTTP proxy to be HTTPS when it should be &#39;http://&#39;
            # (ie {&#39;http&#39;: &#39;http://proxy&#39;, &#39;https&#39;: &#39;https://proxy&#39;})
            # Instead we add a nice error message and point to a URL.
            if (
                isinstance(e, BaseSSLError)
                and self.proxy
                and _is_ssl_error_message_from_http_proxy(e)
                and conn.proxy
                and conn.proxy.scheme == &#34;https&#34;
            ):
                e = ProxyError(
                    &#34;Your proxy appears to only use HTTP and not HTTPS, &#34;
                    &#34;try changing your proxy URL to be HTTP. See: &#34;
                    &#34;https://urllib3.readthedocs.io/en/1.26.x/advanced-usage.html&#34;
                    &#34;#https-proxy-error-http-proxy&#34;,
                    SSLError(e),
                )
            elif isinstance(e, (BaseSSLError, CertificateError)):
                e = SSLError(e)
            elif isinstance(e, (SocketError, NewConnectionError)) and self.proxy:
                e = ProxyError(&#34;Cannot connect to proxy.&#34;, e)
            elif isinstance(e, (SocketError, HTTPException)):
                e = ProtocolError(&#34;Connection aborted.&#34;, e)
    
            retries = retries.increment(
                method, url, error=e, _pool=self, _stacktrace=sys.exc_info()[2]
            )
            retries.sleep()
    
            # Keep track of the error for the retry warning.
            err = e
    
        finally:
            if not clean_exit:
                # We hit some kind of exception, handled or otherwise. We need
                # to throw the connection away unless explicitly told not to.
                # Close the connection, set the variable to None, and make sure
                # we put the None back in the pool to avoid leaking it.
                conn = conn and conn.close()
                release_this_conn = True
    
            if release_this_conn:
                # Put the connection back to be reused. If the connection is
                # expired then it will be None, which will get replaced with a
                # fresh connection during _get_conn.
                self._put_conn(conn)
    
        if not conn:
            # Try again
            log.warning(
                &#34;Retrying (%r) after connection broken by &#39;%r&#39;: %s&#34;, retries, err, url
            )
            return self.urlopen(
                method,
                url,
                body,
                headers,
                retries,
                redirect,
                assert_same_host,
                timeout=timeout,
                pool_timeout=pool_timeout,
                release_conn=release_conn,
                chunked=chunked,
                body_pos=body_pos,
                **response_kw
            )
    
        # Handle redirect?
        redirect_location = redirect and response.get_redirect_location()
        if redirect_location:
            if response.status == 303:
                method = &#34;GET&#34;
    
            try:
                retries = retries.increment(method, url, response=response, _pool=self)
            except MaxRetryError:
                if retries.raise_on_redirect:
                    response.drain_conn()
                    raise
                return response
    
            response.drain_conn()
            retries.sleep_for_retry(response)
            log.debug(&#34;Redirecting %s -&gt; %s&#34;, url, redirect_location)
            return self.urlopen(
                method,
                redirect_location,
                body,
                headers,
                retries=retries,
                redirect=redirect,
                assert_same_host=assert_same_host,
                timeout=timeout,
                pool_timeout=pool_timeout,
                release_conn=release_conn,
                chunked=chunked,
                body_pos=body_pos,
                **response_kw
            )
    
        # Check if we should retry the HTTP response.
        has_retry_after = bool(response.getheader(&#34;Retry-After&#34;))
        if retries.is_retry(method, response.status, has_retry_after):
            try:
&gt;               retries = retries.increment(method, url, response=response, _pool=self)

/usr/local/lib/python3.8/site-packages/urllib3/connectionpool.py:868: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Retry(total=0, connect=None, read=None, redirect=None, status=None)
method = &#39;GET&#39;
url = &#34;/api1/x3/erp/QAL/AOBJEXT(&#39;WYXOHTERM&#39;)?representation=AOBJEXT.%24details&#34;
response = &lt;urllib3.response.HTTPResponse object at 0x7f34bbb16f10&gt;
error = None
_pool = &lt;urllib3.connectionpool.HTTPSConnectionPool object at 0x7f34c0383430&gt;
_stacktrace = None

    def increment(
        self,
        method=None,
        url=None,
        response=None,
        error=None,
        _pool=None,
        _stacktrace=None,
    ):
        &#34;&#34;&#34;Return a new Retry object with incremented retry counters.
    
        :param response: A response object, or None, if the server did not
            return a response.
        :type response: :class:`~urllib3.response.HTTPResponse`
        :param Exception error: An error encountered during the request, or
            None if the response was received successfully.
    
        :return: A new ``Retry`` object.
        &#34;&#34;&#34;
        if self.total is False and error:
            # Disabled, indicate to re-raise the error.
            raise six.reraise(type(error), error, _stacktrace)
    
        total = self.total
        if total is not None:
            total -= 1
    
        connect = self.connect
        read = self.read
        redirect = self.redirect
        status_count = self.status
        other = self.other
        cause = &#34;unknown&#34;
        status = None
        redirect_location = None
    
        if error and self._is_connection_error(error):
            # Connect retry?
            if connect is False:
                raise six.reraise(type(error), error, _stacktrace)
            elif connect is not None:
                connect -= 1
    
        elif error and self._is_read_error(error):
            # Read retry?
            if read is False or not self._is_method_retryable(method):
                raise six.reraise(type(error), error, _stacktrace)
            elif read is not None:
                read -= 1
    
        elif error:
            # Other retry?
            if other is not None:
                other -= 1
    
        elif response and response.get_redirect_location():
            # Redirect retry?
            if redirect is not None:
                redirect -= 1
            cause = &#34;too many redirects&#34;
            redirect_location = response.get_redirect_location()
            status = response.status
    
        else:
            # Incrementing because of a server error like a 500 in
            # status_forcelist and the given method is in the allowed_methods
            cause = ResponseError.GENERIC_ERROR
            if response and response.status:
                if status_count is not None:
                    status_count -= 1
                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)
                status = response.status
    
        history = self.history + (
            RequestHistory(method, url, error, status, redirect_location),
        )
    
        new_retry = self.new(
            total=total,
            connect=connect,
            read=read,
            redirect=redirect,
            status=status_count,
            other=other,
            history=history,
        )
    
        if new_retry.is_exhausted():
&gt;           raise MaxRetryError(_pool, url, error or ResponseError(cause))
E           urllib3.exceptions.MaxRetryError: HTTPSConnectionPool(host=&#39;sagex3-horsprod.covage.com&#39;, port=443): Max retries exceeded with url: /api1/x3/erp/QAL/AOBJEXT(&#39;WYXOHTERM&#39;)?representation=AOBJEXT.%24details (Caused by ResponseError(&#39;too many 502 error responses&#39;))

/usr/local/lib/python3.8/site-packages/urllib3/util/retry.py:592: MaxRetryError

During handling of the above exception, another exception occurred:

folder = &#39;QAL&#39;

    @pytest.mark.livetest
    @pytest.mark.xfail
    @pytest.mark.parametrize(&#34;folder&#34;, [os.environ[&#34;LIVE_TEST_X3_FOLDER&#34;]])
    def test_validate_schema_WYXOHTERM(folder):
        &#34;&#34;&#34;
        Compare diff for `WYXOHUPGRA` model between local snapshot and os.environ[&#34;LIVE_TEST_X3_FOLDER&#34;]\n
        WYXOHTERM: Resilier options contract
        &#34;&#34;&#34;
&gt;       destination = get_model_schema_from_x3(&#34;WYXOHTERM&#34;, folder=folder)

app/api/live_tests/test_validate_import_schema.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
app/api/live_tests/test_validate_import_schema.py:31: in get_model_schema_from_x3
    resp = client.get(class_name=&#34;AOBJEXT&#34;, representation=&#34;AOBJEXT&#34;, ref=model_name)
app/x3_wrapper/rest_client.py:109: in get
    resp = self._cal_x3(&#34;GET&#34;, url, query_params)
app/x3_wrapper/rest_client.py:70: in _cal_x3
    resp = self.client.request(method, url, params=query_params)
/usr/local/lib/python3.8/site-packages/requests/sessions.py:587: in request
    resp = self.send(prep, **send_kwargs)
/usr/local/lib/python3.8/site-packages/requests/sessions.py:701: in send
    r = adapter.send(request, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;requests.adapters.HTTPAdapter object at 0x7f34c0383b50&gt;
request = &lt;PreparedRequest [GET]&gt;, stream = False
timeout = Timeout(connect=None, read=None, total=None), verify = True
cert = None
proxies = OrderedDict([(&#39;no&#39;, &#39;gitlab-runner-cache-01-prd.nut.covage.com&#39;), (&#39;http&#39;, &#39;http://squid.kosc.net:3128&#39;), (&#39;https&#39;, &#39;http://squid.kosc.net:3128&#39;)])

    def send(
        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None
    ):
        &#34;&#34;&#34;Sends PreparedRequest object. Returns Response object.
    
        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.
        :param stream: (optional) Whether to stream the request content.
        :param timeout: (optional) How long to wait for the server to send
            data before giving up, as a float, or a :ref:`(connect timeout,
            read timeout) &lt;timeouts&gt;` tuple.
        :type timeout: float or tuple or urllib3 Timeout object
        :param verify: (optional) Either a boolean, in which case it controls whether
            we verify the server&#39;s TLS certificate, or a string, in which case it
            must be a path to a CA bundle to use
        :param cert: (optional) Any user-provided SSL certificate to be trusted.
        :param proxies: (optional) The proxies dictionary to apply to the request.
        :rtype: requests.Response
        &#34;&#34;&#34;
    
        try:
            conn = self.get_connection(request.url, proxies)
        except LocationValueError as e:
            raise InvalidURL(e, request=request)
    
        self.cert_verify(conn, request.url, verify, cert)
        url = self.request_url(request, proxies)
        self.add_headers(
            request,
            stream=stream,
            timeout=timeout,
            verify=verify,
            cert=cert,
            proxies=proxies,
        )
    
        chunked = not (request.body is None or &#34;Content-Length&#34; in request.headers)
    
        if isinstance(timeout, tuple):
            try:
                connect, read = timeout
                timeout = TimeoutSauce(connect=connect, read=read)
            except ValueError:
                raise ValueError(
                    f&#34;Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, &#34;
                    f&#34;or a single float to set both timeouts to the same value.&#34;
                )
        elif isinstance(timeout, TimeoutSauce):
            pass
        else:
            timeout = TimeoutSauce(connect=timeout, read=timeout)
    
        try:
            if not chunked:
                resp = conn.urlopen(
                    method=request.method,
                    url=url,
                    body=request.body,
                    headers=request.headers,
                    redirect=False,
                    assert_same_host=False,
                    preload_content=False,
                    decode_content=False,
                    retries=self.max_retries,
                    timeout=timeout,
                )
    
            # Send the request.
            else:
                if hasattr(conn, &#34;proxy_pool&#34;):
                    conn = conn.proxy_pool
    
                low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)
    
                try:
                    skip_host = &#34;Host&#34; in request.headers
                    low_conn.putrequest(
                        request.method,
                        url,
                        skip_accept_encoding=True,
                        skip_host=skip_host,
                    )
    
                    for header, value in request.headers.items():
                        low_conn.putheader(header, value)
    
                    low_conn.endheaders()
    
                    for i in request.body:
                        low_conn.send(hex(len(i))[2:].encode(&#34;utf-8&#34;))
                        low_conn.send(b&#34;\r\n&#34;)
                        low_conn.send(i)
                        low_conn.send(b&#34;\r\n&#34;)
                    low_conn.send(b&#34;0\r\n\r\n&#34;)
    
                    # Receive the response from the server
                    r = low_conn.getresponse()
    
                    resp = HTTPResponse.from_httplib(
                        r,
                        pool=conn,
                        connection=low_conn,
                        preload_content=False,
                        decode_content=False,
                    )
                except Exception:
                    # If we hit any problems here, clean up the connection.
                    # Then, raise so that we can handle the actual exception.
                    low_conn.close()
                    raise
    
        except (ProtocolError, OSError) as err:
            raise ConnectionError(err, request=request)
    
        except MaxRetryError as e:
            if isinstance(e.reason, ConnectTimeoutError):
                # TODO: Remove this in 3.0.0: see #2811
                if not isinstance(e.reason, NewConnectionError):
                    raise ConnectTimeout(e, request=request)
    
            if isinstance(e.reason, ResponseError):
&gt;               raise RetryError(e, request=request)
E               requests.exceptions.RetryError: HTTPSConnectionPool(host=&#39;sagex3-horsprod.covage.com&#39;, port=443): Max retries exceeded with url: /api1/x3/erp/QAL/AOBJEXT(&#39;WYXOHTERM&#39;)?representation=AOBJEXT.%24details (Caused by ResponseError(&#39;too many 502 error responses&#39;))

/usr/local/lib/python3.8/site-packages/requests/adapters.py:556: RetryError</pre> </div> </div> </details> <details class="phase teardown "> <summary> <h4 class=title> <span class=phase-name>Teardown</span> </h4> </summary> <div class=content> </div> </details> </div> </div> </details> </div> </details> <details class=file> <summary> <h2 class="title file-title"> <span class=fspath> app/api/tests/test_add_contract_serializer.py </span> <span class=counts> <span title="13 passed" class="count status badge passed ">13</span> </span> <span class=duration> 0:00:00.785316 </span> </h2> </summary> <div class="content box"> <details class="test passed"> <summary> <h3 class="title test-title"> <span class="status badge passed ">PASSED</span> <span class=test-name> <span class=funcname>AddContractSerializerTest::test_components_ok_1</span> </span> <span class=duration>0:00:00.432587</span> </h3> </summary> <div class=content> <table class=metadata> <tr> <th>Started</th> <td>2023-06-30 01:14:20</td> </tr> <tr> <th>Ended</th> <td>2023-06-30 01:14:21</td> </tr> <tr> <th>Duration</th> <td>0:00:00.432587</td> </tr> <tr> <th>Markers</th> <td> <div class=marker> <span class="marker-name badge">unit_test</span> <span class=marker-args> </span> </div> <div class=marker> <span class="marker-name badge">vcr</span> <span class=marker-args> </span> </div> </td> </tr> <tr> <th>Fixtures</th> <td> <span class="badge fixturename"> django_test_environment </span> <span class="badge fixturename"> django_db_blocker </span> <span class="badge fixturename"> vcr </span> <span class="badge fixturename"> vcr_config </span> <span class="badge fixturename"> vcr_cassette_dir </span> <span class="badge fixturename"> prepare_fixture </span> <span class="badge fixturename"> request </span> <span class="badge fixturename"> vcr_cassette </span> <span class="badge fixturename"> vcr_cassette_name </span> </td> </tr> </table> <div class=test-phases> <details class="phase setup "> <summary> <h4 class=title> <span class=phase-name>Setup</span> </h4> </summary> <div class=content> </div> </details> <details class="phase call passed" open> <summary> <h4 class=title> <span class="status  passed"></span> <span class=phase-name>Call</span> </h4> </summary> <div class=content> </div> </details> <details class="phase teardown "> <summary> <h4 class=title> <span class=phase-name>Teardown</span> </h4> </summary> <div class=content> </div> </details> </div> </div> </details> <details class="test passed"> <summary> <h3 class="title test-title"> <span class="status badge passed ">PASSED</span> <span class=test-name> <span class=funcname>AddContractSerializerTest::test_components_ok_2</span> </span> <span class=duration>0:00:00.021625</span> </h3> </summary> <div class=content> <table class=metadata> <tr> <th>Started</th> <td>2023-06-30 01:14:21</td> </tr> <tr> <th>Ended</th> <td>2023-06-30 01:14:21</td> </tr> <tr> <th>Duration</th> <td>0:00:00.021625</td> </tr> <tr> <th>Markers</th> <td> <div class=marker> <span class="marker-name badge">unit_test</span> <span class=marker-args> </span> </div> <div class=marker> <span class="marker-name badge">vcr</span> <span class=marker-args> </span> </div> </td> </tr> <tr> <th>Fixtures</th> <td> <span class="badge fixturename"> django_test_environment </span> <span class="badge fixturename"> django_db_blocker </span> <span class="badge fixturename"> vcr </span> <span class="badge fixturename"> vcr_config </span> <span class="badge fixturename"> vcr_cassette_dir </span> <span class="badge fixturename"> prepare_fixture </span> <span class="badge fixturename"> request </span> <span class="badge fixturename"> vcr_cassette </span> <span class="badge fixturename"> vcr_cassette_name </span> </td> </tr> </table> <div class=test-phases> <details class="phase setup "> <summary> <h4 class=title> <span class=phase-name>Setup</span> </h4> </summary> <div class=content> </div> </details> <details class="phase call passed" open> <summary> <h4 class=title> <span class="status  passed"></span> <span class=phase-name>Call</span> </h4> </summary> <div class=content> </div> </details> <details class="phase teardown "> <summary> <h4 class=title> <span class=phase-name>Teardown</span> </h4> </summary> <div class=content> </div> </details> </div> </div> </details> <details class="test passed"> <summary> <h3 class="title test-title"> <span class="status badge passed ">PASSED</span> <span class=test-name> <span class=funcname>AddContractSerializerTest::test_components_ok_3</span> </span> <span class=duration>0:00:00.021514</span> </h3> </summary> <div class=content> <table class=metadata> <tr> <th>Started</th> <td>2023-06-30 01:14:21</td> </tr> <tr> <th>Ended</th> <td>2023-06-30 01:14:21</td> </tr> <tr> <th>Duration</th> <td>0:00:00.021514</td> </tr> <tr> <th>Markers</th> <td> <div class=marker> <span class="marker-name badge">unit_test</span> <span class=marker-args> </span> </div> <div class=marker> <span class="marker-name badge">vcr</span> <span class=marker-args> </span> </div> </td> </tr> <tr> <th>Fixtures</th> <td> <span class="badge fixturename"> django_test_environment </span> <span class="badge fixturename"> django_db_blocker </span> <span class="badge fixturename"> vcr </span> <span class="badge fixturename"> vcr_config </span> <span class="badge fixturename"> vcr_cassette_dir </span> <span class="badge fixturename"> prepare_fixture </span> <span class="badge fixturename"> request </span> <span class="badge fixturename"> vcr_cassette </span> <span class="badge fixturename"> vcr_cassette_name </span> </td> </tr> </table> <div class=test-phases> <details class="phase setup "> <summary> <h4 class=title> <span class=phase-name>Setup</span> </h4> </summary> <div class=content> </div> </details> <details class="phase call passed" open> <summary> <h4 class=title> <span class="status  passed"></span> <span class=phase-name>Call</span> </h4> </summary> <div class=content> </div> </details> <details class="phase teardown "> <summary> <h4 class=title> <span class=phase-name>Teardown</span> </h4> </summary> <div class=content> </div> </details> </div> </div> </details> <details class="test passed"> <summary> <h3 class="title test-title"> <span class="status badge passed ">PASSED</span> <span class=test-name> <span class=funcname>AddContractSerializerTest::test_components_ok_4</span> </span> <span class=duration>0:00:00.021301</span> </h3> </summary> <div class=content> <table class=metadata> <tr> <th>Started</th> <td>2023-06-30 01:14:21</td> </tr> <tr> <th>Ended</th> <td>2023-06-30 01:14:21</td> </tr> <tr> <th>Duration</th> <td>0:00:00.021301</td> </tr> <tr> <th>Markers</th> <td> <div class=marker> <span class="marker-name badge">unit_test</span> <span class=marker-args> </span> </div> <div class=marker> <span class="marker-name badge">vcr</span> <span class=marker-args> </span> </div> </td> </tr> <tr> <th>Fixtures</th> <td> <span class="badge fixturename"> django_test_environment </span> <span class="badge fixturename"> django_db_blocker </span> <span class="badge fixturename"> vcr </span> <span class="badge fixturename"> vcr_config </span> <span class="badge fixturename"> vcr_cassette_dir </span> <span class="badge fixturename"> prepare_fixture </span> <span class="badge fixturename"> request </span> <span class="badge fixturename"> vcr_cassette </span> <span class="badge fixturename"> vcr_cassette_name </span> </td> </tr> </table> <div class=test-phases> <details class="phase setup "> <summary> <h4 class=title> <span class=phase-name>Setup</span> </h4> </summary> <div class=content> </div> </details> <details class="phase call passed" open> <summary> <h4 class=title> <span class="status  passed"></span> <span class=phase-name>Call</span> </h4> </summary> <div class=content> </div> </details> <details class="phase teardown "> <summary> <h4 class=title> <span class=phase-name>Teardown</span> </h4> </summary> <div class=content> </div> </details> </div> </div> </details> <details class="test passed"> <summary> <h3 class="title test-title"> <span class="status badge passed ">PASSED</span> <span class=test-name> <span class=funcname>AddContractSerializerTest::test_components_with_missing_variant</span> </span> <span class=duration>0:00:00.021661</span> </h3> </summary> <div class=content> <table class=metadata> <tr> <th>Started</th> <td>2023-06-30 01:14:21</td> </tr> <tr> <th>Ended</th> <td>2023-06-30 01:14:21</td> </tr> <tr> <th>Duration</th> <td>0:00:00.021661</td> </tr> <tr> <th>Markers</th> <td> <div class=marker> <span class="marker-name badge">unit_test</span> <span class=marker-args> </span> </div> <div class=marker> <span class="marker-name badge">vcr</span> <span class=marker-args> </span> </div> </td> </tr> <tr> <th>Fixtures</th> <td> <span class="badge fixturename"> django_test_environment </span> <span class="badge fixturename"> django_db_blocker </span> <span class="badge fixturename"> vcr </span> <span class="badge fixturename"> vcr_config </span> <span class="badge fixturename"> vcr_cassette_dir </span> <span class="badge fixturename"> prepare_fixture </span> <span class="badge fixturename"> request </span> <span class="badge fixturename"> vcr_cassette </span> <span class="badge fixturename"> vcr_cassette_name </span> </td> </tr> </table> <div class=test-phases> <details class="phase setup "> <summary> <h4 class=title> <span class=phase-name>Setup</span> </h4> </summary> <div class=content> </div> </details> <details class="phase call passed" open> <summary> <h4 class=title> <span class="status  passed"></span> <span class=phase-name>Call</span> </h4> </summary> <div class=content> </div> </details> <details class="phase teardown "> <summary> <h4 class=title> <span class=phase-name>Teardown</span> </h4> </summary> <div class=content> </div> </details> </div> </div> </details> <details class="test passed"> <summary> <h3 class="title test-title"> <span class="status badge passed ">PASSED</span> <span class=test-name> <span class=funcname>AddContractSerializerTest::test_components_with_multiple_option_or_variants</span> </span> <span class=duration>0:00:00.036745</span> </h3> </summary> <div class=content> <table class=metadata> <tr> <th>Started</th> <td>2023-06-30 01:14:21</td> </tr> <tr> <th>Ended</th> <td>2023-06-30 01:14:21</td> </tr> <tr> <th>Duration</th> <td>0:00:00.036745</td> </tr> <tr> <th>Markers</th> <td> <div class=marker> <span class="marker-name badge">unit_test</span> <span class=marker-args> </span> </div> <div class=marker> <span class="marker-name badge">vcr</span> <span class=marker-args> </span> </div> </td> </tr> <tr> <th>Fixtures</th> <td> <span class="badge fixturename"> django_test_environment </span> <span class="badge fixturename"> django_db_blocker </span> <span class="badge fixturename"> vcr </span> <span class="badge fixturename"> vcr_config </span> <span class="badge fixturename"> vcr_cassette_dir </span> <span class="badge fixturename"> prepare_fixture </span> <span class="badge fixturename"> request </span> <span class="badge fixturename"> vcr_cassette </span> <span class="badge fixturename"> vcr_cassette_name </span> </td> </tr> </table> <div class=test-phases> <details class="phase setup "> <summary> <h4 class=title> <span class=phase-name>Setup</span> </h4> </summary> <div class=content> </div> </details> <details class="phase call passed" open> <summary> <h4 class=title> <span class="status  passed"></span> <span class=phase-name>Call</span> </h4> </summary> <div class=content> </div> </details> <details class="phase teardown "> <summary> <h4 class=title> <span class=phase-name>Teardown</span> </h4> </summary> <div class=content> </div> </details> </div> </div> </details> <details class="test passed"> <summary> <h3 class="title test-title"> <span class="status badge passed ">PASSED</span> <span class=test-name> <span class=funcname>AddContractSerializerTest::test_components_with_not_found_reference</span> </span> <span class=duration>0:00:00.037540</span> </h3> </summary> <div class=content> <table class=metadata> <tr> <th>Started</th> <td>2023-06-30 01:14:21</td> </tr> <tr> <th>Ended</th> <td>2023-06-30 01:14:21</td> </tr> <tr> <th>Duration</th> <td>0:00:00.037540</td> </tr> <tr> <th>Markers</th> <td> <div class=marker> <span class="marker-name badge">unit_test</span> <span class=marker-args> </span> </div> <div class=marker> <span class="marker-name badge">vcr</span> <span class=marker-args> </span> </div> </td> </tr> <tr> <th>Fixtures</th> <td> <span class="badge fixturename"> django_test_environment </span> <span class="badge fixturename"> django_db_blocker </span> <span class="badge fixturename"> vcr </span> <span class="badge fixturename"> vcr_config </span> <span class="badge fixturename"> vcr_cassette_dir </span> <span class="badge fixturename"> prepare_fixture </span> <span class="badge fixturename"> request </span> <span class="badge fixturename"> vcr_cassette </span> <span class="badge fixturename"> vcr_cassette_name </span> </td> </tr> </table> <div class=test-phases> <details class="phase setup "> <summary> <h4 class=title> <span class=phase-name>Setup</span> </h4> </summary> <div class=content> </div> </details> <details class="phase call passed" open> <summary> <h4 class=title> <span class="status  passed"></span> <span class=phase-name>Call</span> </h4> </summary> <div class=content> </div> </details> <details class="phase teardown "> <summary> <h4 class=title> <span class=phase-name>Teardown</span> </h4> </summary> <div class=content> </div> </details> </div> </div> </details> <details class="test passed"> <summary> <h3 class="title test-title"> <span class="status badge passed ">PASSED</span> <span class=test-name> <span class=funcname>AddContractSerializerTest::test_contract_serializer_date_validation</span> </span> <span class=duration>0:00:00.021087</span> </h3> </summary> <div class=content> <table class=metadata> <tr> <th>Started</th> <td>2023-06-30 01:14:21</td> </tr> <tr> <th>Ended</th> <td>2023-06-30 01:14:21</td> </tr> <tr> <th>Duration</th> <td>0:00:00.021087</td> </tr> <tr> <th>Markers</th> <td> <div class=marker> <span class="marker-name badge">unit_test</span> <span class=marker-args> </span> </div> <div class=marker> <span class="marker-name badge">vcr</span> <span class=marker-args> </span> </div> </td> </tr> <tr> <th>Fixtures</th> <td> <span class="badge fixturename"> django_test_environment </span> <span class="badge fixturename"> django_db_blocker </span> <span class="badge fixturename"> vcr </span> <span class="badge fixturename"> vcr_config </span> <span class="badge fixturename"> vcr_cassette_dir </span> <span class="badge fixturename"> prepare_fixture </span> <span class="badge fixturename"> request </span> <span class="badge fixturename"> vcr_cassette </span> <span class="badge fixturename"> vcr_cassette_name </span> </td> </tr> </table> <div class=test-phases> <details class="phase setup "> <summary> <h4 class=title> <span class=phase-name>Setup</span> </h4> </summary> <div class=content> </div> </details> <details class="phase call passed" open> <summary> <h4 class=title> <span class="status  passed"></span> <span class=phase-name>Call</span> </h4> </summary> <div class=content> </div> </details> <details class="phase teardown "> <summary> <h4 class=title> <span class=phase-name>Teardown</span> </h4> </summary> <div class=content> </div> </details> </div> </div> </details> <details class="test passed"> <summary> <h3 class="title test-title"> <span class="status badge passed ">PASSED</span> <span class=test-name> <span class=funcname>AddContractSerializerTest::test_contract_serializer_fields_order</span> </span> <span class=duration>0:00:00.036623</span> </h3> </summary> <div class=content> <table class=metadata> <tr> <th>Started</th> <td>2023-06-30 01:14:21</td> </tr> <tr> <th>Ended</th> <td>2023-06-30 01:14:21</td> </tr> <tr> <th>Duration</th> <td>0:00:00.036623</td> </tr> <tr> <th>Markers</th> <td> <div class=marker> <span class="marker-name badge">unit_test</span> <span class=marker-args> </span> </div> <div class=marker> <span class="marker-name badge">vcr</span> <span class=marker-args> </span> </div> </td> </tr> <tr> <th>Fixtures</th> <td> <span class="badge fixturename"> django_test_environment </span> <span class="badge fixturename"> django_db_blocker </span> <span class="badge fixturename"> vcr </span> <span class="badge fixturename"> vcr_config </span> <span class="badge fixturename"> vcr_cassette_dir </span> <span class="badge fixturename"> prepare_fixture </span> <span class="badge fixturename"> request </span> <span class="badge fixturename"> vcr_cassette </span> <span class="badge fixturename"> vcr_cassette_name </span> </td> </tr> </table> <div class=test-phases> <details class="phase setup "> <summary> <h4 class=title> <span class=phase-name>Setup</span> </h4> </summary> <div class=content> </div> </details> <details class="phase call passed" open> <summary> <h4 class=title> <span class="status  passed"></span> <span class=phase-name>Call</span> </h4> </summary> <div class=content> </div> </details> <details class="phase teardown "> <summary> <h4 class=title> <span class=phase-name>Teardown</span> </h4> </summary> <div class=content> </div> </details> </div> </div> </details> <details class="test passed"> <summary> <h3 class="title test-title"> <span class="status badge passed ">PASSED</span> <span class=test-name> <span class=funcname>AddContractSerializerTest::test_contract_serializer_to_plain_text</span> </span> <span class=duration>0:00:00.021075</span> </h3> </summary> <div class=content> <table class=metadata> <tr> <th>Started</th> <td>2023-06-30 01:14:21</td> </tr> <tr> <th>Ended</th> <td>2023-06-30 01:14:21</td> </tr> <tr> <th>Duration</th> <td>0:00:00.021075</td> </tr> <tr> <th>Markers</th> <td> <div class=marker> <span class="marker-name badge">unit_test</span> <span class=marker-args> </span> </div> <div class=marker> <span class="marker-name badge">vcr</span> <span class=marker-args> </span> </div> </td> </tr> <tr> <th>Fixtures</th> <td> <span class="badge fixturename"> django_test_environment </span> <span class="badge fixturename"> django_db_blocker </span> <span class="badge fixturename"> vcr </span> <span class="badge fixturename"> vcr_config </span> <span class="badge fixturename"> vcr_cassette_dir </span> <span class="badge fixturename"> prepare_fixture </span> <span class="badge fixturename"> request </span> <span class="badge fixturename"> vcr_cassette </span> <span class="badge fixturename"> vcr_cassette_name </span> </td> </tr> </table> <div class=test-phases> <details class="phase setup "> <summary> <h4 class=title> <span class=phase-name>Setup</span> </h4> </summary> <div class=content> </div> </details> <details class="phase call passed" open> <summary> <h4 class=title> <span class="status  passed"></span> <span class=phase-name>Call</span> </h4> </summary> <div class=content> </div> </details> <details class="phase teardown "> <summary> <h4 class=title> <span class=phase-name>Teardown</span> </h4> </summary> <div class=content> </div> </details> </div> </div> </details> <details class="test passed"> <summary> <h3 class="title test-title"> <span class="status badge passed ">PASSED</span> <span class=test-name> <span class=funcname>AddContractSerializerTest::test_ref_service_and_mes_date</span> </span> <span class=duration>0:00:00.057787</span> </h3> </summary> <div class=content> <table class=metadata> <tr> <th>Started</th> <td>2023-06-30 01:14:21</td> </tr> <tr> <th>Ended</th> <td>2023-06-30 01:14:21</td> </tr> <tr> <th>Duration</th> <td>0:00:00.057787</td> </tr> <tr> <th>Markers</th> <td> <div class=marker> <span class="marker-name badge">unit_test</span> <span class=marker-args> </span> </div> <div class=marker> <span class="marker-name badge">vcr</span> <span class=marker-args> </span> </div> </td> </tr> <tr> <th>Fixtures</th> <td> <span class="badge fixturename"> django_test_environment </span> <span class="badge fixturename"> django_db_blocker </span> <span class="badge fixturename"> vcr </span> <span class="badge fixturename"> vcr_config </span> <span class="badge fixturename"> vcr_cassette_dir </span> <span class="badge fixturename"> prepare_fixture </span> <span class="badge fixturename"> request </span> <span class="badge fixturename"> vcr_cassette </span> <span class="badge fixturename"> vcr_cassette_name </span> </td> </tr> </table> <div class=test-phases> <details class="phase setup "> <summary> <h4 class=title> <span class=phase-name>Setup</span> </h4> </summary> <div class=content> </div> </details> <details class="phase call passed" open> <summary> <h4 class=title> <span class="status  passed"></span> <span class=phase-name>Call</span> </h4> </summary> <div class=content> </div> </details> <details class="phase teardown "> <summary> <h4 class=title> <span class=phase-name>Teardown</span> </h4> </summary> <div class=content> </div> </details> </div> </div> </details> <details class="test passed"> <summary> <h3 class="title test-title"> <span class="status badge passed ">PASSED</span> <span class=test-name> <span class=funcname>AddContractSerializerNotFoundTest::test_parent_item_with_wrong_reference</span> </span> <span class=duration>0:00:00.021709</span> </h3> </summary> <div class=content> <table class=metadata> <tr> <th>Started</th> <td>2023-06-30 01:14:21</td> </tr> <tr> <th>Ended</th> <td>2023-06-30 01:14:21</td> </tr> <tr> <th>Duration</th> <td>0:00:00.021709</td> </tr> <tr> <th>Markers</th> <td> <div class=marker> <span class="marker-name badge">vcr</span> <span class=marker-args> </span> </div> </td> </tr> <tr> <th>Fixtures</th> <td> <span class="badge fixturename"> django_test_environment </span> <span class="badge fixturename"> django_db_blocker </span> <span class="badge fixturename"> request </span> </td> </tr> </table> <div class=test-phases> <details class="phase setup "> <summary> <h4 class=title> <span class=phase-name>Setup</span> </h4> </summary> <div class=content> </div> </details> <details class="phase call passed" open> <summary> <h4 class=title> <span class="status  passed"></span> <span class=phase-name>Call</span> </h4> </summary> <div class=content> </div> </details> <details class="phase teardown "> <summary> <h4 class=title> <span class=phase-name>Teardown</span> </h4> </summary> <div class=content> </div> </details> </div> </div> </details> <details class="test passed"> <summary> <h3 class="title test-title"> <span class="status badge passed ">PASSED</span> <span class=test-name> <span class=funcname>AddContractSerializerNotFoundTest::test_update_contract</span> </span> <span class=duration>0:00:00.034061</span> </h3> </summary> <div class=content> <table class=metadata> <tr> <th>Started</th> <td>2023-06-30 01:14:21</td> </tr> <tr> <th>Ended</th> <td>2023-06-30 01:14:21</td> </tr> <tr> <th>Duration</th> <td>0:00:00.034061</td> </tr> <tr> <th>Markers</th> <td> <div class=marker> <span class="marker-name badge">vcr</span> <span class=marker-args> </span> </div> </td> </tr> <tr> <th>Fixtures</th> <td> <span class="badge fixturename"> django_test_environment </span> <span class="badge fixturename"> django_db_blocker </span> <span class="badge fixturename"> request </span> </td> </tr> </table> <div class=test-phases> <details class="phase setup "> <summary> <h4 class=title> <span class=phase-name>Setup</span> </h4> </summary> <div class=content> </div> </details> <details class="phase call passed" open> <summary> <h4 class=title> <span class="status  passed"></span> <span class=phase-name>Call</span> </h4> </summary> <div class=content> </div> </details> <details class="phase teardown "> <summary> <h4 class=title> <span class=phase-name>Teardown</span> </h4> </summary> <div class=content> </div> </details> </div> </div> </details> </div> </details> <details class=file> <summary> <h2 class="title file-title"> <span class=fspath> app/api/tests/test_app_config.py </span> <span class=counts> <span title="1 passed" class="count status badge passed ">1</span> </span> <span class=duration> 0:00:00.002229 </span> </h2> </summary> <div class="content box"> <details class="test passed"> <summary> <h3 class="title test-title"> <span class="status badge passed ">PASSED</span> <span class=test-name> <span class=funcname>ApiConfigTest::test_apps</span> </span> <span class=duration>0:00:00.002229</span> </h3> </summary> <div class=content> <table class=metadata> <tr> <th>Started</th> <td>2023-06-30 01:14:21</td> </tr> <tr> <th>Ended</th> <td>2023-06-30 01:14:21</td> </tr> <tr> <th>Duration</th> <td>0:00:00.002229</td> </tr> <tr> <th>Markers</th> <td> <div class=marker> <span class="marker-name badge">unit_test</span> <span class=marker-args> </span> </div> </td> </tr> <tr> <th>Fixtures</th> <td> <span class="badge fixturename"> django_test_environment </span> <span class="badge fixturename"> django_db_blocker </span> <span class="badge fixturename"> request </span> </td> </tr> </table> <div class=test-phases> <details class="phase setup "> <summary> <h4 class=title> <span class=phase-name>Setup</span> </h4> </summary> <div class=content> </div> </details> <details class="phase call passed" open> <summary> <h4 class=title> <span class="status  passed"></span> <span class=phase-name>Call</span> </h4> </summary> <div class=content> </div> </details> <details class="phase teardown "> <summary> <h4 class=title> <span class=phase-name>Teardown</span> </h4> </summary> <div class=content> </div> </details> </div> </div> </details> </div> </details> <details class=file> <summary> <h2 class="title file-title"> <span class=fspath> app/api/tests/test_authenficiation.py </span> <span class=counts> <span title="4 passed" class="count status badge passed ">4</span> </span> <span class=duration> 0:00:00.506887 </span> </h2> </summary> <div class="content box"> <details class="test passed"> <summary> <h3 class="title test-title"> <span class="status badge passed ">PASSED</span> <span class=test-name> <span class=funcname>AuthentificationTest::test_auth_user_with_right_perms</span> </span> <span class=duration>0:00:00.050964</span> </h3> </summary> <div class=content> <table class=metadata> <tr> <th>Started</th> <td>2023-06-30 01:14:23</td> </tr> <tr> <th>Ended</th> <td>2023-06-30 01:14:23</td> </tr> <tr> <th>Duration</th> <td>0:00:00.050964</td> </tr> <tr> <th>Markers</th> <td> <div class=marker> <span class="marker-name badge">unit_test</span> <span class=marker-args> </span> </div> </td> </tr> <tr> <th>Fixtures</th> <td> <span class="badge fixturename"> django_test_environment </span> <span class="badge fixturename"> django_db_blocker </span> <span class="badge fixturename"> request </span> </td> </tr> </table> <div class=test-phases> <details class="phase setup "> <summary> <h4 class=title> <span class=phase-name>Setup</span> </h4> </summary> <div class=content> </div> </details> <details class="phase call passed" open> <summary> <h4 class=title> <span class="status  passed"></span> <span class=phase-name>Call</span> </h4> </summary> <div class=content> </div> </details> <details class="phase teardown "> <summary> <h4 class=title> <span class=phase-name>Teardown</span> </h4> </summary> <div class=content> </div> </details> </div> </div> </details> <details class="test passed"> <summary> <h3 class="title test-title"> <span class="status badge passed ">PASSED</span> <span class=test-name> <span class=funcname>AuthentificationTest::test_with_bad_token</span> </span> <span class=duration>0:00:00.042821</span> </h3> </summary> <div class=content> <table class=metadata> <tr> <th>Started</th> <td>2023-06-30 01:14:23</td> </tr> <tr> <th>Ended</th> <td>2023-06-30 01:14:23</td> </tr> <tr> <th>Duration</th> <td>0:00:00.042821</td> </tr> <tr> <th>Markers</th> <td> <div class=marker> <span class="marker-name badge">unit_test</span> <span class=marker-args> </span> </div> </td> </tr> <tr> <th>Fixtures</th> <td> <span class="badge fixturename"> django_test_environment </span> <span class="badge fixturename"> django_db_blocker </span> <span class="badge fixturename"> request </span> </td> </tr> </table> <div class=test-phases> <details class="phase setup "> <summary> <h4 class=title> <span class=phase-name>Setup</span> </h4> </summary> <div class=content> </div> </details> <details class="phase call passed" open> <summary> <h4 class=title> <span class="status  passed"></span> <span class=phase-name>Call</span> </h4> </summary> <div class=content> <div class=section> <h5 class=section-title>Captured log call</h5> <pre><samp>WARNING  django.request:log.py:241 Unauthorized: /mock-auth/</samp></pre> </div> </div> </details> <details class="phase teardown "> <summary> <h4 class=title> <span class=phase-name>Teardown</span> </h4> </summary> <div class=content> </div> </details> </div> </div> </details> <details class="test passed"> <summary> <h3 class="title test-title"> <span class="status badge passed ">PASSED</span> <span class=test-name> <span class=funcname>AuthentificationTest::test_with_loged_user_with_missing_perms</span> </span> <span class=duration>0:00:00.044113</span> </h3> </summary> <div class=content> <table class=metadata> <tr> <th>Started</th> <td>2023-06-30 01:14:23</td> </tr> <tr> <th>Ended</th> <td>2023-06-30 01:14:23</td> </tr> <tr> <th>Duration</th> <td>0:00:00.044113</td> </tr> <tr> <th>Markers</th> <td> <div class=marker> <span class="marker-name badge">unit_test</span> <span class=marker-args> </span> </div> </td> </tr> <tr> <th>Fixtures</th> <td> <span class="badge fixturename"> django_test_environment </span> <span class="badge fixturename"> django_db_blocker </span> <span class="badge fixturename"> request </span> </td> </tr> </table> <div class=test-phases> <details class="phase setup "> <summary> <h4 class=title> <span class=phase-name>Setup</span> </h4> </summary> <div class=content> </div> </details> <details class="phase call passed" open> <summary> <h4 class=title> <span class="status  passed"></span> <span class=phase-name>Call</span> </h4> </summary> <div class=content> <div class=section> <h5 class=section-title>Captured log call</h5> <pre><samp>WARNING  django.request:log.py:241 Forbidden: /mock-auth/</samp></pre> </div> </div> </details> <details class="phase teardown "> <summary> <h4 class=title> <span class=phase-name>Teardown</span> </h4> </summary> <div class=content> </div> </details> </div> </div> </details> <details class="test passed"> <summary> <h3 class="title test-title"> <span class="status badge passed ">PASSED</span> <span class=test-name> <span class=funcname>AuthentificationTest::test_without_token</span> </span> <span class=duration>0:00:00.368989</span> </h3> </summary> <div class=content> <table class=metadata> <tr> <th>Started</th> <td>2023-06-30 01:14:23</td> </tr> <tr> <th>Ended</th> <td>2023-06-30 01:14:24</td> </tr> <tr> <th>Duration</th> <td>0:00:00.368989</td> </tr> <tr> <th>Markers</th> <td> <div class=marker> <span class="marker-name badge">unit_test</span> <span class=marker-args> </span> </div> </td> </tr> <tr> <th>Fixtures</th> <td> <span class="badge fixturename"> django_test_environment </span> <span class="badge fixturename"> django_db_blocker </span> <span class="badge fixturename"> request </span> </td> </tr> </table> <div class=test-phases> <details class="phase setup "> <summary> <h4 class=title> <span class=phase-name>Setup</span> </h4> </summary> <div class=content> </div> </details> <details class="phase call passed" open> <summary> <h4 class=title> <span class="status  passed"></span> <span class=phase-name>Call</span> </h4> </summary> <div class=content> <div class=section> <h5 class=section-title>Captured log call</h5> <pre><samp>WARNING  django.request:log.py:241 Unauthorized: /mock-auth/
WARNING  django.request:log.py:241 Unauthorized: /mock-auth/</samp></pre> </div> </div> </details> <details class="phase teardown "> <summary> <h4 class=title> <span class=phase-name>Teardown</span> </h4> </summary> <div class=content> </div> </details> </div> </div> </details> </div> </details> <details class=file> <summary> <h2 class="title file-title"> <span class=fspath> app/api/tests/test_catalog.py </span> <span class=counts> <span title="6 passed" class="count status badge passed ">6</span> </span> <span class=duration> 0:00:00.502197 </span> </h2> </summary> <div class="content box"> <details class="test passed"> <summary> <h3 class="title test-title"> <span class="status badge passed ">PASSED</span> <span class=test-name> <span class=funcname>CatalogTest::test_filter_catalogs</span> </span> <span class=duration>0:00:00.062815</span> </h3> </summary> <div class=content> <table class=metadata> <tr> <th>Started</th> <td>2023-06-30 01:14:24</td> </tr> <tr> <th>Ended</th> <td>2023-06-30 01:14:24</td> </tr> <tr> <th>Duration</th> <td>0:00:00.062815</td> </tr> <tr> <th>Markers</th> <td> <div class=marker> <span class="marker-name badge">vcr</span> <span class=marker-args> </span> </div> <div class=marker> <span class="marker-name badge">unit_test</span> <span class=marker-args> </span> </div> </td> </tr> <tr> <th>Fixtures</th> <td> <span class="badge fixturename"> django_test_environment </span> <span class="badge fixturename"> django_db_blocker </span> <span class="badge fixturename"> vcr </span> <span class="badge fixturename"> vcr_config </span> <span class="badge fixturename"> vcr_cassette_dir </span> <span class="badge fixturename"> prepare_fixture </span> <span class="badge fixturename"> request </span> <span class="badge fixturename"> vcr_cassette </span> <span class="badge fixturename"> vcr_cassette_name </span> </td> </tr> </table> <div class=test-phases> <details class="phase setup "> <summary> <h4 class=title> <span class=phase-name>Setup</span> </h4> </summary> <div class=content> </div> </details> <details class="phase call passed" open> <summary> <h4 class=title> <span class="status  passed"></span> <span class=phase-name>Call</span> </h4> </summary> <div class=content> </div> </details> <details class="phase teardown "> <summary> <h4 class=title> <span class=phase-name>Teardown</span> </h4> </summary> <div class=content> </div> </details> </div> </div> </details> <details class="test passed"> <summary> <h3 class="title test-title"> <span class="status badge passed ">PASSED</span> <span class=test-name> <span class=funcname>CatalogTest::test_get_catalogs_not_found</span> </span> <span class=duration>0:00:00.053710</span> </h3> </summary> <div class=content> <table class=metadata> <tr> <th>Started</th> <td>2023-06-30 01:14:24</td> </tr> <tr> <th>Ended</th> <td>2023-06-30 01:14:24</td> </tr> <tr> <th>Duration</th> <td>0:00:00.053710</td> </tr> <tr> <th>Markers</th> <td> <div class=marker> <span class="marker-name badge">vcr</span> <span class=marker-args> </span> </div> <div class=marker> <span class="marker-name badge">unit_test</span> <span class=marker-args> </span> </div> </td> </tr> <tr> <th>Fixtures</th> <td> <span class="badge fixturename"> django_test_environment </span> <span class="badge fixturename"> django_db_blocker </span> <span class="badge fixturename"> vcr </span> <span class="badge fixturename"> vcr_config </span> <span class="badge fixturename"> vcr_cassette_dir </span> <span class="badge fixturename"> prepare_fixture </span> <span class="badge fixturename"> request </span> <span class="badge fixturename"> vcr_cassette </span> <span class="badge fixturename"> vcr_cassette_name </span> </td> </tr> </table> <div class=test-phases> <details class="phase setup "> <summary> <h4 class=title> <span class=phase-name>Setup</span> </h4> </summary> <div class=content> </div> </details> <details class="phase call passed" open> <summary> <h4 class=title> <span class="status  passed"></span> <span class=phase-name>Call</span> </h4> </summary> <div class=content> <div class=section> <h5 class=section-title>Captured log call</h5> <pre><samp>WARNING  django.request:log.py:241 Not Found: /api/v0/catalogs/DUMMY/</samp></pre> </div> </div> </details> <details class="phase teardown "> <summary> <h4 class=title> <span class=phase-name>Teardown</span> </h4> </summary> <div class=content> </div> </details> </div> </div> </details> <details class="test passed"> <summary> <h3 class="title test-title"> <span class="status badge passed ">PASSED</span> <span class=test-name> <span class=funcname>CatalogTest::test_get_catalogs_success</span> </span> <span class=duration>0:00:00.062698</span> </h3> </summary> <div class=content> <table class=metadata> <tr> <th>Started</th> <td>2023-06-30 01:14:24</td> </tr> <tr> <th>Ended</th> <td>2023-06-30 01:14:24</td> </tr> <tr> <th>Duration</th> <td>0:00:00.062698</td> </tr> <tr> <th>Markers</th> <td> <div class=marker> <span class="marker-name badge">vcr</span> <span class=marker-args> </span> </div> <div class=marker> <span class="marker-name badge">unit_test</span> <span class=marker-args> </span> </div> </td> </tr> <tr> <th>Fixtures</th> <td> <span class="badge fixturename"> django_test_environment </span> <span class="badge fixturename"> django_db_blocker </span> <span class="badge fixturename"> vcr </span> <span class="badge fixturename"> vcr_config </span> <span class="badge fixturename"> vcr_cassette_dir </span> <span class="badge fixturename"> prepare_fixture </span> <span class="badge fixturename"> request </span> <span class="badge fixturename"> vcr_cassette </span> <span class="badge fixturename"> vcr_cassette_name </span> </td> </tr> </table> <div class=test-phases> <details class="phase setup "> <summary> <h4 class=title> <span class=phase-name>Setup</span> </h4> </summary> <div class=content> </div> </details> <details class="phase call passed" open> <summary> <h4 class=title> <span class="status  passed"></span> <span class=phase-name>Call</span> </h4> </summary> <div class=content> </div> </details> <details class="phase teardown "> <summary> <h4 class=title> <span class=phase-name>Teardown</span> </h4> </summary> <div class=content> </div> </details> </div> </div> </details> <details class="test passed"> <summary> <h3 class="title test-title"> <span class="status badge passed ">PASSED</span> <span class=test-name> <span class=funcname>CatalogTest::test_paginate_catalog</span> </span> <span class=duration>0:00:00.092202</span> </h3> </summary> <div class=content> <table class=metadata> <tr> <th>Started</th> <td>2023-06-30 01:14:24</td> </tr> <tr> <th>Ended</th> <td>2023-06-30 01:14:24</td> </tr> <tr> <th>Duration</th> <td>0:00:00.092202</td> </tr> <tr> <th>Markers</th> <td> <div class=marker> <span class="marker-name badge">vcr</span> <span class=marker-args> </span> </div> <div class=marker> <span class="marker-name badge">unit_test</span> <span class=marker-args> </span> </div> </td> </tr> <tr> <th>Fixtures</th> <td> <span class="badge fixturename"> django_test_environment </span> <span class="badge fixturename"> django_db_blocker </span> <span class="badge fixturename"> vcr </span> <span class="badge fixturename"> vcr_config </span> <span class="badge fixturename"> vcr_cassette_dir </span> <span class="badge fixturename"> prepare_fixture </span> <span class="badge fixturename"> request </span> <span class="badge fixturename"> vcr_cassette </span> <span class="badge fixturename"> vcr_cassette_name </span> </td> </tr> </table> <div class=test-phases> <details class="phase setup "> <summary> <h4 class=title> <span class=phase-name>Setup</span> </h4> </summary> <div class=content> </div> </details> <details class="phase call passed" open> <summary> <h4 class=title> <span class="status  passed"></span> <span class=phase-name>Call</span> </h4> </summary> <div class=content> </div> </details> <details class="phase teardown "> <summary> <h4 class=title> <span class=phase-name>Teardown</span> </h4> </summary> <div class=content> </div> </details> </div> </div> </details> <details class="test passed"> <summary> <h3 class="title test-title"> <span class="status badge passed ">PASSED</span> <span class=test-name> <span class=funcname>CatalogTest::test_query_catalog</span> </span> <span class=duration>0:00:00.060389</span> </h3> </summary> <div class=content> <table class=metadata> <tr> <th>Started</th> <td>2023-06-30 01:14:24</td> </tr> <tr> <th>Ended</th> <td>2023-06-30 01:14:24</td> </tr> <tr> <th>Duration</th> <td>0:00:00.060389</td> </tr> <tr> <th>Markers</th> <td> <div class=marker> <span class="marker-name badge">vcr</span> <span class=marker-args> </span> </div> <div class=marker> <span class="marker-name badge">unit_test</span> <span class=marker-args> </span> </div> </td> </tr> <tr> <th>Fixtures</th> <td> <span class="badge fixturename"> django_test_environment </span> <span class="badge fixturename"> django_db_blocker </span> <span class="badge fixturename"> vcr </span> <span class="badge fixturename"> vcr_config </span> <span class="badge fixturename"> vcr_cassette_dir </span> <span class="badge fixturename"> prepare_fixture </span> <span class="badge fixturename"> request </span> <span class="badge fixturename"> vcr_cassette </span> <span class="badge fixturename"> vcr_cassette_name </span> </td> </tr> </table> <div class=test-phases> <details class="phase setup "> <summary> <h4 class=title> <span class=phase-name>Setup</span> </h4> </summary> <div class=content> </div> </details> <details class="phase call passed" open> <summary> <h4 class=title> <span class="status  passed"></span> <span class=phase-name>Call</span> </h4> </summary> <div class=content> </div> </details> <details class="phase teardown "> <summary> <h4 class=title> <span class=phase-name>Teardown</span> </h4> </summary> <div class=content> </div> </details> </div> </div> </details> <details class="test passed"> <summary> <h3 class="title test-title"> <span class="status badge passed ">PASSED</span> <span class=test-name> <span class=funcname>CatalogTest::test_sort_catalogs</span> </span> <span class=duration>0:00:00.170384</span> </h3> </summary> <div class=content> <table class=metadata> <tr> <th>Started</th> <td>2023-06-30 01:14:24</td> </tr> <tr> <th>Ended</th> <td>2023-06-30 01:14:24</td> </tr> <tr> <th>Duration</th> <td>0:00:00.170384</td> </tr> <tr> <th>Markers</th> <td> <div class=marker> <span class="marker-name badge">vcr</span> <span class=marker-args> </span> </div> <div class=marker> <span class="marker-name badge">unit_test</span> <span class=marker-args> </span> </div> </td> </tr> <tr> <th>Fixtures</th> <td> <span class="badge fixturename"> django_test_environment </span> <span class="badge fixturename"> django_db_blocker </span> <span class="badge fixturename"> vcr </span> <span class="badge fixturename"> vcr_config </span> <span class="badge fixturename"> vcr_cassette_dir </span> <span class="badge fixturename"> prepare_fixture </span> <span class="badge fixturename"> request </span> <span class="badge fixturename"> vcr_cassette </span> <span class="badge fixturename"> vcr_cassette_name </span> </td> </tr> </table> <div class=test-phases> <details class="phase setup "> <summary> <h4 class=title> <span class=phase-name>Setup</span> </h4> </summary> <div class=content> </div> </details> <details class="phase call passed" open> <summary> <h4 class=title> <span class="status  passed"></span> <span class=phase-name>Call</span> </h4> </summary> <div class=content> </div> </details> <details class="phase teardown "> <summary> <h4 class=title> <span class=phase-name>Teardown</span> </h4> </summary> <div class=content> </div> </details> </div> </div> </details> </div> </details> <details class=file> <summary> <h2 class="title file-title"> <span class=fspath> app/api/tests/test_contract.py </span> <span class=counts> <span title="11 passed" class="count status badge passed ">11</span> </span> <span class=duration> 0:00:00.999447 </span> </h2> </summary> <div class="content box"> <details class="test passed"> <summary> <h3 class="title test-title"> <span class="status badge passed ">PASSED</span> <span class=test-name> <span class=funcname>ContractTest::test_create_contract</span> </span> <span class=duration>0:00:00.163970</span> </h3> </summary> <div class=content> <table class=metadata> <tr> <th>Started</th> <td>2023-06-30 01:14:24</td> </tr> <tr> <th>Ended</th> <td>2023-06-30 01:14:24</td> </tr> <tr> <th>Duration</th> <td>0:00:00.163970</td> </tr> <tr> <th>Markers</th> <td> <div class=marker> <span class="marker-name badge">vcr</span> <span class=marker-args> before_record_request=&lt;function record_only_x3 at 0x7f34c31a49d0&gt; </span> </div> <div class=marker> <span class="marker-name badge">unit_test</span> <span class=marker-args> </span> </div> </td> </tr> <tr> <th>Fixtures</th> <td> <span class="badge fixturename"> django_test_environment </span> <span class="badge fixturename"> django_db_blocker </span> <span class="badge fixturename"> vcr </span> <span class="badge fixturename"> vcr_config </span> <span class="badge fixturename"> vcr_cassette_dir </span> <span class="badge fixturename"> prepare_fixture </span> <span class="badge fixturename"> request </span> <span class="badge fixturename"> vcr_cassette </span> <span class="badge fixturename"> vcr_cassette_name </span> </td> </tr> </table> <div class=test-phases> <details class="phase setup "> <summary> <h4 class=title> <span class=phase-name>Setup</span> </h4> </summary> <div class=content> </div> </details> <details class="phase call passed" open> <summary> <h4 class=title> <span class="status  passed"></span> <span class=phase-name>Call</span> </h4> </summary> <div class=content> </div> </details> <details class="phase teardown "> <summary> <h4 class=title> <span class=phase-name>Teardown</span> </h4> </summary> <div class=content> </div> </details> </div> </div> </details> <details class="test passed"> <summary> <h3 class="title test-title"> <span class="status badge passed ">PASSED</span> <span class=test-name> <span class=funcname>ContractTest::test_filter_contract</span> </span> <span class=duration>0:00:00.052533</span> </h3> </summary> <div class=content> <table class=metadata> <tr> <th>Started</th> <td>2023-06-30 01:14:24</td> </tr> <tr> <th>Ended</th> <td>2023-06-30 01:14:24</td> </tr> <tr> <th>Duration</th> <td>0:00:00.052533</td> </tr> <tr> <th>Markers</th> <td> <div class=marker> <span class="marker-name badge">vcr</span> <span class=marker-args> </span> </div> <div class=marker> <span class="marker-name badge">unit_test</span> <span class=marker-args> </span> </div> </td> </tr> <tr> <th>Fixtures</th> <td> <span class="badge fixturename"> django_test_environment </span> <span class="badge fixturename"> django_db_blocker </span> <span class="badge fixturename"> vcr </span> <span class="badge fixturename"> vcr_config </span> <span class="badge fixturename"> vcr_cassette_dir </span> <span class="badge fixturename"> prepare_fixture </span> <span class="badge fixturename"> request </span> <span class="badge fixturename"> vcr_cassette </span> <span class="badge fixturename"> vcr_cassette_name </span> </td> </tr> </table> <div class=test-phases> <details class="phase setup "> <summary> <h4 class=title> <span class=phase-name>Setup</span> </h4> </summary> <div class=content> </div> </details> <details class="phase call passed" open> <summary> <h4 class=title> <span class="status  passed"></span> <span class=phase-name>Call</span> </h4> </summary> <div class=content> </div> </details> <details class="phase teardown "> <summary> <h4 class=title> <span class=phase-name>Teardown</span> </h4> </summary> <div class=content> </div> </details> </div> </div> </details> <details class="test passed"> <summary> <h3 class="title test-title"> <span class="status badge passed ">PASSED</span> <span class=test-name> <span class=funcname>ContractTest::test_get_contract_not_found</span> </span> <span class=duration>0:00:00.050810</span> </h3> </summary> <div class=content> <table class=metadata> <tr> <th>Started</th> <td>2023-06-30 01:14:24</td> </tr> <tr> <th>Ended</th> <td>2023-06-30 01:14:24</td> </tr> <tr> <th>Duration</th> <td>0:00:00.050810</td> </tr> <tr> <th>Markers</th> <td> <div class=marker> <span class="marker-name badge">vcr</span> <span class=marker-args> </span> </div> <div class=marker> <span class="marker-name badge">unit_test</span> <span class=marker-args> </span> </div> </td> </tr> <tr> <th>Fixtures</th> <td> <span class="badge fixturename"> django_test_environment </span> <span class="badge fixturename"> django_db_blocker </span> <span class="badge fixturename"> vcr </span> <span class="badge fixturename"> vcr_config </span> <span class="badge fixturename"> vcr_cassette_dir </span> <span class="badge fixturename"> prepare_fixture </span> <span class="badge fixturename"> request </span> <span class="badge fixturename"> vcr_cassette </span> <span class="badge fixturename"> vcr_cassette_name </span> </td> </tr> </table> <div class=test-phases> <details class="phase setup "> <summary> <h4 class=title> <span class=phase-name>Setup</span> </h4> </summary> <div class=content> </div> </details> <details class="phase call passed" open> <summary> <h4 class=title> <span class="status  passed"></span> <span class=phase-name>Call</span> </h4> </summary> <div class=content> <div class=section> <h5 class=section-title>Captured log call</h5> <pre><samp>WARNING  django.request:log.py:241 Not Found: /api/v0/contracts/DUMMY/</samp></pre> </div> </div> </details> <details class="phase teardown "> <summary> <h4 class=title> <span class=phase-name>Teardown</span> </h4> </summary> <div class=content> </div> </details> </div> </div> </details> <details class="test passed"> <summary> <h3 class="title test-title"> <span class="status badge passed ">PASSED</span> <span class=test-name> <span class=funcname>ContractTest::test_get_contract_success</span> </span> <span class=duration>0:00:00.055843</span> </h3> </summary> <div class=content> <table class=metadata> <tr> <th>Started</th> <td>2023-06-30 01:14:24</td> </tr> <tr> <th>Ended</th> <td>2023-06-30 01:14:24</td> </tr> <tr> <th>Duration</th> <td>0:00:00.055843</td> </tr> <tr> <th>Markers</th> <td> <div class=marker> <span class="marker-name badge">vcr</span> <span class=marker-args> </span> </div> <div class=marker> <span class="marker-name badge">unit_test</span> <span class=marker-args> </span> </div> </td> </tr> <tr> <th>Fixtures</th> <td> <span class="badge fixturename"> django_test_environment </span> <span class="badge fixturename"> django_db_blocker </span> <span class="badge fixturename"> vcr </span> <span class="badge fixturename"> vcr_config </span> <span class="badge fixturename"> vcr_cassette_dir </span> <span class="badge fixturename"> prepare_fixture </span> <span class="badge fixturename"> request </span> <span class="badge fixturename"> vcr_cassette </span> <span class="badge fixturename"> vcr_cassette_name </span> </td> </tr> </table> <div class=test-phases> <details class="phase setup "> <summary> <h4 class=title> <span class=phase-name>Setup</span> </h4> </summary> <div class=content> </div> </details> <details class="phase call passed" open> <summary> <h4 class=title> <span class="status  passed"></span> <span class=phase-name>Call</span> </h4> </summary> <div class=content> </div> </details> <details class="phase teardown "> <summary> <h4 class=title> <span class=phase-name>Teardown</span> </h4> </summary> <div class=content> </div> </details> </div> </div> </details> <details class="test passed"> <summary> <h3 class="title test-title"> <span class="status badge passed ">PASSED</span> <span class=test-name> <span class=funcname>ContractTest::test_get_contract_with_decimal_prices</span> </span> <span class=duration>0:00:00.057818</span> </h3> </summary> <div class=content> <table class=metadata> <tr> <th>Started</th> <td>2023-06-30 01:14:24</td> </tr> <tr> <th>Ended</th> <td>2023-06-30 01:14:25</td> </tr> <tr> <th>Duration</th> <td>0:00:00.057818</td> </tr> <tr> <th>Markers</th> <td> <div class=marker> <span class="marker-name badge">vcr</span> <span class=marker-args> </span> </div> <div class=marker> <span class="marker-name badge">unit_test</span> <span class=marker-args> </span> </div> </td> </tr> <tr> <th>Fixtures</th> <td> <span class="badge fixturename"> django_test_environment </span> <span class="badge fixturename"> django_db_blocker </span> <span class="badge fixturename"> vcr </span> <span class="badge fixturename"> vcr_config </span> <span class="badge fixturename"> vcr_cassette_dir </span> <span class="badge fixturename"> prepare_fixture </span> <span class="badge fixturename"> request </span> <span class="badge fixturename"> vcr_cassette </span> <span class="badge fixturename"> vcr_cassette_name </span> </td> </tr> </table> <div class=test-phases> <details class="phase setup "> <summary> <h4 class=title> <span class=phase-name>Setup</span> </h4> </summary> <div class=content> </div> </details> <details class="phase call passed" open> <summary> <h4 class=title> <span class="status  passed"></span> <span class=phase-name>Call</span> </h4> </summary> <div class=content> </div> </details> <details class="phase teardown "> <summary> <h4 class=title> <span class=phase-name>Teardown</span> </h4> </summary> <div class=content> </div> </details> </div> </div> </details> <details class="test passed"> <summary> <h3 class="title test-title"> <span class="status badge passed ">PASSED</span> <span class=test-name> <span class=funcname>ContractTest::test_get_contract_with_empty_articles</span> </span> <span class=duration>0:00:00.057560</span> </h3> </summary> <div class=content> <table class=metadata> <tr> <th>Started</th> <td>2023-06-30 01:14:25</td> </tr> <tr> <th>Ended</th> <td>2023-06-30 01:14:25</td> </tr> <tr> <th>Duration</th> <td>0:00:00.057560</td> </tr> <tr> <th>Markers</th> <td> <div class=marker> <span class="marker-name badge">vcr</span> <span class=marker-args> </span> </div> <div class=marker> <span class="marker-name badge">unit_test</span> <span class=marker-args> </span> </div> </td> </tr> <tr> <th>Fixtures</th> <td> <span class="badge fixturename"> django_test_environment </span> <span class="badge fixturename"> django_db_blocker </span> <span class="badge fixturename"> vcr </span> <span class="badge fixturename"> vcr_config </span> <span class="badge fixturename"> vcr_cassette_dir </span> <span class="badge fixturename"> prepare_fixture </span> <span class="badge fixturename"> request </span> <span class="badge fixturename"> vcr_cassette </span> <span class="badge fixturename"> vcr_cassette_name </span> </td> </tr> </table> <div class=test-phases> <details class="phase setup "> <summary> <h4 class=title> <span class=phase-name>Setup</span> </h4> </summary> <div class=content> </div> </details> <details class="phase call passed" open> <summary> <h4 class=title> <span class="status  passed"></span> <span class=phase-name>Call</span> </h4> </summary> <div class=content> </div> </details> <details class="phase teardown "> <summary> <h4 class=title> <span class=phase-name>Teardown</span> </h4> </summary> <div class=content> </div> </details> </div> </div> </details> <details class="test passed"> <summary> <h3 class="title test-title"> <span class="status badge passed ">PASSED</span> <span class=test-name> <span class=funcname>ContractTest::test_get_contract_without_facility</span> </span> <span class=duration>0:00:00.058170</span> </h3> </summary> <div class=content> <table class=metadata> <tr> <th>Started</th> <td>2023-06-30 01:14:25</td> </tr> <tr> <th>Ended</th> <td>2023-06-30 01:14:25</td> </tr> <tr> <th>Duration</th> <td>0:00:00.058170</td> </tr> <tr> <th>Markers</th> <td> <div class=marker> <span class="marker-name badge">vcr</span> <span class=marker-args> </span> </div> <div class=marker> <span class="marker-name badge">unit_test</span> <span class=marker-args> </span> </div> </td> </tr> <tr> <th>Fixtures</th> <td> <span class="badge fixturename"> django_test_environment </span> <span class="badge fixturename"> django_db_blocker </span> <span class="badge fixturename"> vcr </span> <span class="badge fixturename"> vcr_config </span> <span class="badge fixturename"> vcr_cassette_dir </span> <span class="badge fixturename"> prepare_fixture </span> <span class="badge fixturename"> request </span> <span class="badge fixturename"> vcr_cassette </span> <span class="badge fixturename"> vcr_cassette_name </span> </td> </tr> </table> <div class=test-phases> <details class="phase setup "> <summary> <h4 class=title> <span class=phase-name>Setup</span> </h4> </summary> <div class=content> </div> </details> <details class="phase call passed" open> <summary> <h4 class=title> <span class="status  passed"></span> <span class=phase-name>Call</span> </h4> </summary> <div class=content> </div> </details> <details class="phase teardown "> <summary> <h4 class=title> <span class=phase-name>Teardown</span> </h4> </summary> <div class=content> </div> </details> </div> </div> </details> <details class="test passed"> <summary> <h3 class="title test-title"> <span class="status badge passed ">PASSED</span> <span class=test-name> <span class=funcname>ContractTest::test_lock_error</span> </span> <span class=duration>0:00:00.193448</span> </h3> </summary> <div class=content> <table class=metadata> <tr> <th>Started</th> <td>2023-06-30 01:14:25</td> </tr> <tr> <th>Ended</th> <td>2023-06-30 01:14:25</td> </tr> <tr> <th>Duration</th> <td>0:00:00.193448</td> </tr> <tr> <th>Markers</th> <td> <div class=marker> <span class="marker-name badge">vcr</span> <span class=marker-args> before_record_request=&lt;function record_only_x3 at 0x7f34c31a49d0&gt; </span> </div> <div class=marker> <span class="marker-name badge">unit_test</span> <span class=marker-args> </span> </div> </td> </tr> <tr> <th>Fixtures</th> <td> <span class="badge fixturename"> django_test_environment </span> <span class="badge fixturename"> django_db_blocker </span> <span class="badge fixturename"> vcr </span> <span class="badge fixturename"> vcr_config </span> <span class="badge fixturename"> vcr_cassette_dir </span> <span class="badge fixturename"> prepare_fixture </span> <span class="badge fixturename"> request </span> <span class="badge fixturename"> vcr_cassette </span> <span class="badge fixturename"> vcr_cassette_name </span> </td> </tr> </table> <div class=test-phases> <details class="phase setup "> <summary> <h4 class=title> <span class=phase-name>Setup</span> </h4> </summary> <div class=content> </div> </details> <details class="phase call passed" open> <summary> <h4 class=title> <span class="status  passed"></span> <span class=phase-name>Call</span> </h4> </summary> <div class=content> <div class=section> <h5 class=section-title>Captured log call</h5> <pre><samp>WARNING  django.request:log.py:241 Locked: /api/v0/contracts/CTAUX000000042/activate/</samp></pre> </div> </div> </details> <details class="phase teardown "> <summary> <h4 class=title> <span class=phase-name>Teardown</span> </h4> </summary> <div class=content> </div> </details> </div> </div> </details> <details class="test passed"> <summary> <h3 class="title test-title"> <span class="status badge passed ">PASSED</span> <span class=test-name> <span class=funcname>ContractTest::test_paginate_contract</span> </span> <span class=duration>0:00:00.064324</span> </h3> </summary> <div class=content> <table class=metadata> <tr> <th>Started</th> <td>2023-06-30 01:14:25</td> </tr> <tr> <th>Ended</th> <td>2023-06-30 01:14:25</td> </tr> <tr> <th>Duration</th> <td>0:00:00.064324</td> </tr> <tr> <th>Markers</th> <td> <div class=marker> <span class="marker-name badge">vcr</span> <span class=marker-args> </span> </div> <div class=marker> <span class="marker-name badge">unit_test</span> <span class=marker-args> </span> </div> </td> </tr> <tr> <th>Fixtures</th> <td> <span class="badge fixturename"> django_test_environment </span> <span class="badge fixturename"> django_db_blocker </span> <span class="badge fixturename"> vcr </span> <span class="badge fixturename"> vcr_config </span> <span class="badge fixturename"> vcr_cassette_dir </span> <span class="badge fixturename"> prepare_fixture </span> <span class="badge fixturename"> request </span> <span class="badge fixturename"> vcr_cassette </span> <span class="badge fixturename"> vcr_cassette_name </span> </td> </tr> </table> <div class=test-phases> <details class="phase setup "> <summary> <h4 class=title> <span class=phase-name>Setup</span> </h4> </summary> <div class=content> </div> </details> <details class="phase call passed" open> <summary> <h4 class=title> <span class="status  passed"></span> <span class=phase-name>Call</span> </h4> </summary> <div class=content> </div> </details> <details class="phase teardown "> <summary> <h4 class=title> <span class=phase-name>Teardown</span> </h4> </summary> <div class=content> </div> </details> </div> </div> </details> <details class="test passed"> <summary> <h3 class="title test-title"> <span class="status badge passed ">PASSED</span> <span class=test-name> <span class=funcname>ContractTest::test_query_contract</span> </span> <span class=duration>0:00:00.053227</span> </h3> </summary> <div class=content> <table class=metadata> <tr> <th>Started</th> <td>2023-06-30 01:14:25</td> </tr> <tr> <th>Ended</th> <td>2023-06-30 01:14:25</td> </tr> <tr> <th>Duration</th> <td>0:00:00.053227</td> </tr> <tr> <th>Markers</th> <td> <div class=marker> <span class="marker-name badge">vcr</span> <span class=marker-args> </span> </div> <div class=marker> <span class="marker-name badge">unit_test</span> <span class=marker-args> </span> </div> </td> </tr> <tr> <th>Fixtures</th> <td> <span class="badge fixturename"> django_test_environment </span> <span class="badge fixturename"> django_db_blocker </span> <span class="badge fixturename"> vcr </span> <span class="badge fixturename"> vcr_config </span> <span class="badge fixturename"> vcr_cassette_dir </span> <span class="badge fixturename"> prepare_fixture </span> <span class="badge fixturename"> request </span> <span class="badge fixturename"> vcr_cassette </span> <span class="badge fixturename"> vcr_cassette_name </span> </td> </tr> </table> <div class=test-phases> <details class="phase setup "> <summary> <h4 class=title> <span class=phase-name>Setup</span> </h4> </summary> <div class=content> </div> </details> <details class="phase call passed" open> <summary> <h4 class=title> <span class="status  passed"></span> <span class=phase-name>Call</span> </h4> </summary> <div class=content> </div> </details> <details class="phase teardown "> <summary> <h4 class=title> <span class=phase-name>Teardown</span> </h4> </summary> <div class=content> </div> </details> </div> </div> </details> <details class="test passed"> <summary> <h3 class="title test-title"> <span class="status badge passed ">PASSED</span> <span class=test-name> <span class=funcname>ContractTest::test_sort_contract</span> </span> <span class=duration>0:00:00.191744</span> </h3> </summary> <div class=content> <table class=metadata> <tr> <th>Started</th> <td>2023-06-30 01:14:25</td> </tr> <tr> <th>Ended</th> <td>2023-06-30 01:14:25</td> </tr> <tr> <th>Duration</th> <td>0:00:00.191744</td> </tr> <tr> <th>Markers</th> <td> <div class=marker> <span class="marker-name badge">vcr</span> <span class=marker-args> </span> </div> <div class=marker> <span class="marker-name badge">unit_test</span> <span class=marker-args> </span> </div> </td> </tr> <tr> <th>Fixtures</th> <td> <span class="badge fixturename"> django_test_environment </span> <span class="badge fixturename"> django_db_blocker </span> <span class="badge fixturename"> vcr </span> <span class="badge fixturename"> vcr_config </span> <span class="badge fixturename"> vcr_cassette_dir </span> <span class="badge fixturename"> prepare_fixture </span> <span class="badge fixturename"> request </span> <span class="badge fixturename"> vcr_cassette </span> <span class="badge fixturename"> vcr_cassette_name </span> </td> </tr> </table> <div class=test-phases> <details class="phase setup "> <summary> <h4 class=title> <span class=phase-name>Setup</span> </h4> </summary> <div class=content> </div> </details> <details class="phase call passed" open> <summary> <h4 class=title> <span class="status  passed"></span> <span class=phase-name>Call</span> </h4> </summary> <div class=content> </div> </details> <details class="phase teardown "> <summary> <h4 class=title> <span class=phase-name>Teardown</span> </h4> </summary> <div class=content> </div> </details> </div> </div> </details> </div> </details> <details class=file> <summary> <h2 class="title file-title"> <span class=fspath> app/api/tests/test_cpv.py </span> <span class=counts> <span title="1 passed" class="count status badge passed ">1</span> </span> <span class=duration> 0:00:00.508276 </span> </h2> </summary> <div class="content box"> <details class="test passed"> <summary> <h3 class="title test-title"> <span class="status badge passed ">PASSED</span> <span class=test-name> <span class=funcname>CPVTest::test_query_cpv</span> </span> <span class=duration>0:00:00.508276</span> </h3> </summary> <div class=content> <table class=metadata> <tr> <th>Started</th> <td>2023-06-30 01:14:25</td> </tr> <tr> <th>Ended</th> <td>2023-06-30 01:14:26</td> </tr> <tr> <th>Duration</th> <td>0:00:00.508276</td> </tr> <tr> <th>Markers</th> <td> <div class=marker> <span class="marker-name badge">vcr</span> <span class=marker-args> </span> </div> <div class=marker> <span class="marker-name badge">unit_test</span> <span class=marker-args> </span> </div> </td> </tr> <tr> <th>Fixtures</th> <td> <span class="badge fixturename"> django_test_environment </span> <span class="badge fixturename"> django_db_blocker </span> <span class="badge fixturename"> request </span> </td> </tr> </table> <div class=test-phases> <details class="phase setup "> <summary> <h4 class=title> <span class=phase-name>Setup</span> </h4> </summary> <div class=content> </div> </details> <details class="phase call passed" open> <summary> <h4 class=title> <span class="status  passed"></span> <span class=phase-name>Call</span> </h4> </summary> <div class=content> </div> </details> <details class="phase teardown "> <summary> <h4 class=title> <span class=phase-name>Teardown</span> </h4> </summary> <div class=content> </div> </details> </div> </div> </details> </div> </details> <details class=file> <summary> <h2 class="title file-title"> <span class=fspath> app/api/tests/test_customer.py </span> <span class=counts> <span title="9 passed" class="count status badge passed ">9</span> </span> <span class=duration> 0:00:01.001006 </span> </h2> </summary> <div class="content box"> <details class="test passed"> <summary> <h3 class="title test-title"> <span class="status badge passed ">PASSED</span> <span class=test-name> <span class=funcname>CustomerTest::test_filter_customer</span> </span> <span class=duration>0:00:00.060303</span> </h3> </summary> <div class=content> <table class=metadata> <tr> <th>Started</th> <td>2023-06-30 01:14:26</td> </tr> <tr> <th>Ended</th> <td>2023-06-30 01:14:26</td> </tr> <tr> <th>Duration</th> <td>0:00:00.060303</td> </tr> <tr> <th>Markers</th> <td> <div class=marker> <span class="marker-name badge">vcr</span> <span class=marker-args> </span> </div> <div class=marker> <span class="marker-name badge">unit_test</span> <span class=marker-args> </span> </div> </td> </tr> <tr> <th>Fixtures</th> <td> <span class="badge fixturename"> django_test_environment </span> <span class="badge fixturename"> django_db_blocker </span> <span class="badge fixturename"> vcr </span> <span class="badge fixturename"> vcr_config </span> <span class="badge fixturename"> vcr_cassette_dir </span> <span class="badge fixturename"> prepare_fixture </span> <span class="badge fixturename"> request </span> <span class="badge fixturename"> vcr_cassette </span> <span class="badge fixturename"> vcr_cassette_name </span> </td> </tr> </table> <div class=test-phases> <details class="phase setup "> <summary> <h4 class=title> <span class=phase-name>Setup</span> </h4> </summary> <div class=content> </div> </details> <details class="phase call passed" open> <summary> <h4 class=title> <span class="status  passed"></span> <span class=phase-name>Call</span> </h4> </summary> <div class=content> </div> </details> <details class="phase teardown "> <summary> <h4 class=title> <span class=phase-name>Teardown</span> </h4> </summary> <div class=content> </div> </details> </div> </div> </details> <details class="test passed"> <summary> <h3 class="title test-title"> <span class="status badge passed ">PASSED</span> <span class=test-name> <span class=funcname>CustomerTest::test_get_customer_not_found</span> </span> <span class=duration>0:00:00.054131</span> </h3> </summary> <div class=content> <table class=metadata> <tr> <th>Started</th> <td>2023-06-30 01:14:26</td> </tr> <tr> <th>Ended</th> <td>2023-06-30 01:14:26</td> </tr> <tr> <th>Duration</th> <td>0:00:00.054131</td> </tr> <tr> <th>Markers</th> <td> <div class=marker> <span class="marker-name badge">vcr</span> <span class=marker-args> </span> </div> <div class=marker> <span class="marker-name badge">unit_test</span> <span class=marker-args> </span> </div> </td> </tr> <tr> <th>Fixtures</th> <td> <span class="badge fixturename"> django_test_environment </span> <span class="badge fixturename"> django_db_blocker </span> <span class="badge fixturename"> vcr </span> <span class="badge fixturename"> vcr_config </span> <span class="badge fixturename"> vcr_cassette_dir </span> <span class="badge fixturename"> prepare_fixture </span> <span class="badge fixturename"> request </span> <span class="badge fixturename"> vcr_cassette </span> <span class="badge fixturename"> vcr_cassette_name </span> </td> </tr> </table> <div class=test-phases> <details class="phase setup "> <summary> <h4 class=title> <span class=phase-name>Setup</span> </h4> </summary> <div class=content> </div> </details> <details class="phase call passed" open> <summary> <h4 class=title> <span class="status  passed"></span> <span class=phase-name>Call</span> </h4> </summary> <div class=content> <div class=section> <h5 class=section-title>Captured log call</h5> <pre><samp>WARNING  django.request:log.py:241 Not Found: /api/v0/customers/DUMMY/</samp></pre> </div> </div> </details> <details class="phase teardown "> <summary> <h4 class=title> <span class=phase-name>Teardown</span> </h4> </summary> <div class=content> </div> </details> </div> </div> </details> <details class="test passed"> <summary> <h3 class="title test-title"> <span class="status badge passed ">PASSED</span> <span class=test-name> <span class=funcname>CustomerTest::test_get_customer_success</span> </span> <span class=duration>0:00:00.057256</span> </h3> </summary> <div class=content> <table class=metadata> <tr> <th>Started</th> <td>2023-06-30 01:14:26</td> </tr> <tr> <th>Ended</th> <td>2023-06-30 01:14:26</td> </tr> <tr> <th>Duration</th> <td>0:00:00.057256</td> </tr> <tr> <th>Markers</th> <td> <div class=marker> <span class="marker-name badge">vcr</span> <span class=marker-args> </span> </div> <div class=marker> <span class="marker-name badge">unit_test</span> <span class=marker-args> </span> </div> </td> </tr> <tr> <th>Fixtures</th> <td> <span class="badge fixturename"> django_test_environment </span> <span class="badge fixturename"> django_db_blocker </span> <span class="badge fixturename"> vcr </span> <span class="badge fixturename"> vcr_config </span> <span class="badge fixturename"> vcr_cassette_dir </span> <span class="badge fixturename"> prepare_fixture </span> <span class="badge fixturename"> request </span> <span class="badge fixturename"> vcr_cassette </span> <span class="badge fixturename"> vcr_cassette_name </span> </td> </tr> </table> <div class=test-phases> <details class="phase setup "> <summary> <h4 class=title> <span class=phase-name>Setup</span> </h4> </summary> <div class=content> </div> </details> <details class="phase call passed" open> <summary> <h4 class=title> <span class="status  passed"></span> <span class=phase-name>Call</span> </h4> </summary> <div class=content> </div> </details> <details class="phase teardown "> <summary> <h4 class=title> <span class=phase-name>Teardown</span> </h4> </summary> <div class=content> </div> </details> </div> </div> </details> <details class="test passed"> <summary> <h3 class="title test-title"> <span class="status badge passed ">PASSED</span> <span class=test-name> <span class=funcname>CustomerTest::test_handle_filter_errors</span> </span> <span class=duration>0:00:00.205951</span> </h3> </summary> <div class=content> <table class=metadata> <tr> <th>Started</th> <td>2023-06-30 01:14:26</td> </tr> <tr> <th>Ended</th> <td>2023-06-30 01:14:26</td> </tr> <tr> <th>Duration</th> <td>0:00:00.205951</td> </tr> <tr> <th>Markers</th> <td> <div class=marker> <span class="marker-name badge">vcr</span> <span class=marker-args> </span> </div> <div class=marker> <span class="marker-name badge">unit_test</span> <span class=marker-args> </span> </div> </td> </tr> <tr> <th>Fixtures</th> <td> <span class="badge fixturename"> django_test_environment </span> <span class="badge fixturename"> django_db_blocker </span> <span class="badge fixturename"> vcr </span> <span class="badge fixturename"> vcr_config </span> <span class="badge fixturename"> vcr_cassette_dir </span> <span class="badge fixturename"> prepare_fixture </span> <span class="badge fixturename"> request </span> <span class="badge fixturename"> vcr_cassette </span> <span class="badge fixturename"> vcr_cassette_name </span> </td> </tr> </table> <div class=test-phases> <details class="phase setup "> <summary> <h4 class=title> <span class=phase-name>Setup</span> </h4> </summary> <div class=content> </div> </details> <details class="phase call passed" open> <summary> <h4 class=title> <span class="status  passed"></span> <span class=phase-name>Call</span> </h4> </summary> <div class=content> <div class=section> <h5 class=section-title>Captured log call</h5> <pre><samp>WARNING  django.request:log.py:241 Bad Request: /api/v0/customers/
WARNING  django.request:log.py:241 Bad Request: /api/v0/customers/
WARNING  django.request:log.py:241 Bad Request: /api/v0/customers/
WARNING  django.request:log.py:241 Bad Request: /api/v0/customers/</samp></pre> </div> </div> </details> <details class="phase teardown "> <summary> <h4 class=title> <span class=phase-name>Teardown</span> </h4> </summary> <div class=content> </div> </details> </div> </div> </details> <details class="test passed"> <summary> <h3 class="title test-title"> <span class="status badge passed ">PASSED</span> <span class=test-name> <span class=funcname>CustomerTest::test_handle_sort_field_errors</span> </span> <span class=duration>0:00:00.068725</span> </h3> </summary> <div class=content> <table class=metadata> <tr> <th>Started</th> <td>2023-06-30 01:14:26</td> </tr> <tr> <th>Ended</th> <td>2023-06-30 01:14:26</td> </tr> <tr> <th>Duration</th> <td>0:00:00.068725</td> </tr> <tr> <th>Markers</th> <td> <div class=marker> <span class="marker-name badge">vcr</span> <span class=marker-args> </span> </div> <div class=marker> <span class="marker-name badge">unit_test</span> <span class=marker-args> </span> </div> </td> </tr> <tr> <th>Fixtures</th> <td> <span class="badge fixturename"> django_test_environment </span> <span class="badge fixturename"> django_db_blocker </span> <span class="badge fixturename"> vcr </span> <span class="badge fixturename"> vcr_config </span> <span class="badge fixturename"> vcr_cassette_dir </span> <span class="badge fixturename"> prepare_fixture </span> <span class="badge fixturename"> request </span> <span class="badge fixturename"> vcr_cassette </span> <span class="badge fixturename"> vcr_cassette_name </span> </td> </tr> </table> <div class=test-phases> <details class="phase setup "> <summary> <h4 class=title> <span class=phase-name>Setup</span> </h4> </summary> <div class=content> </div> </details> <details class="phase call passed" open> <summary> <h4 class=title> <span class="status  passed"></span> <span class=phase-name>Call</span> </h4> </summary> <div class=content> <div class=section> <h5 class=section-title>Captured log call</h5> <pre><samp>WARNING  django.request:log.py:241 Bad Request: /api/v0/customers/</samp></pre> </div> </div> </details> <details class="phase teardown "> <summary> <h4 class=title> <span class=phase-name>Teardown</span> </h4> </summary> <div class=content> </div> </details> </div> </div> </details> <details class="test passed"> <summary> <h3 class="title test-title"> <span class="status badge passed ">PASSED</span> <span class=test-name> <span class=funcname>CustomerTest::test_handle_sort_order_errors</span> </span> <span class=duration>0:00:00.066684</span> </h3> </summary> <div class=content> <table class=metadata> <tr> <th>Started</th> <td>2023-06-30 01:14:26</td> </tr> <tr> <th>Ended</th> <td>2023-06-30 01:14:26</td> </tr> <tr> <th>Duration</th> <td>0:00:00.066684</td> </tr> <tr> <th>Markers</th> <td> <div class=marker> <span class="marker-name badge">vcr</span> <span class=marker-args> </span> </div> <div class=marker> <span class="marker-name badge">unit_test</span> <span class=marker-args> </span> </div> </td> </tr> <tr> <th>Fixtures</th> <td> <span class="badge fixturename"> django_test_environment </span> <span class="badge fixturename"> django_db_blocker </span> <span class="badge fixturename"> vcr </span> <span class="badge fixturename"> vcr_config </span> <span class="badge fixturename"> vcr_cassette_dir </span> <span class="badge fixturename"> prepare_fixture </span> <span class="badge fixturename"> request </span> <span class="badge fixturename"> vcr_cassette </span> <span class="badge fixturename"> vcr_cassette_name </span> </td> </tr> </table> <div class=test-phases> <details class="phase setup "> <summary> <h4 class=title> <span class=phase-name>Setup</span> </h4> </summary> <div class=content> </div> </details> <details class="phase call passed" open> <summary> <h4 class=title> <span class="status  passed"></span> <span class=phase-name>Call</span> </h4> </summary> <div class=content> <div class=section> <h5 class=section-title>Captured log call</h5> <pre><samp>WARNING  django.request:log.py:241 Bad Request: /api/v0/customers/</samp></pre> </div> </div> </details> <details class="phase teardown "> <summary> <h4 class=title> <span class=phase-name>Teardown</span> </h4> </summary> <div class=content> </div> </details> </div> </div> </details> <details class="test passed"> <summary> <h3 class="title test-title"> <span class="status badge passed ">PASSED</span> <span class=test-name> <span class=funcname>CustomerTest::test_paginate_customer</span> </span> <span class=duration>0:00:00.072529</span> </h3> </summary> <div class=content> <table class=metadata> <tr> <th>Started</th> <td>2023-06-30 01:14:26</td> </tr> <tr> <th>Ended</th> <td>2023-06-30 01:14:26</td> </tr> <tr> <th>Duration</th> <td>0:00:00.072529</td> </tr> <tr> <th>Markers</th> <td> <div class=marker> <span class="marker-name badge">vcr</span> <span class=marker-args> </span> </div> <div class=marker> <span class="marker-name badge">unit_test</span> <span class=marker-args> </span> </div> </td> </tr> <tr> <th>Fixtures</th> <td> <span class="badge fixturename"> django_test_environment </span> <span class="badge fixturename"> django_db_blocker </span> <span class="badge fixturename"> vcr </span> <span class="badge fixturename"> vcr_config </span> <span class="badge fixturename"> vcr_cassette_dir </span> <span class="badge fixturename"> prepare_fixture </span> <span class="badge fixturename"> request </span> <span class="badge fixturename"> vcr_cassette </span> <span class="badge fixturename"> vcr_cassette_name </span> </td> </tr> </table> <div class=test-phases> <details class="phase setup "> <summary> <h4 class=title> <span class=phase-name>Setup</span> </h4> </summary> <div class=content> </div> </details> <details class="phase call passed" open> <summary> <h4 class=title> <span class="status  passed"></span> <span class=phase-name>Call</span> </h4> </summary> <div class=content> </div> </details> <details class="phase teardown "> <summary> <h4 class=title> <span class=phase-name>Teardown</span> </h4> </summary> <div class=content> </div> </details> </div> </div> </details> <details class="test passed"> <summary> <h3 class="title test-title"> <span class="status badge passed ">PASSED</span> <span class=test-name> <span class=funcname>CustomerTest::test_query_customer</span> </span> <span class=duration>0:00:00.054254</span> </h3> </summary> <div class=content> <table class=metadata> <tr> <th>Started</th> <td>2023-06-30 01:14:26</td> </tr> <tr> <th>Ended</th> <td>2023-06-30 01:14:26</td> </tr> <tr> <th>Duration</th> <td>0:00:00.054254</td> </tr> <tr> <th>Markers</th> <td> <div class=marker> <span class="marker-name badge">vcr</span> <span class=marker-args> </span> </div> <div class=marker> <span class="marker-name badge">unit_test</span> <span class=marker-args> </span> </div> </td> </tr> <tr> <th>Fixtures</th> <td> <span class="badge fixturename"> django_test_environment </span> <span class="badge fixturename"> django_db_blocker </span> <span class="badge fixturename"> vcr </span> <span class="badge fixturename"> vcr_config </span> <span class="badge fixturename"> vcr_cassette_dir </span> <span class="badge fixturename"> prepare_fixture </span> <span class="badge fixturename"> request </span> <span class="badge fixturename"> vcr_cassette </span> <span class="badge fixturename"> vcr_cassette_name </span> </td> </tr> </table> <div class=test-phases> <details class="phase setup "> <summary> <h4 class=title> <span class=phase-name>Setup</span> </h4> </summary> <div class=content> </div> </details> <details class="phase call passed" open> <summary> <h4 class=title> <span class="status  passed"></span> <span class=phase-name>Call</span> </h4> </summary> <div class=content> </div> </details> <details class="phase teardown "> <summary> <h4 class=title> <span class=phase-name>Teardown</span> </h4> </summary> <div class=content> </div> </details> </div> </div> </details> <details class="test passed"> <summary> <h3 class="title test-title"> <span class="status badge passed ">PASSED</span> <span class=test-name> <span class=funcname>CustomerTest::test_sort_customer</span> </span> <span class=duration>0:00:00.361173</span> </h3> </summary> <div class=content> <table class=metadata> <tr> <th>Started</th> <td>2023-06-30 01:14:26</td> </tr> <tr> <th>Ended</th> <td>2023-06-30 01:14:27</td> </tr> <tr> <th>Duration</th> <td>0:00:00.361173</td> </tr> <tr> <th>Markers</th> <td> <div class=marker> <span class="marker-name badge">vcr</span> <span class=marker-args> </span> </div> <div class=marker> <span class="marker-name badge">unit_test</span> <span class=marker-args> </span> </div> </td> </tr> <tr> <th>Fixtures</th> <td> <span class="badge fixturename"> django_test_environment </span> <span class="badge fixturename"> django_db_blocker </span> <span class="badge fixturename"> vcr </span> <span class="badge fixturename"> vcr_config </span> <span class="badge fixturename"> vcr_cassette_dir </span> <span class="badge fixturename"> prepare_fixture </span> <span class="badge fixturename"> request </span> <span class="badge fixturename"> vcr_cassette </span> <span class="badge fixturename"> vcr_cassette_name </span> </td> </tr> </table> <div class=test-phases> <details class="phase setup "> <summary> <h4 class=title> <span class=phase-name>Setup</span> </h4> </summary> <div class=content> </div> </details> <details class="phase call passed" open> <summary> <h4 class=title> <span class="status  passed"></span> <span class=phase-name>Call</span> </h4> </summary> <div class=content> </div> </details> <details class="phase teardown "> <summary> <h4 class=title> <span class=phase-name>Teardown</span> </h4> </summary> <div class=content> </div> </details> </div> </div> </details> </div> </details> <details class=file> <summary> <h2 class="title file-title"> <span class=fspath> app/api/tests/test_doc.py </span> <span class=counts> <span title="2 passed" class="count status badge passed ">2</span> </span> <span class=duration> 0:00:01.804775 </span> </h2> </summary> <div class="content box"> <details class="test passed"> <summary> <h3 class="title test-title"> <span class="status badge passed ">PASSED</span> <span class=test-name> <span class=funcname>DocumentationTest::test_doc</span> </span> <span class=duration>0:00:00.086439</span> </h3> </summary> <div class=content> <table class=metadata> <tr> <th>Started</th> <td>2023-06-30 01:14:21</td> </tr> <tr> <th>Ended</th> <td>2023-06-30 01:14:21</td> </tr> <tr> <th>Duration</th> <td>0:00:00.086439</td> </tr> <tr> <th>Markers</th> <td> <div class=marker> <span class="marker-name badge">unit_test</span> <span class=marker-args> </span> </div> </td> </tr> <tr> <th>Fixtures</th> <td> <span class="badge fixturename"> django_test_environment </span> <span class="badge fixturename"> django_db_blocker </span> <span class="badge fixturename"> request </span> </td> </tr> </table> <div class=test-phases> <details class="phase setup "> <summary> <h4 class=title> <span class=phase-name>Setup</span> </h4> </summary> <div class=content> </div> </details> <details class="phase call passed" open> <summary> <h4 class=title> <span class="status  passed"></span> <span class=phase-name>Call</span> </h4> </summary> <div class=content> </div> </details> <details class="phase teardown "> <summary> <h4 class=title> <span class=phase-name>Teardown</span> </h4> </summary> <div class=content> </div> </details> </div> </div> </details> <details class="test passed"> <summary> <h3 class="title test-title"> <span class="status badge passed ">PASSED</span> <span class=test-name> <span class=funcname>DocumentationTest::test_health_check</span> </span> <span class=duration>0:00:01.718336</span> </h3> </summary> <div class=content> <table class=metadata> <tr> <th>Started</th> <td>2023-06-30 01:14:21</td> </tr> <tr> <th>Ended</th> <td>2023-06-30 01:14:23</td> </tr> <tr> <th>Duration</th> <td>0:00:01.718336</td> </tr> <tr> <th>Markers</th> <td> <div class=marker> <span class="marker-name badge">unit_test</span> <span class=marker-args> </span> </div> </td> </tr> <tr> <th>Fixtures</th> <td> <span class="badge fixturename"> django_test_environment </span> <span class="badge fixturename"> django_db_blocker </span> <span class="badge fixturename"> request </span> </td> </tr> </table> <div class=test-phases> <details class="phase setup "> <summary> <h4 class=title> <span class=phase-name>Setup</span> </h4> </summary> <div class=content> </div> </details> <details class="phase call passed" open> <summary> <h4 class=title> <span class="status  passed"></span> <span class=phase-name>Call</span> </h4> </summary> <div class=content> <div class=section> <h5 class=section-title>Captured log call</h5> <pre><samp>ERROR    django.request:log.py:241 Service Unavailable: /healthcheck/</samp></pre> </div> </div> </details> <details class="phase teardown "> <summary> <h4 class=title> <span class=phase-name>Teardown</span> </h4> </summary> <div class=content> </div> </details> </div> </div> </details> </div> </details> <details class=file> <summary> <h2 class="title file-title"> <span class=fspath> app/api/tests/test_facilities.py </span> <span class=counts> <span title="4 passed" class="count status badge passed ">4</span> </span> <span class=duration> 0:00:00.504617 </span> </h2> </summary> <div class="content box"> <details class="test passed"> <summary> <h3 class="title test-title"> <span class="status badge passed ">PASSED</span> <span class=test-name> <span class=funcname>SiteTest::test_filter_facilities</span> </span> <span class=duration>0:00:00.062506</span> </h3> </summary> <div class=content> <table class=metadata> <tr> <th>Started</th> <td>2023-06-30 01:14:27</td> </tr> <tr> <th>Ended</th> <td>2023-06-30 01:14:27</td> </tr> <tr> <th>Duration</th> <td>0:00:00.062506</td> </tr> <tr> <th>Markers</th> <td> <div class=marker> <span class="marker-name badge">vcr</span> <span class=marker-args> </span> </div> <div class=marker> <span class="marker-name badge">unit_test</span> <span class=marker-args> </span> </div> </td> </tr> <tr> <th>Fixtures</th> <td> <span class="badge fixturename"> django_test_environment </span> <span class="badge fixturename"> django_db_blocker </span> <span class="badge fixturename"> vcr </span> <span class="badge fixturename"> vcr_config </span> <span class="badge fixturename"> vcr_cassette_dir </span> <span class="badge fixturename"> prepare_fixture </span> <span class="badge fixturename"> request </span> <span class="badge fixturename"> vcr_cassette </span> <span class="badge fixturename"> vcr_cassette_name </span> </td> </tr> </table> <div class=test-phases> <details class="phase setup "> <summary> <h4 class=title> <span class=phase-name>Setup</span> </h4> </summary> <div class=content> </div> </details> <details class="phase call passed" open> <summary> <h4 class=title> <span class="status  passed"></span> <span class=phase-name>Call</span> </h4> </summary> <div class=content> </div> </details> <details class="phase teardown "> <summary> <h4 class=title> <span class=phase-name>Teardown</span> </h4> </summary> <div class=content> </div> </details> </div> </div> </details> <details class="test passed"> <summary> <h3 class="title test-title"> <span class="status badge passed ">PASSED</span> <span class=test-name> <span class=funcname>SiteTest::test_paginate_facilities</span> </span> <span class=duration>0:00:00.078122</span> </h3> </summary> <div class=content> <table class=metadata> <tr> <th>Started</th> <td>2023-06-30 01:14:27</td> </tr> <tr> <th>Ended</th> <td>2023-06-30 01:14:27</td> </tr> <tr> <th>Duration</th> <td>0:00:00.078122</td> </tr> <tr> <th>Markers</th> <td> <div class=marker> <span class="marker-name badge">vcr</span> <span class=marker-args> </span> </div> <div class=marker> <span class="marker-name badge">unit_test</span> <span class=marker-args> </span> </div> </td> </tr> <tr> <th>Fixtures</th> <td> <span class="badge fixturename"> django_test_environment </span> <span class="badge fixturename"> django_db_blocker </span> <span class="badge fixturename"> vcr </span> <span class="badge fixturename"> vcr_config </span> <span class="badge fixturename"> vcr_cassette_dir </span> <span class="badge fixturename"> prepare_fixture </span> <span class="badge fixturename"> request </span> <span class="badge fixturename"> vcr_cassette </span> <span class="badge fixturename"> vcr_cassette_name </span> </td> </tr> </table> <div class=test-phases> <details class="phase setup "> <summary> <h4 class=title> <span class=phase-name>Setup</span> </h4> </summary> <div class=content> </div> </details> <details class="phase call passed" open> <summary> <h4 class=title> <span class="status  passed"></span> <span class=phase-name>Call</span> </h4> </summary> <div class=content> </div> </details> <details class="phase teardown "> <summary> <h4 class=title> <span class=phase-name>Teardown</span> </h4> </summary> <div class=content> </div> </details> </div> </div> </details> <details class="test passed"> <summary> <h3 class="title test-title"> <span class="status badge passed ">PASSED</span> <span class=test-name> <span class=funcname>SiteTest::test_query_facilities</span> </span> <span class=duration>0:00:00.059359</span> </h3> </summary> <div class=content> <table class=metadata> <tr> <th>Started</th> <td>2023-06-30 01:14:27</td> </tr> <tr> <th>Ended</th> <td>2023-06-30 01:14:27</td> </tr> <tr> <th>Duration</th> <td>0:00:00.059359</td> </tr> <tr> <th>Markers</th> <td> <div class=marker> <span class="marker-name badge">vcr</span> <span class=marker-args> </span> </div> <div class=marker> <span class="marker-name badge">unit_test</span> <span class=marker-args> </span> </div> </td> </tr> <tr> <th>Fixtures</th> <td> <span class="badge fixturename"> django_test_environment </span> <span class="badge fixturename"> django_db_blocker </span> <span class="badge fixturename"> vcr </span> <span class="badge fixturename"> vcr_config </span> <span class="badge fixturename"> vcr_cassette_dir </span> <span class="badge fixturename"> prepare_fixture </span> <span class="badge fixturename"> request </span> <span class="badge fixturename"> vcr_cassette </span> <span class="badge fixturename"> vcr_cassette_name </span> </td> </tr> </table> <div class=test-phases> <details class="phase setup "> <summary> <h4 class=title> <span class=phase-name>Setup</span> </h4> </summary> <div class=content> </div> </details> <details class="phase call passed" open> <summary> <h4 class=title> <span class="status  passed"></span> <span class=phase-name>Call</span> </h4> </summary> <div class=content> </div> </details> <details class="phase teardown "> <summary> <h4 class=title> <span class=phase-name>Teardown</span> </h4> </summary> <div class=content> </div> </details> </div> </div> </details> <details class="test passed"> <summary> <h3 class="title test-title"> <span class="status badge passed ">PASSED</span> <span class=test-name> <span class=funcname>SiteTest::test_sort_facilities</span> </span> <span class=duration>0:00:00.304630</span> </h3> </summary> <div class=content> <table class=metadata> <tr> <th>Started</th> <td>2023-06-30 01:14:27</td> </tr> <tr> <th>Ended</th> <td>2023-06-30 01:14:27</td> </tr> <tr> <th>Duration</th> <td>0:00:00.304630</td> </tr> <tr> <th>Markers</th> <td> <div class=marker> <span class="marker-name badge">vcr</span> <span class=marker-args> </span> </div> <div class=marker> <span class="marker-name badge">unit_test</span> <span class=marker-args> </span> </div> </td> </tr> <tr> <th>Fixtures</th> <td> <span class="badge fixturename"> django_test_environment </span> <span class="badge fixturename"> django_db_blocker </span> <span class="badge fixturename"> vcr </span> <span class="badge fixturename"> vcr_config </span> <span class="badge fixturename"> vcr_cassette_dir </span> <span class="badge fixturename"> prepare_fixture </span> <span class="badge fixturename"> request </span> <span class="badge fixturename"> vcr_cassette </span> <span class="badge fixturename"> vcr_cassette_name </span> </td> </tr> </table> <div class=test-phases> <details class="phase setup "> <summary> <h4 class=title> <span class=phase-name>Setup</span> </h4> </summary> <div class=content> </div> </details> <details class="phase call passed" open> <summary> <h4 class=title> <span class="status  passed"></span> <span class=phase-name>Call</span> </h4> </summary> <div class=content> </div> </details> <details class="phase teardown "> <summary> <h4 class=title> <span class=phase-name>Teardown</span> </h4> </summary> <div class=content> </div> </details> </div> </div> </details> </div> </details> <details class=file> <summary> <h2 class="title file-title"> <span class=fspath> app/api/tests/test_modify_option_contract.py </span> <span class=counts> <span title="12 passed" class="count status badge passed ">12</span> </span> <span class=duration> 0:00:01.999815 </span> </h2> </summary> <div class="content box"> <details class="test passed"> <summary> <h3 class="title test-title"> <span class="status badge passed ">PASSED</span> <span class=test-name> <span class=funcname>ModifyOptionContractTest::test_modify_option_contract_activated</span> </span> <span class=duration>0:00:01.224642</span> </h3> </summary> <div class=content> <table class=metadata> <tr> <th>Started</th> <td>2023-06-30 01:14:27</td> </tr> <tr> <th>Ended</th> <td>2023-06-30 01:14:28</td> </tr> <tr> <th>Duration</th> <td>0:00:01.224642</td> </tr> <tr> <th>Markers</th> <td> <div class=marker> <span class="marker-name badge">vcr</span> <span class=marker-args> before_record_request=&lt;function record_only_x3 at 0x7f34c31a49d0&gt; </span> </div> <div class=marker> <span class="marker-name badge">unit_test</span> <span class=marker-args> </span> </div> </td> </tr> <tr> <th>Fixtures</th> <td> <span class="badge fixturename"> django_test_environment </span> <span class="badge fixturename"> django_db_blocker </span> <span class="badge fixturename"> request </span> </td> </tr> </table> <div class=test-phases> <details class="phase setup "> <summary> <h4 class=title> <span class=phase-name>Setup</span> </h4> </summary> <div class=content> </div> </details> <details class="phase call passed" open> <summary> <h4 class=title> <span class="status  passed"></span> <span class=phase-name>Call</span> </h4> </summary> <div class=content> </div> </details> <details class="phase teardown "> <summary> <h4 class=title> <span class=phase-name>Teardown</span> </h4> </summary> <div class=content> </div> </details> </div> </div> </details> <details class="test passed"> <summary> <h3 class="title test-title"> <span class="status badge passed ">PASSED</span> <span class=test-name> <span class=funcname>ModifyOptionContractTest::test_modify_option_multiple_options</span> </span> <span class=duration>0:00:00.053310</span> </h3> </summary> <div class=content> <table class=metadata> <tr> <th>Started</th> <td>2023-06-30 01:14:28</td> </tr> <tr> <th>Ended</th> <td>2023-06-30 01:14:28</td> </tr> <tr> <th>Duration</th> <td>0:00:00.053310</td> </tr> <tr> <th>Markers</th> <td> <div class=marker> <span class="marker-name badge">vcr</span> <span class=marker-args> </span> </div> <div class=marker> <span class="marker-name badge">unit_test</span> <span class=marker-args> </span> </div> </td> </tr> <tr> <th>Fixtures</th> <td> <span class="badge fixturename"> django_test_environment </span> <span class="badge fixturename"> django_db_blocker </span> <span class="badge fixturename"> request </span> </td> </tr> </table> <div class=test-phases> <details class="phase setup "> <summary> <h4 class=title> <span class=phase-name>Setup</span> </h4> </summary> <div class=content> </div> </details> <details class="phase call passed" open> <summary> <h4 class=title> <span class="status  passed"></span> <span class=phase-name>Call</span> </h4> </summary> <div class=content> </div> </details> <details class="phase teardown "> <summary> <h4 class=title> <span class=phase-name>Teardown</span> </h4> </summary> <div class=content> </div> </details> </div> </div> </details> <details class="test passed"> <summary> <h3 class="title test-title"> <span class="status badge passed ">PASSED</span> <span class=test-name> <span class=funcname>ModifyOptionContractTest::test_modify_option_required_fields</span> </span> <span class=duration>0:00:00.043194</span> </h3> </summary> <div class=content> <table class=metadata> <tr> <th>Started</th> <td>2023-06-30 01:14:28</td> </tr> <tr> <th>Ended</th> <td>2023-06-30 01:14:28</td> </tr> <tr> <th>Duration</th> <td>0:00:00.043194</td> </tr> <tr> <th>Markers</th> <td> <div class=marker> <span class="marker-name badge">vcr</span> <span class=marker-args> </span> </div> <div class=marker> <span class="marker-name badge">unit_test</span> <span class=marker-args> </span> </div> </td> </tr> <tr> <th>Fixtures</th> <td> <span class="badge fixturename"> django_test_environment </span> <span class="badge fixturename"> django_db_blocker </span> <span class="badge fixturename"> request </span> </td> </tr> </table> <div class=test-phases> <details class="phase setup "> <summary> <h4 class=title> <span class=phase-name>Setup</span> </h4> </summary> <div class=content> </div> </details> <details class="phase call passed" open> <summary> <h4 class=title> <span class="status  passed"></span> <span class=phase-name>Call</span> </h4> </summary> <div class=content> </div> </details> <details class="phase teardown "> <summary> <h4 class=title> <span class=phase-name>Teardown</span> </h4> </summary> <div class=content> </div> </details> </div> </div> </details> <details class="test passed"> <summary> <h3 class="title test-title"> <span class="status badge passed ">PASSED</span> <span class=test-name> <span class=funcname>ModifyOptionContractTest::test_modify_option_sequence_used_more_than_once</span> </span> <span class=duration>0:00:00.057215</span> </h3> </summary> <div class=content> <table class=metadata> <tr> <th>Started</th> <td>2023-06-30 01:14:28</td> </tr> <tr> <th>Ended</th> <td>2023-06-30 01:14:29</td> </tr> <tr> <th>Duration</th> <td>0:00:00.057215</td> </tr> <tr> <th>Markers</th> <td> <div class=marker> <span class="marker-name badge">vcr</span> <span class=marker-args> </span> </div> <div class=marker> <span class="marker-name badge">unit_test</span> <span class=marker-args> </span> </div> </td> </tr> <tr> <th>Fixtures</th> <td> <span class="badge fixturename"> django_test_environment </span> <span class="badge fixturename"> django_db_blocker </span> <span class="badge fixturename"> request </span> </td> </tr> </table> <div class=test-phases> <details class="phase setup "> <summary> <h4 class=title> <span class=phase-name>Setup</span> </h4> </summary> <div class=content> </div> </details> <details class="phase call passed" open> <summary> <h4 class=title> <span class="status  passed"></span> <span class=phase-name>Call</span> </h4> </summary> <div class=content> </div> </details> <details class="phase teardown "> <summary> <h4 class=title> <span class=phase-name>Teardown</span> </h4> </summary> <div class=content> </div> </details> </div> </div> </details> <details class="test passed"> <summary> <h3 class="title test-title"> <span class="status badge passed ">PASSED</span> <span class=test-name> <span class=funcname>ModifyOptionContractTest::test_modify_option_validate_items_exists_in_catalog</span> </span> <span class=duration>0:00:00.051991</span> </h3> </summary> <div class=content> <table class=metadata> <tr> <th>Started</th> <td>2023-06-30 01:14:29</td> </tr> <tr> <th>Ended</th> <td>2023-06-30 01:14:29</td> </tr> <tr> <th>Duration</th> <td>0:00:00.051991</td> </tr> <tr> <th>Markers</th> <td> <div class=marker> <span class="marker-name badge">vcr</span> <span class=marker-args> </span> </div> <div class=marker> <span class="marker-name badge">unit_test</span> <span class=marker-args> </span> </div> </td> </tr> <tr> <th>Fixtures</th> <td> <span class="badge fixturename"> django_test_environment </span> <span class="badge fixturename"> django_db_blocker </span> <span class="badge fixturename"> request </span> </td> </tr> </table> <div class=test-phases> <details class="phase setup "> <summary> <h4 class=title> <span class=phase-name>Setup</span> </h4> </summary> <div class=content> </div> </details> <details class="phase call passed" open> <summary> <h4 class=title> <span class="status  passed"></span> <span class=phase-name>Call</span> </h4> </summary> <div class=content> </div> </details> <details class="phase teardown "> <summary> <h4 class=title> <span class=phase-name>Teardown</span> </h4> </summary> <div class=content> </div> </details> </div> </div> </details> <details class="test passed"> <summary> <h3 class="title test-title"> <span class="status badge passed ">PASSED</span> <span class=test-name> <span class=funcname>ModifyOptionContractTest::test_modify_option_validate_options_duplication</span> </span> <span class=duration>0:00:00.061803</span> </h3> </summary> <div class=content> <table class=metadata> <tr> <th>Started</th> <td>2023-06-30 01:14:29</td> </tr> <tr> <th>Ended</th> <td>2023-06-30 01:14:29</td> </tr> <tr> <th>Duration</th> <td>0:00:00.061803</td> </tr> <tr> <th>Markers</th> <td> <div class=marker> <span class="marker-name badge">vcr</span> <span class=marker-args> </span> </div> <div class=marker> <span class="marker-name badge">unit_test</span> <span class=marker-args> </span> </div> </td> </tr> <tr> <th>Fixtures</th> <td> <span class="badge fixturename"> django_test_environment </span> <span class="badge fixturename"> django_db_blocker </span> <span class="badge fixturename"> request </span> </td> </tr> </table> <div class=test-phases> <details class="phase setup "> <summary> <h4 class=title> <span class=phase-name>Setup</span> </h4> </summary> <div class=content> </div> </details> <details class="phase call passed" open> <summary> <h4 class=title> <span class="status  passed"></span> <span class=phase-name>Call</span> </h4> </summary> <div class=content> </div> </details> <details class="phase teardown "> <summary> <h4 class=title> <span class=phase-name>Teardown</span> </h4> </summary> <div class=content> </div> </details> </div> </div> </details> <details class="test passed"> <summary> <h3 class="title test-title"> <span class="status badge passed ">PASSED</span> <span class=test-name> <span class=funcname>ModifyOptionContractTest::test_modify_option_validate_options_normal</span> </span> <span class=duration>0:00:00.052480</span> </h3> </summary> <div class=content> <table class=metadata> <tr> <th>Started</th> <td>2023-06-30 01:14:29</td> </tr> <tr> <th>Ended</th> <td>2023-06-30 01:14:29</td> </tr> <tr> <th>Duration</th> <td>0:00:00.052480</td> </tr> <tr> <th>Markers</th> <td> <div class=marker> <span class="marker-name badge">vcr</span> <span class=marker-args> </span> </div> <div class=marker> <span class="marker-name badge">unit_test</span> <span class=marker-args> </span> </div> </td> </tr> <tr> <th>Fixtures</th> <td> <span class="badge fixturename"> django_test_environment </span> <span class="badge fixturename"> django_db_blocker </span> <span class="badge fixturename"> request </span> </td> </tr> </table> <div class=test-phases> <details class="phase setup "> <summary> <h4 class=title> <span class=phase-name>Setup</span> </h4> </summary> <div class=content> </div> </details> <details class="phase call passed" open> <summary> <h4 class=title> <span class="status  passed"></span> <span class=phase-name>Call</span> </h4> </summary> <div class=content> </div> </details> <details class="phase teardown "> <summary> <h4 class=title> <span class=phase-name>Teardown</span> </h4> </summary> <div class=content> </div> </details> </div> </div> </details> <details class="test passed"> <summary> <h3 class="title test-title"> <span class="status badge passed ">PASSED</span> <span class=test-name> <span class=funcname>ModifyOptionContractTest::test_modify_option_validate_options_sequence_number</span> </span> <span class=duration>0:00:00.064170</span> </h3> </summary> <div class=content> <div class=documentation> <p>Test add options with same sequence number</p> </div> <table class=metadata> <tr> <th>Started</th> <td>2023-06-30 01:14:29</td> </tr> <tr> <th>Ended</th> <td>2023-06-30 01:14:29</td> </tr> <tr> <th>Duration</th> <td>0:00:00.064170</td> </tr> <tr> <th>Markers</th> <td> <div class=marker> <span class="marker-name badge">vcr</span> <span class=marker-args> </span> </div> <div class=marker> <span class="marker-name badge">unit_test</span> <span class=marker-args> </span> </div> </td> </tr> <tr> <th>Fixtures</th> <td> <span class="badge fixturename"> django_test_environment </span> <span class="badge fixturename"> django_db_blocker </span> <span class="badge fixturename"> request </span> </td> </tr> </table> <div class=test-phases> <details class="phase setup "> <summary> <h4 class=title> <span class=phase-name>Setup</span> </h4> </summary> <div class=content> </div> </details> <details class="phase call passed" open> <summary> <h4 class=title> <span class="status  passed"></span> <span class=phase-name>Call</span> </h4> </summary> <div class=content> </div> </details> <details class="phase teardown "> <summary> <h4 class=title> <span class=phase-name>Teardown</span> </h4> </summary> <div class=content> </div> </details> </div> </div> </details> <details class="test passed"> <summary> <h3 class="title test-title"> <span class="status badge passed ">PASSED</span> <span class=test-name> <span class=funcname>ModifyOptionContractTest::test_modify_option_when_contract_not_found</span> </span> <span class=duration>0:00:00.047805</span> </h3> </summary> <div class=content> <table class=metadata> <tr> <th>Started</th> <td>2023-06-30 01:14:29</td> </tr> <tr> <th>Ended</th> <td>2023-06-30 01:14:29</td> </tr> <tr> <th>Duration</th> <td>0:00:00.047805</td> </tr> <tr> <th>Markers</th> <td> <div class=marker> <span class="marker-name badge">vcr</span> <span class=marker-args> </span> </div> <div class=marker> <span class="marker-name badge">unit_test</span> <span class=marker-args> </span> </div> </td> </tr> <tr> <th>Fixtures</th> <td> <span class="badge fixturename"> django_test_environment </span> <span class="badge fixturename"> django_db_blocker </span> <span class="badge fixturename"> request </span> </td> </tr> </table> <div class=test-phases> <details class="phase setup "> <summary> <h4 class=title> <span class=phase-name>Setup</span> </h4> </summary> <div class=content> </div> </details> <details class="phase call passed" open> <summary> <h4 class=title> <span class="status  passed"></span> <span class=phase-name>Call</span> </h4> </summary> <div class=content> </div> </details> <details class="phase teardown "> <summary> <h4 class=title> <span class=phase-name>Teardown</span> </h4> </summary> <div class=content> </div> </details> </div> </div> </details> <details class="test passed"> <summary> <h3 class="title test-title"> <span class="status badge passed ">PASSED</span> <span class=test-name> <span class=funcname>ModifyOptionContractTest::test_modify_option_when_contract_not_in_allowed_status</span> </span> <span class=duration>0:00:00.051831</span> </h3> </summary> <div class=content> <table class=metadata> <tr> <th>Started</th> <td>2023-06-30 01:14:29</td> </tr> <tr> <th>Ended</th> <td>2023-06-30 01:14:29</td> </tr> <tr> <th>Duration</th> <td>0:00:00.051831</td> </tr> <tr> <th>Markers</th> <td> <div class=marker> <span class="marker-name badge">vcr</span> <span class=marker-args> </span> </div> <div class=marker> <span class="marker-name badge">unit_test</span> <span class=marker-args> </span> </div> </td> </tr> <tr> <th>Fixtures</th> <td> <span class="badge fixturename"> django_test_environment </span> <span class="badge fixturename"> django_db_blocker </span> <span class="badge fixturename"> request </span> </td> </tr> </table> <div class=test-phases> <details class="phase setup "> <summary> <h4 class=title> <span class=phase-name>Setup</span> </h4> </summary> <div class=content> </div> </details> <details class="phase call passed" open> <summary> <h4 class=title> <span class="status  passed"></span> <span class=phase-name>Call</span> </h4> </summary> <div class=content> </div> </details> <details class="phase teardown "> <summary> <h4 class=title> <span class=phase-name>Teardown</span> </h4> </summary> <div class=content> </div> </details> </div> </div> </details> <details class="test passed"> <summary> <h3 class="title test-title"> <span class="status badge passed ">PASSED</span> <span class=test-name> <span class=funcname>ModifyOptionContractTest::test_modify_option_when_contract_without_items</span> </span> <span class=duration>0:00:00.048103</span> </h3> </summary> <div class=content> <table class=metadata> <tr> <th>Started</th> <td>2023-06-30 01:14:29</td> </tr> <tr> <th>Ended</th> <td>2023-06-30 01:14:29</td> </tr> <tr> <th>Duration</th> <td>0:00:00.048103</td> </tr> <tr> <th>Markers</th> <td> <div class=marker> <span class="marker-name badge">vcr</span> <span class=marker-args> </span> </div> <div class=marker> <span class="marker-name badge">unit_test</span> <span class=marker-args> </span> </div> </td> </tr> <tr> <th>Fixtures</th> <td> <span class="badge fixturename"> django_test_environment </span> <span class="badge fixturename"> django_db_blocker </span> <span class="badge fixturename"> request </span> </td> </tr> </table> <div class=test-phases> <details class="phase setup "> <summary> <h4 class=title> <span class=phase-name>Setup</span> </h4> </summary> <div class=content> </div> </details> <details class="phase call passed" open> <summary> <h4 class=title> <span class="status  passed"></span> <span class=phase-name>Call</span> </h4> </summary> <div class=content> </div> </details> <details class="phase teardown "> <summary> <h4 class=title> <span class=phase-name>Teardown</span> </h4> </summary> <div class=content> </div> </details> </div> </div> </details> <details class="test passed"> <summary> <h3 class="title test-title"> <span class="status badge passed ">PASSED</span> <span class=test-name> <span class=funcname>ModifyOptionContractTest::test_modify_option_with_missing_perms</span> </span> <span class=duration>0:00:00.243271</span> </h3> </summary> <div class=content> <table class=metadata> <tr> <th>Started</th> <td>2023-06-30 01:14:29</td> </tr> <tr> <th>Ended</th> <td>2023-06-30 01:14:29</td> </tr> <tr> <th>Duration</th> <td>0:00:00.243271</td> </tr> <tr> <th>Markers</th> <td> <div class=marker> <span class="marker-name badge">unit_test</span> <span class=marker-args> </span> </div> </td> </tr> <tr> <th>Fixtures</th> <td> <span class="badge fixturename"> django_test_environment </span> <span class="badge fixturename"> django_db_blocker </span> <span class="badge fixturename"> request </span> </td> </tr> </table> <div class=test-phases> <details class="phase setup "> <summary> <h4 class=title> <span class=phase-name>Setup</span> </h4> </summary> <div class=content> </div> </details> <details class="phase call passed" open> <summary> <h4 class=title> <span class="status  passed"></span> <span class=phase-name>Call</span> </h4> </summary> <div class=content> <div class=section> <h5 class=section-title>Captured log call</h5> <pre><samp>WARNING  django.request:log.py:241 Forbidden: /api/v0/contracts/sohnum/modify-option/</samp></pre> </div> </div> </details> <details class="phase teardown "> <summary> <h4 class=title> <span class=phase-name>Teardown</span> </h4> </summary> <div class=content> </div> </details> </div> </div> </details> </div> </details> <details class=file> <summary> <h2 class="title file-title"> <span class=fspath> app/api/tests/test_terminate_contract_serializer.py </span> <span class=counts> <span title="8 passed" class="count status badge passed ">8</span> </span> <span class=duration> 0:00:00.064987 </span> </h2> </summary> <div class="content box"> <details class="test passed"> <summary> <h3 class="title test-title"> <span class="status badge passed ">PASSED</span> <span class=test-name> <span class=funcname>TerminateContractTest::test_serializer_fields</span> </span> <span class=duration>0:00:00.025385</span> </h3> </summary> <div class=content> <table class=metadata> <tr> <th>Started</th> <td>2023-06-30 01:14:23</td> </tr> <tr> <th>Ended</th> <td>2023-06-30 01:14:23</td> </tr> <tr> <th>Duration</th> <td>0:00:00.025385</td> </tr> <tr> <th>Markers</th> <td> <div class=marker> <span class="marker-name badge">vcr</span> <span class=marker-args> </span> </div> <div class=marker> <span class="marker-name badge">unit_test</span> <span class=marker-args> </span> </div> </td> </tr> <tr> <th>Fixtures</th> <td> <span class="badge fixturename"> django_test_environment </span> <span class="badge fixturename"> django_db_blocker </span> <span class="badge fixturename"> request </span> </td> </tr> </table> <div class=test-phases> <details class="phase setup "> <summary> <h4 class=title> <span class=phase-name>Setup</span> </h4> </summary> <div class=content> </div> </details> <details class="phase call passed" open> <summary> <h4 class=title> <span class="status  passed"></span> <span class=phase-name>Call</span> </h4> </summary> <div class=content> </div> </details> <details class="phase teardown "> <summary> <h4 class=title> <span class=phase-name>Teardown</span> </h4> </summary> <div class=content> </div> </details> </div> </div> </details> <details class="test passed"> <summary> <h3 class="title test-title"> <span class="status badge passed ">PASSED</span> <span class=test-name> <span class=funcname>TerminateContractTest::test_serializer_order_additional_data</span> </span> <span class=duration>0:00:00.001870</span> </h3> </summary> <div class=content> <table class=metadata> <tr> <th>Started</th> <td>2023-06-30 01:14:23</td> </tr> <tr> <th>Ended</th> <td>2023-06-30 01:14:23</td> </tr> <tr> <th>Duration</th> <td>0:00:00.001870</td> </tr> <tr> <th>Markers</th> <td> <div class=marker> <span class="marker-name badge">unit_test</span> <span class=marker-args> </span> </div> </td> </tr> <tr> <th>Fixtures</th> <td> <span class="badge fixturename"> django_test_environment </span> <span class="badge fixturename"> django_db_blocker </span> <span class="badge fixturename"> request </span> </td> </tr> </table> <div class=test-phases> <details class="phase setup "> <summary> <h4 class=title> <span class=phase-name>Setup</span> </h4> </summary> <div class=content> </div> </details> <details class="phase call passed" open> <summary> <h4 class=title> <span class="status  passed"></span> <span class=phase-name>Call</span> </h4> </summary> <div class=content> </div> </details> <details class="phase teardown "> <summary> <h4 class=title> <span class=phase-name>Teardown</span> </h4> </summary> <div class=content> </div> </details> </div> </div> </details> <details class="test passed"> <summary> <h3 class="title test-title"> <span class="status badge passed ">PASSED</span> <span class=test-name> <span class=funcname>TerminateContractTest::test_serializer_order_different_order</span> </span> <span class=duration>0:00:00.001687</span> </h3> </summary> <div class=content> <table class=metadata> <tr> <th>Started</th> <td>2023-06-30 01:14:23</td> </tr> <tr> <th>Ended</th> <td>2023-06-30 01:14:23</td> </tr> <tr> <th>Duration</th> <td>0:00:00.001687</td> </tr> <tr> <th>Markers</th> <td> <div class=marker> <span class="marker-name badge">unit_test</span> <span class=marker-args> </span> </div> </td> </tr> <tr> <th>Fixtures</th> <td> <span class="badge fixturename"> django_test_environment </span> <span class="badge fixturename"> django_db_blocker </span> <span class="badge fixturename"> request </span> </td> </tr> </table> <div class=test-phases> <details class="phase setup "> <summary> <h4 class=title> <span class=phase-name>Setup</span> </h4> </summary> <div class=content> </div> </details> <details class="phase call passed" open> <summary> <h4 class=title> <span class="status  passed"></span> <span class=phase-name>Call</span> </h4> </summary> <div class=content> </div> </details> <details class="phase teardown "> <summary> <h4 class=title> <span class=phase-name>Teardown</span> </h4> </summary> <div class=content> </div> </details> </div> </div> </details> <details class="test passed"> <summary> <h3 class="title test-title"> <span class="status badge passed ">PASSED</span> <span class=test-name> <span class=funcname>TerminateContractTest::test_serializer_order_missing_data</span> </span> <span class=duration>0:00:00.001662</span> </h3> </summary> <div class=content> <table class=metadata> <tr> <th>Started</th> <td>2023-06-30 01:14:23</td> </tr> <tr> <th>Ended</th> <td>2023-06-30 01:14:23</td> </tr> <tr> <th>Duration</th> <td>0:00:00.001662</td> </tr> <tr> <th>Markers</th> <td> <div class=marker> <span class="marker-name badge">unit_test</span> <span class=marker-args> </span> </div> </td> </tr> <tr> <th>Fixtures</th> <td> <span class="badge fixturename"> django_test_environment </span> <span class="badge fixturename"> django_db_blocker </span> <span class="badge fixturename"> request </span> </td> </tr> </table> <div class=test-phases> <details class="phase setup "> <summary> <h4 class=title> <span class=phase-name>Setup</span> </h4> </summary> <div class=content> </div> </details> <details class="phase call passed" open> <summary> <h4 class=title> <span class="status  passed"></span> <span class=phase-name>Call</span> </h4> </summary> <div class=content> </div> </details> <details class="phase teardown "> <summary> <h4 class=title> <span class=phase-name>Teardown</span> </h4> </summary> <div class=content> </div> </details> </div> </div> </details> <details class="test passed"> <summary> <h3 class="title test-title"> <span class="status badge passed ">PASSED</span> <span class=test-name> <span class=funcname>TerminateContractTest::test_serializer_order_same_order</span> </span> <span class=duration>0:00:00.001620</span> </h3> </summary> <div class=content> <table class=metadata> <tr> <th>Started</th> <td>2023-06-30 01:14:23</td> </tr> <tr> <th>Ended</th> <td>2023-06-30 01:14:23</td> </tr> <tr> <th>Duration</th> <td>0:00:00.001620</td> </tr> <tr> <th>Markers</th> <td> <div class=marker> <span class="marker-name badge">unit_test</span> <span class=marker-args> </span> </div> </td> </tr> <tr> <th>Fixtures</th> <td> <span class="badge fixturename"> django_test_environment </span> <span class="badge fixturename"> django_db_blocker </span> <span class="badge fixturename"> request </span> </td> </tr> </table> <div class=test-phases> <details class="phase setup "> <summary> <h4 class=title> <span class=phase-name>Setup</span> </h4> </summary> <div class=content> </div> </details> <details class="phase call passed" open> <summary> <h4 class=title> <span class="status  passed"></span> <span class=phase-name>Call</span> </h4> </summary> <div class=content> </div> </details> <details class="phase teardown "> <summary> <h4 class=title> <span class=phase-name>Teardown</span> </h4> </summary> <div class=content> </div> </details> </div> </div> </details> <details class="test passed"> <summary> <h3 class="title test-title"> <span class="status badge passed ">PASSED</span> <span class=test-name> <span class=funcname>TerminateContractTest::test_terminate_when_contract_already_terminate</span> </span> <span class=duration>0:00:00.011205</span> </h3> </summary> <div class=content> <table class=metadata> <tr> <th>Started</th> <td>2023-06-30 01:14:23</td> </tr> <tr> <th>Ended</th> <td>2023-06-30 01:14:23</td> </tr> <tr> <th>Duration</th> <td>0:00:00.011205</td> </tr> <tr> <th>Markers</th> <td> <div class=marker> <span class="marker-name badge">vcr</span> <span class=marker-args> </span> </div> <div class=marker> <span class="marker-name badge">unit_test</span> <span class=marker-args> </span> </div> </td> </tr> <tr> <th>Fixtures</th> <td> <span class="badge fixturename"> django_test_environment </span> <span class="badge fixturename"> django_db_blocker </span> <span class="badge fixturename"> request </span> </td> </tr> </table> <div class=test-phases> <details class="phase setup "> <summary> <h4 class=title> <span class=phase-name>Setup</span> </h4> </summary> <div class=content> </div> </details> <details class="phase call passed" open> <summary> <h4 class=title> <span class="status  passed"></span> <span class=phase-name>Call</span> </h4> </summary> <div class=content> </div> </details> <details class="phase teardown "> <summary> <h4 class=title> <span class=phase-name>Teardown</span> </h4> </summary> <div class=content> </div> </details> </div> </div> </details> <details class="test passed"> <summary> <h3 class="title test-title"> <span class="status badge passed ">PASSED</span> <span class=test-name> <span class=funcname>TerminateContractTest::test_terminate_when_contract_not_activate</span> </span> <span class=duration>0:00:00.010504</span> </h3> </summary> <div class=content> <table class=metadata> <tr> <th>Started</th> <td>2023-06-30 01:14:23</td> </tr> <tr> <th>Ended</th> <td>2023-06-30 01:14:23</td> </tr> <tr> <th>Duration</th> <td>0:00:00.010504</td> </tr> <tr> <th>Markers</th> <td> <div class=marker> <span class="marker-name badge">vcr</span> <span class=marker-args> </span> </div> <div class=marker> <span class="marker-name badge">unit_test</span> <span class=marker-args> </span> </div> </td> </tr> <tr> <th>Fixtures</th> <td> <span class="badge fixturename"> django_test_environment </span> <span class="badge fixturename"> django_db_blocker </span> <span class="badge fixturename"> request </span> </td> </tr> </table> <div class=test-phases> <details class="phase setup "> <summary> <h4 class=title> <span class=phase-name>Setup</span> </h4> </summary> <div class=content> </div> </details> <details class="phase call passed" open> <summary> <h4 class=title> <span class="status  passed"></span> <span class=phase-name>Call</span> </h4> </summary> <div class=content> </div> </details> <details class="phase teardown "> <summary> <h4 class=title> <span class=phase-name>Teardown</span> </h4> </summary> <div class=content> </div> </details> </div> </div> </details> <details class="test passed"> <summary> <h3 class="title test-title"> <span class="status badge passed ">PASSED</span> <span class=test-name> <span class=funcname>TerminateContractTest::test_terminate_when_contract_not_found</span> </span> <span class=duration>0:00:00.011054</span> </h3> </summary> <div class=content> <table class=metadata> <tr> <th>Started</th> <td>2023-06-30 01:14:23</td> </tr> <tr> <th>Ended</th> <td>2023-06-30 01:14:23</td> </tr> <tr> <th>Duration</th> <td>0:00:00.011054</td> </tr> <tr> <th>Markers</th> <td> <div class=marker> <span class="marker-name badge">vcr</span> <span class=marker-args> </span> </div> <div class=marker> <span class="marker-name badge">unit_test</span> <span class=marker-args> </span> </div> </td> </tr> <tr> <th>Fixtures</th> <td> <span class="badge fixturename"> django_test_environment </span> <span class="badge fixturename"> django_db_blocker </span> <span class="badge fixturename"> request </span> </td> </tr> </table> <div class=test-phases> <details class="phase setup "> <summary> <h4 class=title> <span class=phase-name>Setup</span> </h4> </summary> <div class=content> </div> </details> <details class="phase call passed" open> <summary> <h4 class=title> <span class="status  passed"></span> <span class=phase-name>Call</span> </h4> </summary> <div class=content> </div> </details> <details class="phase teardown "> <summary> <h4 class=title> <span class=phase-name>Teardown</span> </h4> </summary> <div class=content> </div> </details> </div> </div> </details> </div> </details> <details class=file> <summary> <h2 class="title file-title"> <span class=fspath> app/api/tests/test_terminate_option_contract.py </span> <span class=counts> <span title="11 passed" class="count status badge passed ">11</span> </span> <span class=duration> 0:00:02.507908 </span> </h2> </summary> <div class="content box"> <details class="test passed"> <summary> <h3 class="title test-title"> <span class="status badge passed ">PASSED</span> <span class=test-name> <span class=funcname>TerminateOptionContractTest::test_terminate_option_contract_activated</span> </span> <span class=duration>0:00:01.015902</span> </h3> </summary> <div class=content> <table class=metadata> <tr> <th>Started</th> <td>2023-06-30 01:14:29</td> </tr> <tr> <th>Ended</th> <td>2023-06-30 01:14:30</td> </tr> <tr> <th>Duration</th> <td>0:00:01.015902</td> </tr> <tr> <th>Markers</th> <td> <div class=marker> <span class="marker-name badge">vcr</span> <span class=marker-args> before_record_request=&lt;function record_only_x3 at 0x7f34c31a49d0&gt; </span> </div> <div class=marker> <span class="marker-name badge">unit_test</span> <span class=marker-args> </span> </div> </td> </tr> <tr> <th>Fixtures</th> <td> <span class="badge fixturename"> django_test_environment </span> <span class="badge fixturename"> django_db_blocker </span> <span class="badge fixturename"> request </span> </td> </tr> </table> <div class=test-phases> <details class="phase setup "> <summary> <h4 class=title> <span class=phase-name>Setup</span> </h4> </summary> <div class=content> </div> </details> <details class="phase call passed" open> <summary> <h4 class=title> <span class="status  passed"></span> <span class=phase-name>Call</span> </h4> </summary> <div class=content> </div> </details> <details class="phase teardown "> <summary> <h4 class=title> <span class=phase-name>Teardown</span> </h4> </summary> <div class=content> </div> </details> </div> </div> </details> <details class="test passed"> <summary> <h3 class="title test-title"> <span class="status badge passed ">PASSED</span> <span class=test-name> <span class=funcname>TerminateOptionContractTest::test_terminate_option_multiple_options</span> </span> <span class=duration>0:00:00.052714</span> </h3> </summary> <div class=content> <table class=metadata> <tr> <th>Started</th> <td>2023-06-30 01:14:30</td> </tr> <tr> <th>Ended</th> <td>2023-06-30 01:14:30</td> </tr> <tr> <th>Duration</th> <td>0:00:00.052714</td> </tr> <tr> <th>Markers</th> <td> <div class=marker> <span class="marker-name badge">vcr</span> <span class=marker-args> before_record_request=&lt;function record_only_x3 at 0x7f34c31a49d0&gt; </span> </div> <div class=marker> <span class="marker-name badge">unit_test</span> <span class=marker-args> </span> </div> </td> </tr> <tr> <th>Fixtures</th> <td> <span class="badge fixturename"> django_test_environment </span> <span class="badge fixturename"> django_db_blocker </span> <span class="badge fixturename"> request </span> </td> </tr> </table> <div class=test-phases> <details class="phase setup "> <summary> <h4 class=title> <span class=phase-name>Setup</span> </h4> </summary> <div class=content> </div> </details> <details class="phase call passed" open> <summary> <h4 class=title> <span class="status  passed"></span> <span class=phase-name>Call</span> </h4> </summary> <div class=content> </div> </details> <details class="phase teardown "> <summary> <h4 class=title> <span class=phase-name>Teardown</span> </h4> </summary> <div class=content> </div> </details> </div> </div> </details> <details class="test passed"> <summary> <h3 class="title test-title"> <span class="status badge passed ">PASSED</span> <span class=test-name> <span class=funcname>TerminateOptionContractTest::test_terminate_option_required_fields</span> </span> <span class=duration>0:00:00.132208</span> </h3> </summary> <div class=content> <table class=metadata> <tr> <th>Started</th> <td>2023-06-30 01:14:30</td> </tr> <tr> <th>Ended</th> <td>2023-06-30 01:14:30</td> </tr> <tr> <th>Duration</th> <td>0:00:00.132208</td> </tr> <tr> <th>Markers</th> <td> <div class=marker> <span class="marker-name badge">vcr</span> <span class=marker-args> before_record_request=&lt;function record_only_x3 at 0x7f34c31a49d0&gt; </span> </div> <div class=marker> <span class="marker-name badge">unit_test</span> <span class=marker-args> </span> </div> </td> </tr> <tr> <th>Fixtures</th> <td> <span class="badge fixturename"> django_test_environment </span> <span class="badge fixturename"> django_db_blocker </span> <span class="badge fixturename"> request </span> </td> </tr> </table> <div class=test-phases> <details class="phase setup "> <summary> <h4 class=title> <span class=phase-name>Setup</span> </h4> </summary> <div class=content> </div> </details> <details class="phase call passed" open> <summary> <h4 class=title> <span class="status  passed"></span> <span class=phase-name>Call</span> </h4> </summary> <div class=content> </div> </details> <details class="phase teardown "> <summary> <h4 class=title> <span class=phase-name>Teardown</span> </h4> </summary> <div class=content> </div> </details> </div> </div> </details> <details class="test passed"> <summary> <h3 class="title test-title"> <span class="status badge passed ">PASSED</span> <span class=test-name> <span class=funcname>TerminateOptionContractTest::test_terminate_option_validate_item_already_terminated</span> </span> <span class=duration>0:00:00.052224</span> </h3> </summary> <div class=content> <table class=metadata> <tr> <th>Started</th> <td>2023-06-30 01:14:30</td> </tr> <tr> <th>Ended</th> <td>2023-06-30 01:14:30</td> </tr> <tr> <th>Duration</th> <td>0:00:00.052224</td> </tr> <tr> <th>Markers</th> <td> <div class=marker> <span class="marker-name badge">vcr</span> <span class=marker-args> before_record_request=&lt;function record_only_x3 at 0x7f34c31a49d0&gt; </span> </div> <div class=marker> <span class="marker-name badge">unit_test</span> <span class=marker-args> </span> </div> </td> </tr> <tr> <th>Fixtures</th> <td> <span class="badge fixturename"> django_test_environment </span> <span class="badge fixturename"> django_db_blocker </span> <span class="badge fixturename"> request </span> </td> </tr> </table> <div class=test-phases> <details class="phase setup "> <summary> <h4 class=title> <span class=phase-name>Setup</span> </h4> </summary> <div class=content> </div> </details> <details class="phase call passed" open> <summary> <h4 class=title> <span class="status  passed"></span> <span class=phase-name>Call</span> </h4> </summary> <div class=content> </div> </details> <details class="phase teardown "> <summary> <h4 class=title> <span class=phase-name>Teardown</span> </h4> </summary> <div class=content> </div> </details> </div> </div> </details> <details class="test passed"> <summary> <h3 class="title test-title"> <span class="status badge passed ">PASSED</span> <span class=test-name> <span class=funcname>TerminateOptionContractTest::test_terminate_option_validate_item_exists_in_contract</span> </span> <span class=duration>0:00:00.796336</span> </h3> </summary> <div class=content> <table class=metadata> <tr> <th>Started</th> <td>2023-06-30 01:14:30</td> </tr> <tr> <th>Ended</th> <td>2023-06-30 01:14:31</td> </tr> <tr> <th>Duration</th> <td>0:00:00.796336</td> </tr> <tr> <th>Markers</th> <td> <div class=marker> <span class="marker-name badge">vcr</span> <span class=marker-args> before_record_request=&lt;function record_only_x3 at 0x7f34c31a49d0&gt; </span> </div> <div class=marker> <span class="marker-name badge">unit_test</span> <span class=marker-args> </span> </div> </td> </tr> <tr> <th>Fixtures</th> <td> <span class="badge fixturename"> django_test_environment </span> <span class="badge fixturename"> django_db_blocker </span> <span class="badge fixturename"> request </span> </td> </tr> </table> <div class=test-phases> <details class="phase setup "> <summary> <h4 class=title> <span class=phase-name>Setup</span> </h4> </summary> <div class=content> </div> </details> <details class="phase call passed" open> <summary> <h4 class=title> <span class="status  passed"></span> <span class=phase-name>Call</span> </h4> </summary> <div class=content> </div> </details> <details class="phase teardown "> <summary> <h4 class=title> <span class=phase-name>Teardown</span> </h4> </summary> <div class=content> </div> </details> </div> </div> </details> <details class="test passed"> <summary> <h3 class="title test-title"> <span class="status badge passed ">PASSED</span> <span class=test-name> <span class=funcname>TerminateOptionContractTest::test_terminate_option_validate_normal_and_variant</span> </span> <span class=duration>0:00:00.062855</span> </h3> </summary> <div class=content> <table class=metadata> <tr> <th>Started</th> <td>2023-06-30 01:14:31</td> </tr> <tr> <th>Ended</th> <td>2023-06-30 01:14:31</td> </tr> <tr> <th>Duration</th> <td>0:00:00.062855</td> </tr> <tr> <th>Markers</th> <td> <div class=marker> <span class="marker-name badge">vcr</span> <span class=marker-args> before_record_request=&lt;function record_only_x3 at 0x7f34c31a49d0&gt; </span> </div> <div class=marker> <span class="marker-name badge">unit_test</span> <span class=marker-args> </span> </div> </td> </tr> <tr> <th>Fixtures</th> <td> <span class="badge fixturename"> django_test_environment </span> <span class="badge fixturename"> django_db_blocker </span> <span class="badge fixturename"> request </span> </td> </tr> </table> <div class=test-phases> <details class="phase setup "> <summary> <h4 class=title> <span class=phase-name>Setup</span> </h4> </summary> <div class=content> </div> </details> <details class="phase call passed" open> <summary> <h4 class=title> <span class="status  passed"></span> <span class=phase-name>Call</span> </h4> </summary> <div class=content> </div> </details> <details class="phase teardown "> <summary> <h4 class=title> <span class=phase-name>Teardown</span> </h4> </summary> <div class=content> </div> </details> </div> </div> </details> <details class="test passed"> <summary> <h3 class="title test-title"> <span class="status badge passed ">PASSED</span> <span class=test-name> <span class=funcname>TerminateOptionContractTest::test_terminate_option_validate_options_duplication</span> </span> <span class=duration>0:00:00.051243</span> </h3> </summary> <div class=content> <table class=metadata> <tr> <th>Started</th> <td>2023-06-30 01:14:31</td> </tr> <tr> <th>Ended</th> <td>2023-06-30 01:14:31</td> </tr> <tr> <th>Duration</th> <td>0:00:00.051243</td> </tr> <tr> <th>Markers</th> <td> <div class=marker> <span class="marker-name badge">vcr</span> <span class=marker-args> before_record_request=&lt;function record_only_x3 at 0x7f34c31a49d0&gt; </span> </div> <div class=marker> <span class="marker-name badge">unit_test</span> <span class=marker-args> </span> </div> </td> </tr> <tr> <th>Fixtures</th> <td> <span class="badge fixturename"> django_test_environment </span> <span class="badge fixturename"> django_db_blocker </span> <span class="badge fixturename"> request </span> </td> </tr> </table> <div class=test-phases> <details class="phase setup "> <summary> <h4 class=title> <span class=phase-name>Setup</span> </h4> </summary> <div class=content> </div> </details> <details class="phase call passed" open> <summary> <h4 class=title> <span class="status  passed"></span> <span class=phase-name>Call</span> </h4> </summary> <div class=content> </div> </details> <details class="phase teardown "> <summary> <h4 class=title> <span class=phase-name>Teardown</span> </h4> </summary> <div class=content> </div> </details> </div> </div> </details> <details class="test passed"> <summary> <h3 class="title test-title"> <span class="status badge passed ">PASSED</span> <span class=test-name> <span class=funcname>TerminateOptionContractTest::test_terminate_option_when_contract_not_found</span> </span> <span class=duration>0:00:00.046730</span> </h3> </summary> <div class=content> <table class=metadata> <tr> <th>Started</th> <td>2023-06-30 01:14:31</td> </tr> <tr> <th>Ended</th> <td>2023-06-30 01:14:31</td> </tr> <tr> <th>Duration</th> <td>0:00:00.046730</td> </tr> <tr> <th>Markers</th> <td> <div class=marker> <span class="marker-name badge">vcr</span> <span class=marker-args> before_record_request=&lt;function record_only_x3 at 0x7f34c31a49d0&gt; </span> </div> <div class=marker> <span class="marker-name badge">unit_test</span> <span class=marker-args> </span> </div> </td> </tr> <tr> <th>Fixtures</th> <td> <span class="badge fixturename"> django_test_environment </span> <span class="badge fixturename"> django_db_blocker </span> <span class="badge fixturename"> request </span> </td> </tr> </table> <div class=test-phases> <details class="phase setup "> <summary> <h4 class=title> <span class=phase-name>Setup</span> </h4> </summary> <div class=content> </div> </details> <details class="phase call passed" open> <summary> <h4 class=title> <span class="status  passed"></span> <span class=phase-name>Call</span> </h4> </summary> <div class=content> </div> </details> <details class="phase teardown "> <summary> <h4 class=title> <span class=phase-name>Teardown</span> </h4> </summary> <div class=content> </div> </details> </div> </div> </details> <details class="test passed"> <summary> <h3 class="title test-title"> <span class="status badge passed ">PASSED</span> <span class=test-name> <span class=funcname>TerminateOptionContractTest::test_terminate_option_when_contract_not_in_allowed_status</span> </span> <span class=duration>0:00:00.049048</span> </h3> </summary> <div class=content> <table class=metadata> <tr> <th>Started</th> <td>2023-06-30 01:14:31</td> </tr> <tr> <th>Ended</th> <td>2023-06-30 01:14:31</td> </tr> <tr> <th>Duration</th> <td>0:00:00.049048</td> </tr> <tr> <th>Markers</th> <td> <div class=marker> <span class="marker-name badge">vcr</span> <span class=marker-args> before_record_request=&lt;function record_only_x3 at 0x7f34c31a49d0&gt; </span> </div> <div class=marker> <span class="marker-name badge">unit_test</span> <span class=marker-args> </span> </div> </td> </tr> <tr> <th>Fixtures</th> <td> <span class="badge fixturename"> django_test_environment </span> <span class="badge fixturename"> django_db_blocker </span> <span class="badge fixturename"> request </span> </td> </tr> </table> <div class=test-phases> <details class="phase setup "> <summary> <h4 class=title> <span class=phase-name>Setup</span> </h4> </summary> <div class=content> </div> </details> <details class="phase call passed" open> <summary> <h4 class=title> <span class="status  passed"></span> <span class=phase-name>Call</span> </h4> </summary> <div class=content> </div> </details> <details class="phase teardown "> <summary> <h4 class=title> <span class=phase-name>Teardown</span> </h4> </summary> <div class=content> </div> </details> </div> </div> </details> <details class="test passed"> <summary> <h3 class="title test-title"> <span class="status badge passed ">PASSED</span> <span class=test-name> <span class=funcname>TerminateOptionContractTest::test_terminate_option_when_contract_without_items</span> </span> <span class=duration>0:00:00.047856</span> </h3> </summary> <div class=content> <table class=metadata> <tr> <th>Started</th> <td>2023-06-30 01:14:31</td> </tr> <tr> <th>Ended</th> <td>2023-06-30 01:14:32</td> </tr> <tr> <th>Duration</th> <td>0:00:00.047856</td> </tr> <tr> <th>Markers</th> <td> <div class=marker> <span class="marker-name badge">vcr</span> <span class=marker-args> before_record_request=&lt;function record_only_x3 at 0x7f34c31a49d0&gt; </span> </div> <div class=marker> <span class="marker-name badge">unit_test</span> <span class=marker-args> </span> </div> </td> </tr> <tr> <th>Fixtures</th> <td> <span class="badge fixturename"> django_test_environment </span> <span class="badge fixturename"> django_db_blocker </span> <span class="badge fixturename"> request </span> </td> </tr> </table> <div class=test-phases> <details class="phase setup "> <summary> <h4 class=title> <span class=phase-name>Setup</span> </h4> </summary> <div class=content> </div> </details> <details class="phase call passed" open> <summary> <h4 class=title> <span class="status  passed"></span> <span class=phase-name>Call</span> </h4> </summary> <div class=content> </div> </details> <details class="phase teardown "> <summary> <h4 class=title> <span class=phase-name>Teardown</span> </h4> </summary> <div class=content> </div> </details> </div> </div> </details> <details class="test passed"> <summary> <h3 class="title test-title"> <span class="status badge passed ">PASSED</span> <span class=test-name> <span class=funcname>TerminateOptionContractTest::test_terminate_option_with_missing_perms</span> </span> <span class=duration>0:00:00.200791</span> </h3> </summary> <div class=content> <table class=metadata> <tr> <th>Started</th> <td>2023-06-30 01:14:32</td> </tr> <tr> <th>Ended</th> <td>2023-06-30 01:14:32</td> </tr> <tr> <th>Duration</th> <td>0:00:00.200791</td> </tr> <tr> <th>Markers</th> <td> <div class=marker> <span class="marker-name badge">unit_test</span> <span class=marker-args> </span> </div> </td> </tr> <tr> <th>Fixtures</th> <td> <span class="badge fixturename"> django_test_environment </span> <span class="badge fixturename"> django_db_blocker </span> <span class="badge fixturename"> request </span> </td> </tr> </table> <div class=test-phases> <details class="phase setup "> <summary> <h4 class=title> <span class=phase-name>Setup</span> </h4> </summary> <div class=content> </div> </details> <details class="phase call passed" open> <summary> <h4 class=title> <span class="status  passed"></span> <span class=phase-name>Call</span> </h4> </summary> <div class=content> <div class=section> <h5 class=section-title>Captured log call</h5> <pre><samp>WARNING  django.request:log.py:241 Forbidden: /api/v0/contracts/sohnum/terminate-option/</samp></pre> </div> </div> </details> <details class="phase teardown "> <summary> <h4 class=title> <span class=phase-name>Teardown</span> </h4> </summary> <div class=content> </div> </details> </div> </div> </details> </div> </details> <details class=file> <summary> <h2 class="title file-title"> <span class=fspath> app/core/tests.py </span> <span class=counts> <span title="2 passed" class="count status badge passed ">2</span> </span> <span class=duration> 0:00:00.009364 </span> </h2> </summary> <div class="content box"> <details class="test passed"> <summary> <h3 class="title test-title"> <span class="status badge passed ">PASSED</span> <span class=test-name> <span class=funcname>SettingsTest::test_append_slash_enabled</span> </span> <span class=duration>0:00:00.006894</span> </h3> </summary> <div class=content> <div class=documentation> <dl class=simple> <dt>Ensure <cite>APPEND_SLASH</cite> behaviour is enabled.</dt> <dd><p>-&gt; This adds a slash if url is not found.</p> </dd> </dl> </div> <table class=metadata> <tr> <th>Started</th> <td>2023-06-30 01:14:23</td> </tr> <tr> <th>Ended</th> <td>2023-06-30 01:14:23</td> </tr> <tr> <th>Duration</th> <td>0:00:00.006894</td> </tr> <tr> <th>Markers</th> <td> <div class=marker> <span class="marker-name badge">unit_test</span> <span class=marker-args> </span> </div> </td> </tr> <tr> <th>Fixtures</th> <td> <span class="badge fixturename"> django_test_environment </span> <span class="badge fixturename"> django_db_blocker </span> <span class="badge fixturename"> request </span> </td> </tr> </table> <div class=test-phases> <details class="phase setup "> <summary> <h4 class=title> <span class=phase-name>Setup</span> </h4> </summary> <div class=content> </div> </details> <details class="phase call passed" open> <summary> <h4 class=title> <span class="status  passed"></span> <span class=phase-name>Call</span> </h4> </summary> <div class=content> </div> </details> <details class="phase teardown "> <summary> <h4 class=title> <span class=phase-name>Teardown</span> </h4> </summary> <div class=content> </div> </details> </div> </div> </details> <details class="test passed"> <summary> <h3 class="title test-title"> <span class="status badge passed ">PASSED</span> <span class=test-name> <span class=funcname>SettingsTest::test_handles_request_sgi</span> </span> <span class=duration>0:00:00.002471</span> </h3> </summary> <div class=content> <table class=metadata> <tr> <th>Started</th> <td>2023-06-30 01:14:23</td> </tr> <tr> <th>Ended</th> <td>2023-06-30 01:14:23</td> </tr> <tr> <th>Duration</th> <td>0:00:00.002471</td> </tr> <tr> <th>Markers</th> <td> <div class=marker> <span class="marker-name badge">unit_test</span> <span class=marker-args> </span> </div> </td> </tr> <tr> <th>Fixtures</th> <td> <span class="badge fixturename"> django_test_environment </span> <span class="badge fixturename"> django_db_blocker </span> <span class="badge fixturename"> request </span> </td> </tr> </table> <div class=test-phases> <details class="phase setup "> <summary> <h4 class=title> <span class=phase-name>Setup</span> </h4> </summary> <div class=content> </div> </details> <details class="phase call passed" open> <summary> <h4 class=title> <span class="status  passed"></span> <span class=phase-name>Call</span> </h4> </summary> <div class=content> </div> </details> <details class="phase teardown "> <summary> <h4 class=title> <span class=phase-name>Teardown</span> </h4> </summary> <div class=content> </div> </details> </div> </div> </details> </div> </details> <details class=file> <summary> <h2 class="title file-title"> <span class=fspath> app/users/tests/test_azure_active_directory.py </span> <span class=counts> <span title="4 passed" class="count status badge passed ">4</span> </span> <span class=duration> 0:00:00.506862 </span> </h2> </summary> <div class="content box"> <details class="test passed"> <summary> <h3 class="title test-title"> <span class="status badge passed ">PASSED</span> <span class=test-name> <span class=funcname>UserAzureADTest::test_azure_ad_authenticate</span> </span> <span class=duration>0:00:00.080915</span> </h3> </summary> <div class=content> <table class=metadata> <tr> <th>Started</th> <td>2023-06-30 01:14:32</td> </tr> <tr> <th>Ended</th> <td>2023-06-30 01:14:32</td> </tr> <tr> <th>Duration</th> <td>0:00:00.080915</td> </tr> <tr> <th>Markers</th> <td> <div class=marker> <span class="marker-name badge">unit_test</span> <span class=marker-args> </span> </div> </td> </tr> <tr> <th>Fixtures</th> <td> <span class="badge fixturename"> django_test_environment </span> <span class="badge fixturename"> django_db_blocker </span> <span class="badge fixturename"> request </span> </td> </tr> </table> <div class=test-phases> <details class="phase setup "> <summary> <h4 class=title> <span class=phase-name>Setup</span> </h4> </summary> <div class=content> </div> </details> <details class="phase call passed" open> <summary> <h4 class=title> <span class="status  passed"></span> <span class=phase-name>Call</span> </h4> </summary> <div class=content> </div> </details> <details class="phase teardown "> <summary> <h4 class=title> <span class=phase-name>Teardown</span> </h4> </summary> <div class=content> </div> </details> </div> </div> </details> <details class="test passed"> <summary> <h3 class="title test-title"> <span class="status badge passed ">PASSED</span> <span class=test-name> <span class=funcname>UserAzureADTest::test_azure_ad_callback</span> </span> <span class=duration>0:00:00.089754</span> </h3> </summary> <div class=content> <table class=metadata> <tr> <th>Started</th> <td>2023-06-30 01:14:32</td> </tr> <tr> <th>Ended</th> <td>2023-06-30 01:14:32</td> </tr> <tr> <th>Duration</th> <td>0:00:00.089754</td> </tr> <tr> <th>Markers</th> <td> <div class=marker> <span class="marker-name badge">vcr</span> <span class=marker-args> </span> </div> <div class=marker> <span class="marker-name badge">unit_test</span> <span class=marker-args> </span> </div> </td> </tr> <tr> <th>Fixtures</th> <td> <span class="badge fixturename"> django_test_environment </span> <span class="badge fixturename"> django_db_blocker </span> <span class="badge fixturename"> request </span> </td> </tr> </table> <div class=test-phases> <details class="phase setup "> <summary> <h4 class=title> <span class=phase-name>Setup</span> </h4> </summary> <div class=content> </div> </details> <details class="phase call passed" open> <summary> <h4 class=title> <span class="status  passed"></span> <span class=phase-name>Call</span> </h4> </summary> <div class=content> </div> </details> <details class="phase teardown "> <summary> <h4 class=title> <span class=phase-name>Teardown</span> </h4> </summary> <div class=content> </div> </details> </div> </div> </details> <details class="test passed"> <summary> <h3 class="title test-title"> <span class="status badge passed ">PASSED</span> <span class=test-name> <span class=funcname>UserAzureADTest::test_azure_ad_callback_with_user_email_already_exists</span> </span> <span class=duration>0:00:00.086823</span> </h3> </summary> <div class=content> <table class=metadata> <tr> <th>Started</th> <td>2023-06-30 01:14:32</td> </tr> <tr> <th>Ended</th> <td>2023-06-30 01:14:32</td> </tr> <tr> <th>Duration</th> <td>0:00:00.086823</td> </tr> <tr> <th>Markers</th> <td> <div class=marker> <span class="marker-name badge">vcr</span> <span class=marker-args> </span> </div> <div class=marker> <span class="marker-name badge">unit_test</span> <span class=marker-args> </span> </div> </td> </tr> <tr> <th>Fixtures</th> <td> <span class="badge fixturename"> django_test_environment </span> <span class="badge fixturename"> django_db_blocker </span> <span class="badge fixturename"> request </span> </td> </tr> </table> <div class=test-phases> <details class="phase setup "> <summary> <h4 class=title> <span class=phase-name>Setup</span> </h4> </summary> <div class=content> </div> </details> <details class="phase call passed" open> <summary> <h4 class=title> <span class="status  passed"></span> <span class=phase-name>Call</span> </h4> </summary> <div class=content> </div> </details> <details class="phase teardown "> <summary> <h4 class=title> <span class=phase-name>Teardown</span> </h4> </summary> <div class=content> </div> </details> </div> </div> </details> <details class="test passed"> <summary> <h3 class="title test-title"> <span class="status badge passed ">PASSED</span> <span class=test-name> <span class=funcname>UserAzureADTest::test_azure_ad_callback_with_wrong_state</span> </span> <span class=duration>0:00:00.249369</span> </h3> </summary> <div class=content> <table class=metadata> <tr> <th>Started</th> <td>2023-06-30 01:14:32</td> </tr> <tr> <th>Ended</th> <td>2023-06-30 01:14:32</td> </tr> <tr> <th>Duration</th> <td>0:00:00.249369</td> </tr> <tr> <th>Markers</th> <td> <div class=marker> <span class="marker-name badge">unit_test</span> <span class=marker-args> </span> </div> </td> </tr> <tr> <th>Fixtures</th> <td> <span class="badge fixturename"> django_test_environment </span> <span class="badge fixturename"> django_db_blocker </span> <span class="badge fixturename"> request </span> </td> </tr> </table> <div class=test-phases> <details class="phase setup "> <summary> <h4 class=title> <span class=phase-name>Setup</span> </h4> </summary> <div class=content> </div> </details> <details class="phase call passed" open> <summary> <h4 class=title> <span class="status  passed"></span> <span class=phase-name>Call</span> </h4> </summary> <div class=content> <div class=section> <h5 class=section-title>Captured log call</h5> <pre><samp>WARNING  django.request:log.py:241 Bad Request: /ad/callback/</samp></pre> </div> </div> </details> <details class="phase teardown "> <summary> <h4 class=title> <span class=phase-name>Teardown</span> </h4> </summary> <div class=content> </div> </details> </div> </div> </details> </div> </details> <details class=file> <summary> <h2 class="title file-title"> <span class=fspath> app/users/tests/test_user_info.py </span> <span class=counts> <span title="3 passed" class="count status badge passed ">3</span> </span> <span class=duration> 0:00:00.505227 </span> </h2> </summary> <div class="content box"> <details class="test passed"> <summary> <h3 class="title test-title"> <span class="status badge passed ">PASSED</span> <span class=test-name> <span class=funcname>UserInfoTest::test_user_info_with_bad_token</span> </span> <span class=duration>0:00:00.046598</span> </h3> </summary> <div class=content> <table class=metadata> <tr> <th>Started</th> <td>2023-06-30 01:14:32</td> </tr> <tr> <th>Ended</th> <td>2023-06-30 01:14:32</td> </tr> <tr> <th>Duration</th> <td>0:00:00.046598</td> </tr> <tr> <th>Markers</th> <td> <div class=marker> <span class="marker-name badge">unit_test</span> <span class=marker-args> </span> </div> </td> </tr> <tr> <th>Fixtures</th> <td> <span class="badge fixturename"> django_test_environment </span> <span class="badge fixturename"> django_db_blocker </span> <span class="badge fixturename"> request </span> </td> </tr> </table> <div class=test-phases> <details class="phase setup "> <summary> <h4 class=title> <span class=phase-name>Setup</span> </h4> </summary> <div class=content> </div> </details> <details class="phase call passed" open> <summary> <h4 class=title> <span class="status  passed"></span> <span class=phase-name>Call</span> </h4> </summary> <div class=content> <div class=section> <h5 class=section-title>Captured log call</h5> <pre><samp>WARNING  django.request:log.py:241 Unauthorized: /api/v0/users/me/</samp></pre> </div> </div> </details> <details class="phase teardown "> <summary> <h4 class=title> <span class=phase-name>Teardown</span> </h4> </summary> <div class=content> </div> </details> </div> </div> </details> <details class="test passed"> <summary> <h3 class="title test-title"> <span class="status badge passed ">PASSED</span> <span class=test-name> <span class=funcname>UserInfoTest::test_user_info_with_token</span> </span> <span class=duration>0:00:00.043707</span> </h3> </summary> <div class=content> <table class=metadata> <tr> <th>Started</th> <td>2023-06-30 01:14:32</td> </tr> <tr> <th>Ended</th> <td>2023-06-30 01:14:32</td> </tr> <tr> <th>Duration</th> <td>0:00:00.043707</td> </tr> <tr> <th>Markers</th> <td> <div class=marker> <span class="marker-name badge">unit_test</span> <span class=marker-args> </span> </div> </td> </tr> <tr> <th>Fixtures</th> <td> <span class="badge fixturename"> django_test_environment </span> <span class="badge fixturename"> django_db_blocker </span> <span class="badge fixturename"> request </span> </td> </tr> </table> <div class=test-phases> <details class="phase setup "> <summary> <h4 class=title> <span class=phase-name>Setup</span> </h4> </summary> <div class=content> </div> </details> <details class="phase call passed" open> <summary> <h4 class=title> <span class="status  passed"></span> <span class=phase-name>Call</span> </h4> </summary> <div class=content> </div> </details> <details class="phase teardown "> <summary> <h4 class=title> <span class=phase-name>Teardown</span> </h4> </summary> <div class=content> </div> </details> </div> </div> </details> <details class="test passed"> <summary> <h3 class="title test-title"> <span class="status badge passed ">PASSED</span> <span class=test-name> <span class=funcname>UserInfoTest::test_user_info_without_token</span> </span> <span class=duration>0:00:00.414921</span> </h3> </summary> <div class=content> <table class=metadata> <tr> <th>Started</th> <td>2023-06-30 01:14:32</td> </tr> <tr> <th>Ended</th> <td>2023-06-30 01:14:33</td> </tr> <tr> <th>Duration</th> <td>0:00:00.414921</td> </tr> <tr> <th>Markers</th> <td> <div class=marker> <span class="marker-name badge">unit_test</span> <span class=marker-args> </span> </div> </td> </tr> <tr> <th>Fixtures</th> <td> <span class="badge fixturename"> django_test_environment </span> <span class="badge fixturename"> django_db_blocker </span> <span class="badge fixturename"> request </span> </td> </tr> </table> <div class=test-phases> <details class="phase setup "> <summary> <h4 class=title> <span class=phase-name>Setup</span> </h4> </summary> <div class=content> </div> </details> <details class="phase call passed" open> <summary> <h4 class=title> <span class="status  passed"></span> <span class=phase-name>Call</span> </h4> </summary> <div class=content> <div class=section> <h5 class=section-title>Captured log call</h5> <pre><samp>WARNING  django.request:log.py:241 Unauthorized: /api/v0/users/me/</samp></pre> </div> </div> </details> <details class="phase teardown "> <summary> <h4 class=title> <span class=phase-name>Teardown</span> </h4> </summary> <div class=content> </div> </details> </div> </div> </details> </div> </details> <details class=file> <summary> <h2 class="title file-title"> <span class=fspath> app/x3_wrapper/tests/test_rest_client.py </span> <span class=counts> <span title="8 passed" class="count status badge passed ">8</span> </span> <span class=duration> 0:00:01.321714 </span> </h2> </summary> <div class="content box"> <details class="test passed"> <summary> <h3 class="title test-title"> <span class="status badge passed ">PASSED</span> <span class=test-name> <span class=funcname>TestRestClient::test_get_list_customer</span> </span> <span class=duration>0:00:00.012427</span> </h3> </summary> <div class=content> <table class=metadata> <tr> <th>Started</th> <td>2023-06-30 01:14:57</td> </tr> <tr> <th>Ended</th> <td>2023-06-30 01:14:57</td> </tr> <tr> <th>Duration</th> <td>0:00:00.012427</td> </tr> <tr> <th>Markers</th> <td> <div class=marker> <span class="marker-name badge">vcr</span> <span class=marker-args> </span> </div> <div class=marker> <span class="marker-name badge">unit_test</span> <span class=marker-args> </span> </div> </td> </tr> <tr> <th>Fixtures</th> <td> <span class="badge fixturename"> django_test_environment </span> <span class="badge fixturename"> django_db_blocker </span> <span class="badge fixturename"> vcr </span> <span class="badge fixturename"> vcr_config </span> <span class="badge fixturename"> vcr_cassette_dir </span> <span class="badge fixturename"> prepare_fixture </span> <span class="badge fixturename"> request </span> <span class="badge fixturename"> vcr_cassette </span> <span class="badge fixturename"> vcr_cassette_name </span> </td> </tr> </table> <div class=test-phases> <details class="phase setup "> <summary> <h4 class=title> <span class=phase-name>Setup</span> </h4> </summary> <div class=content> </div> </details> <details class="phase call passed" open> <summary> <h4 class=title> <span class="status  passed"></span> <span class=phase-name>Call</span> </h4> </summary> <div class=content> </div> </details> <details class="phase teardown "> <summary> <h4 class=title> <span class=phase-name>Teardown</span> </h4> </summary> <div class=content> </div> </details> </div> </div> </details> <details class="test passed"> <summary> <h3 class="title test-title"> <span class="status badge passed ">PASSED</span> <span class=test-name> <span class=funcname>TestRestClient::test_get_list_customer_with_filter</span> </span> <span class=duration>0:00:00.010775</span> </h3> </summary> <div class=content> <table class=metadata> <tr> <th>Started</th> <td>2023-06-30 01:14:57</td> </tr> <tr> <th>Ended</th> <td>2023-06-30 01:14:57</td> </tr> <tr> <th>Duration</th> <td>0:00:00.010775</td> </tr> <tr> <th>Markers</th> <td> <div class=marker> <span class="marker-name badge">vcr</span> <span class=marker-args> </span> </div> <div class=marker> <span class="marker-name badge">unit_test</span> <span class=marker-args> </span> </div> </td> </tr> <tr> <th>Fixtures</th> <td> <span class="badge fixturename"> django_test_environment </span> <span class="badge fixturename"> django_db_blocker </span> <span class="badge fixturename"> vcr </span> <span class="badge fixturename"> vcr_config </span> <span class="badge fixturename"> vcr_cassette_dir </span> <span class="badge fixturename"> prepare_fixture </span> <span class="badge fixturename"> request </span> <span class="badge fixturename"> vcr_cassette </span> <span class="badge fixturename"> vcr_cassette_name </span> </td> </tr> </table> <div class=test-phases> <details class="phase setup "> <summary> <h4 class=title> <span class=phase-name>Setup</span> </h4> </summary> <div class=content> </div> </details> <details class="phase call passed" open> <summary> <h4 class=title> <span class="status  passed"></span> <span class=phase-name>Call</span> </h4> </summary> <div class=content> </div> </details> <details class="phase teardown "> <summary> <h4 class=title> <span class=phase-name>Teardown</span> </h4> </summary> <div class=content> </div> </details> </div> </div> </details> <details class="test passed"> <summary> <h3 class="title test-title"> <span class="status badge passed ">PASSED</span> <span class=test-name> <span class=funcname>TestRestClient::test_get_list_customer_with_order</span> </span> <span class=duration>0:00:00.016524</span> </h3> </summary> <div class=content> <table class=metadata> <tr> <th>Started</th> <td>2023-06-30 01:14:57</td> </tr> <tr> <th>Ended</th> <td>2023-06-30 01:14:57</td> </tr> <tr> <th>Duration</th> <td>0:00:00.016524</td> </tr> <tr> <th>Markers</th> <td> <div class=marker> <span class="marker-name badge">vcr</span> <span class=marker-args> </span> </div> <div class=marker> <span class="marker-name badge">unit_test</span> <span class=marker-args> </span> </div> </td> </tr> <tr> <th>Fixtures</th> <td> <span class="badge fixturename"> django_test_environment </span> <span class="badge fixturename"> django_db_blocker </span> <span class="badge fixturename"> vcr </span> <span class="badge fixturename"> vcr_config </span> <span class="badge fixturename"> vcr_cassette_dir </span> <span class="badge fixturename"> prepare_fixture </span> <span class="badge fixturename"> request </span> <span class="badge fixturename"> vcr_cassette </span> <span class="badge fixturename"> vcr_cassette_name </span> </td> </tr> </table> <div class=test-phases> <details class="phase setup "> <summary> <h4 class=title> <span class=phase-name>Setup</span> </h4> </summary> <div class=content> </div> </details> <details class="phase call passed" open> <summary> <h4 class=title> <span class="status  passed"></span> <span class=phase-name>Call</span> </h4> </summary> <div class=content> </div> </details> <details class="phase teardown "> <summary> <h4 class=title> <span class=phase-name>Teardown</span> </h4> </summary> <div class=content> </div> </details> </div> </div> </details> <details class="test passed"> <summary> <h3 class="title test-title"> <span class="status badge passed ">PASSED</span> <span class=test-name> <span class=funcname>TestRestClient::test_get_single_customer</span> </span> <span class=duration>0:00:00.010544</span> </h3> </summary> <div class=content> <table class=metadata> <tr> <th>Started</th> <td>2023-06-30 01:14:57</td> </tr> <tr> <th>Ended</th> <td>2023-06-30 01:14:57</td> </tr> <tr> <th>Duration</th> <td>0:00:00.010544</td> </tr> <tr> <th>Markers</th> <td> <div class=marker> <span class="marker-name badge">vcr</span> <span class=marker-args> </span> </div> <div class=marker> <span class="marker-name badge">unit_test</span> <span class=marker-args> </span> </div> </td> </tr> <tr> <th>Fixtures</th> <td> <span class="badge fixturename"> django_test_environment </span> <span class="badge fixturename"> django_db_blocker </span> <span class="badge fixturename"> vcr </span> <span class="badge fixturename"> vcr_config </span> <span class="badge fixturename"> vcr_cassette_dir </span> <span class="badge fixturename"> prepare_fixture </span> <span class="badge fixturename"> request </span> <span class="badge fixturename"> vcr_cassette </span> <span class="badge fixturename"> vcr_cassette_name </span> </td> </tr> </table> <div class=test-phases> <details class="phase setup "> <summary> <h4 class=title> <span class=phase-name>Setup</span> </h4> </summary> <div class=content> </div> </details> <details class="phase call passed" open> <summary> <h4 class=title> <span class="status  passed"></span> <span class=phase-name>Call</span> </h4> </summary> <div class=content> </div> </details> <details class="phase teardown "> <summary> <h4 class=title> <span class=phase-name>Teardown</span> </h4> </summary> <div class=content> </div> </details> </div> </div> </details> <details class="test passed"> <summary> <h3 class="title test-title"> <span class="status badge passed ">PASSED</span> <span class=test-name> <span class=funcname>TestRestClient::test_paginate_customer_with_filters</span> </span> <span class=duration>0:00:00.011615</span> </h3> </summary> <div class=content> <table class=metadata> <tr> <th>Started</th> <td>2023-06-30 01:14:57</td> </tr> <tr> <th>Ended</th> <td>2023-06-30 01:14:57</td> </tr> <tr> <th>Duration</th> <td>0:00:00.011615</td> </tr> <tr> <th>Markers</th> <td> <div class=marker> <span class="marker-name badge">vcr</span> <span class=marker-args> </span> </div> <div class=marker> <span class="marker-name badge">unit_test</span> <span class=marker-args> </span> </div> </td> </tr> <tr> <th>Fixtures</th> <td> <span class="badge fixturename"> django_test_environment </span> <span class="badge fixturename"> django_db_blocker </span> <span class="badge fixturename"> vcr </span> <span class="badge fixturename"> vcr_config </span> <span class="badge fixturename"> vcr_cassette_dir </span> <span class="badge fixturename"> prepare_fixture </span> <span class="badge fixturename"> request </span> <span class="badge fixturename"> vcr_cassette </span> <span class="badge fixturename"> vcr_cassette_name </span> </td> </tr> </table> <div class=test-phases> <details class="phase setup "> <summary> <h4 class=title> <span class=phase-name>Setup</span> </h4> </summary> <div class=content> </div> </details> <details class="phase call passed" open> <summary> <h4 class=title> <span class="status  passed"></span> <span class=phase-name>Call</span> </h4> </summary> <div class=content> </div> </details> <details class="phase teardown "> <summary> <h4 class=title> <span class=phase-name>Teardown</span> </h4> </summary> <div class=content> </div> </details> </div> </div> </details> <details class="test passed"> <summary> <h3 class="title test-title"> <span class="status badge passed ">PASSED</span> <span class=test-name> <span class=funcname>TestRestClient::test_paginate_customer_with_order</span> </span> <span class=duration>0:00:00.014948</span> </h3> </summary> <div class=content> <table class=metadata> <tr> <th>Started</th> <td>2023-06-30 01:14:57</td> </tr> <tr> <th>Ended</th> <td>2023-06-30 01:14:57</td> </tr> <tr> <th>Duration</th> <td>0:00:00.014948</td> </tr> <tr> <th>Markers</th> <td> <div class=marker> <span class="marker-name badge">vcr</span> <span class=marker-args> </span> </div> <div class=marker> <span class="marker-name badge">unit_test</span> <span class=marker-args> </span> </div> </td> </tr> <tr> <th>Fixtures</th> <td> <span class="badge fixturename"> django_test_environment </span> <span class="badge fixturename"> django_db_blocker </span> <span class="badge fixturename"> vcr </span> <span class="badge fixturename"> vcr_config </span> <span class="badge fixturename"> vcr_cassette_dir </span> <span class="badge fixturename"> prepare_fixture </span> <span class="badge fixturename"> request </span> <span class="badge fixturename"> vcr_cassette </span> <span class="badge fixturename"> vcr_cassette_name </span> </td> </tr> </table> <div class=test-phases> <details class="phase setup "> <summary> <h4 class=title> <span class=phase-name>Setup</span> </h4> </summary> <div class=content> </div> </details> <details class="phase call passed" open> <summary> <h4 class=title> <span class="status  passed"></span> <span class=phase-name>Call</span> </h4> </summary> <div class=content> </div> </details> <details class="phase teardown "> <summary> <h4 class=title> <span class=phase-name>Teardown</span> </h4> </summary> <div class=content> </div> </details> </div> </div> </details> <details class="test passed"> <summary> <h3 class="title test-title"> <span class="status badge passed ">PASSED</span> <span class=test-name> <span class=funcname>TestRestClient::test_rest_get_retry</span> </span> <span class=duration>0:00:00.621765</span> </h3> </summary> <div class=content> <table class=metadata> <tr> <th>Started</th> <td>2023-06-30 01:14:57</td> </tr> <tr> <th>Ended</th> <td>2023-06-30 01:14:58</td> </tr> <tr> <th>Duration</th> <td>0:00:00.621765</td> </tr> <tr> <th>Markers</th> <td> <div class=marker> <span class="marker-name badge">vcr</span> <span class=marker-args> </span> </div> <div class=marker> <span class="marker-name badge">unit_test</span> <span class=marker-args> </span> </div> </td> </tr> <tr> <th>Fixtures</th> <td> <span class="badge fixturename"> django_test_environment </span> <span class="badge fixturename"> django_db_blocker </span> <span class="badge fixturename"> vcr </span> <span class="badge fixturename"> vcr_config </span> <span class="badge fixturename"> vcr_cassette_dir </span> <span class="badge fixturename"> prepare_fixture </span> <span class="badge fixturename"> request </span> <span class="badge fixturename"> vcr_cassette </span> <span class="badge fixturename"> vcr_cassette_name </span> </td> </tr> </table> <div class=test-phases> <details class="phase setup "> <summary> <h4 class=title> <span class=phase-name>Setup</span> </h4> </summary> <div class=content> </div> </details> <details class="phase call passed" open> <summary> <h4 class=title> <span class="status  passed"></span> <span class=phase-name>Call</span> </h4> </summary> <div class=content> </div> </details> <details class="phase teardown "> <summary> <h4 class=title> <span class=phase-name>Teardown</span> </h4> </summary> <div class=content> </div> </details> </div> </div> </details> <details class="test passed"> <summary> <h3 class="title test-title"> <span class="status badge passed ">PASSED</span> <span class=test-name> <span class=funcname>TestRestClient::test_rest_post_retry</span> </span> <span class=duration>0:00:00.623116</span> </h3> </summary> <div class=content> <table class=metadata> <tr> <th>Started</th> <td>2023-06-30 01:14:58</td> </tr> <tr> <th>Ended</th> <td>2023-06-30 01:14:58</td> </tr> <tr> <th>Duration</th> <td>0:00:00.623116</td> </tr> <tr> <th>Markers</th> <td> <div class=marker> <span class="marker-name badge">vcr</span> <span class=marker-args> </span> </div> <div class=marker> <span class="marker-name badge">unit_test</span> <span class=marker-args> </span> </div> </td> </tr> <tr> <th>Fixtures</th> <td> <span class="badge fixturename"> django_test_environment </span> <span class="badge fixturename"> django_db_blocker </span> <span class="badge fixturename"> vcr </span> <span class="badge fixturename"> vcr_config </span> <span class="badge fixturename"> vcr_cassette_dir </span> <span class="badge fixturename"> prepare_fixture </span> <span class="badge fixturename"> request </span> <span class="badge fixturename"> vcr_cassette </span> <span class="badge fixturename"> vcr_cassette_name </span> </td> </tr> </table> <div class=test-phases> <details class="phase setup "> <summary> <h4 class=title> <span class=phase-name>Setup</span> </h4> </summary> <div class=content> </div> </details> <details class="phase call passed" open> <summary> <h4 class=title> <span class="status  passed"></span> <span class=phase-name>Call</span> </h4> </summary> <div class=content> </div> </details> <details class="phase teardown "> <summary> <h4 class=title> <span class=phase-name>Teardown</span> </h4> </summary> <div class=content> </div> </details> </div> </div> </details> </div> </details> <details class=file> <summary> <h2 class="title file-title"> <span class=fspath> app/x3_wrapper/tests/test_soap_client.py </span> <span class=counts> <span title="9 passed" class="count status badge passed ">9</span> </span> <span class=duration> 0:00:00.150033 </span> </h2> </summary> <div class="content box"> <details class="test passed"> <summary> <h3 class="title test-title"> <span class="status badge passed ">PASSED</span> <span class=test-name> <span class=funcname>TestSoapClient::test_export_clients_csv</span> </span> <span class=duration>0:00:00.085018</span> </h3> </summary> <div class=content> <table class=metadata> <tr> <th>Started</th> <td>2023-06-30 01:14:58</td> </tr> <tr> <th>Ended</th> <td>2023-06-30 01:14:58</td> </tr> <tr> <th>Duration</th> <td>0:00:00.085018</td> </tr> <tr> <th>Markers</th> <td> <div class=marker> <span class="marker-name badge">vcr</span> <span class=marker-args> </span> </div> <div class=marker> <span class="marker-name badge">unit_test</span> <span class=marker-args> </span> </div> </td> </tr> <tr> <th>Fixtures</th> <td> <span class="badge fixturename"> django_test_environment </span> <span class="badge fixturename"> django_db_blocker </span> <span class="badge fixturename"> request </span> </td> </tr> </table> <div class=test-phases> <details class="phase setup "> <summary> <h4 class=title> <span class=phase-name>Setup</span> </h4> </summary> <div class=content> </div> </details> <details class="phase call passed" open> <summary> <h4 class=title> <span class="status  passed"></span> <span class=phase-name>Call</span> </h4> </summary> <div class=content> </div> </details> <details class="phase teardown "> <summary> <h4 class=title> <span class=phase-name>Teardown</span> </h4> </summary> <div class=content> </div> </details> </div> </div> </details> <details class="test passed"> <summary> <h3 class="title test-title"> <span class="status badge passed ">PASSED</span> <span class=test-name> <span class=funcname>TestSoapClient::test_export_clients_xml</span> </span> <span class=duration>0:00:00.015043</span> </h3> </summary> <div class=content> <table class=metadata> <tr> <th>Started</th> <td>2023-06-30 01:14:58</td> </tr> <tr> <th>Ended</th> <td>2023-06-30 01:14:58</td> </tr> <tr> <th>Duration</th> <td>0:00:00.015043</td> </tr> <tr> <th>Markers</th> <td> <div class=marker> <span class="marker-name badge">vcr</span> <span class=marker-args> </span> </div> <div class=marker> <span class="marker-name badge">unit_test</span> <span class=marker-args> </span> </div> </td> </tr> <tr> <th>Fixtures</th> <td> <span class="badge fixturename"> django_test_environment </span> <span class="badge fixturename"> django_db_blocker </span> <span class="badge fixturename"> request </span> </td> </tr> </table> <div class=test-phases> <details class="phase setup "> <summary> <h4 class=title> <span class=phase-name>Setup</span> </h4> </summary> <div class=content> </div> </details> <details class="phase call passed" open> <summary> <h4 class=title> <span class="status  passed"></span> <span class=phase-name>Call</span> </h4> </summary> <div class=content> </div> </details> <details class="phase teardown "> <summary> <h4 class=title> <span class=phase-name>Teardown</span> </h4> </summary> <div class=content> </div> </details> </div> </div> </details> <details class="test passed"> <summary> <h3 class="title test-title"> <span class="status badge passed ">PASSED</span> <span class=test-name> <span class=funcname>TestSoapClient::test_export_products_csv</span> </span> <span class=duration>0:00:00.001583</span> </h3> </summary> <div class=content> <table class=metadata> <tr> <th>Started</th> <td>2023-06-30 01:14:58</td> </tr> <tr> <th>Ended</th> <td>2023-06-30 01:14:58</td> </tr> <tr> <th>Duration</th> <td>0:00:00.001583</td> </tr> <tr> <th>Markers</th> <td> <div class=marker> <span class="marker-name badge">unit_test</span> <span class=marker-args> </span> </div> </td> </tr> <tr> <th>Fixtures</th> <td> <span class="badge fixturename"> django_test_environment </span> <span class="badge fixturename"> django_db_blocker </span> <span class="badge fixturename"> request </span> </td> </tr> </table> <div class=test-phases> <details class="phase setup "> <summary> <h4 class=title> <span class=phase-name>Setup</span> </h4> </summary> <div class=content> </div> </details> <details class="phase call passed" open> <summary> <h4 class=title> <span class="status  passed"></span> <span class=phase-name>Call</span> </h4> </summary> <div class=content> </div> </details> <details class="phase teardown "> <summary> <h4 class=title> <span class=phase-name>Teardown</span> </h4> </summary> <div class=content> </div> </details> </div> </div> </details> <details class="test passed"> <summary> <h3 class="title test-title"> <span class="status badge passed ">PASSED</span> <span class=test-name> <span class=funcname>TestSoapClient::test_failed_call</span> </span> <span class=duration>0:00:00.001287</span> </h3> </summary> <div class=content> <table class=metadata> <tr> <th>Started</th> <td>2023-06-30 01:14:58</td> </tr> <tr> <th>Ended</th> <td>2023-06-30 01:14:58</td> </tr> <tr> <th>Duration</th> <td>0:00:00.001287</td> </tr> <tr> <th>Markers</th> <td> <div class=marker> <span class="marker-name badge">unit_test</span> <span class=marker-args> </span> </div> </td> </tr> <tr> <th>Fixtures</th> <td> <span class="badge fixturename"> django_test_environment </span> <span class="badge fixturename"> django_db_blocker </span> <span class="badge fixturename"> request </span> </td> </tr> </table> <div class=test-phases> <details class="phase setup "> <summary> <h4 class=title> <span class=phase-name>Setup</span> </h4> </summary> <div class=content> </div> </details> <details class="phase call passed" open> <summary> <h4 class=title> <span class="status  passed"></span> <span class=phase-name>Call</span> </h4> </summary> <div class=content> </div> </details> <details class="phase teardown "> <summary> <h4 class=title> <span class=phase-name>Teardown</span> </h4> </summary> <div class=content> </div> </details> </div> </div> </details> <details class="test passed"> <summary> <h3 class="title test-title"> <span class="status badge passed ">PASSED</span> <span class=test-name> <span class=funcname>TestSoapClient::test_import_contract</span> </span> <span class=duration>0:00:00.011425</span> </h3> </summary> <div class=content> <table class=metadata> <tr> <th>Started</th> <td>2023-06-30 01:14:58</td> </tr> <tr> <th>Ended</th> <td>2023-06-30 01:14:58</td> </tr> <tr> <th>Duration</th> <td>0:00:00.011425</td> </tr> <tr> <th>Markers</th> <td> <div class=marker> <span class="marker-name badge">vcr</span> <span class=marker-args> </span> </div> <div class=marker> <span class="marker-name badge">unit_test</span> <span class=marker-args> </span> </div> </td> </tr> <tr> <th>Fixtures</th> <td> <span class="badge fixturename"> django_test_environment </span> <span class="badge fixturename"> django_db_blocker </span> <span class="badge fixturename"> request </span> </td> </tr> </table> <div class=test-phases> <details class="phase setup "> <summary> <h4 class=title> <span class=phase-name>Setup</span> </h4> </summary> <div class=content> </div> </details> <details class="phase call passed" open> <summary> <h4 class=title> <span class="status  passed"></span> <span class=phase-name>Call</span> </h4> </summary> <div class=content> </div> </details> <details class="phase teardown "> <summary> <h4 class=title> <span class=phase-name>Teardown</span> </h4> </summary> <div class=content> </div> </details> </div> </div> </details> <details class="test passed"> <summary> <h3 class="title test-title"> <span class="status badge passed ">PASSED</span> <span class=test-name> <span class=funcname>TestSoapClient::test_save_order</span> </span> <span class=duration>0:00:00.011171</span> </h3> </summary> <div class=content> <table class=metadata> <tr> <th>Started</th> <td>2023-06-30 01:14:58</td> </tr> <tr> <th>Ended</th> <td>2023-06-30 01:14:58</td> </tr> <tr> <th>Duration</th> <td>0:00:00.011171</td> </tr> <tr> <th>Markers</th> <td> <div class=marker> <span class="marker-name badge">vcr</span> <span class=marker-args> </span> </div> <div class=marker> <span class="marker-name badge">unit_test</span> <span class=marker-args> </span> </div> </td> </tr> <tr> <th>Fixtures</th> <td> <span class="badge fixturename"> django_test_environment </span> <span class="badge fixturename"> django_db_blocker </span> <span class="badge fixturename"> request </span> </td> </tr> </table> <div class=test-phases> <details class="phase setup "> <summary> <h4 class=title> <span class=phase-name>Setup</span> </h4> </summary> <div class=content> </div> </details> <details class="phase call passed" open> <summary> <h4 class=title> <span class="status  passed"></span> <span class=phase-name>Call</span> </h4> </summary> <div class=content> </div> </details> <details class="phase teardown "> <summary> <h4 class=title> <span class=phase-name>Teardown</span> </h4> </summary> <div class=content> </div> </details> </div> </div> </details> <details class="test passed"> <summary> <h3 class="title test-title"> <span class="status badge passed ">PASSED</span> <span class=test-name> <span class=funcname>TestSoapClient::test_succes_query</span> </span> <span class=duration>0:00:00.001311</span> </h3> </summary> <div class=content> <table class=metadata> <tr> <th>Started</th> <td>2023-06-30 01:14:58</td> </tr> <tr> <th>Ended</th> <td>2023-06-30 01:14:58</td> </tr> <tr> <th>Duration</th> <td>0:00:00.001311</td> </tr> <tr> <th>Markers</th> <td> <div class=marker> <span class="marker-name badge">unit_test</span> <span class=marker-args> </span> </div> </td> </tr> <tr> <th>Fixtures</th> <td> <span class="badge fixturename"> django_test_environment </span> <span class="badge fixturename"> django_db_blocker </span> <span class="badge fixturename"> request </span> </td> </tr> </table> <div class=test-phases> <details class="phase setup "> <summary> <h4 class=title> <span class=phase-name>Setup</span> </h4> </summary> <div class=content> </div> </details> <details class="phase call passed" open> <summary> <h4 class=title> <span class="status  passed"></span> <span class=phase-name>Call</span> </h4> </summary> <div class=content> </div> </details> <details class="phase teardown "> <summary> <h4 class=title> <span class=phase-name>Teardown</span> </h4> </summary> <div class=content> </div> </details> </div> </div> </details> <details class="test passed"> <summary> <h3 class="title test-title"> <span class="status badge passed ">PASSED</span> <span class=test-name> <span class=funcname>TestSoapClient::test_succes_query_with_filters</span> </span> <span class=duration>0:00:00.001257</span> </h3> </summary> <div class=content> <table class=metadata> <tr> <th>Started</th> <td>2023-06-30 01:14:58</td> </tr> <tr> <th>Ended</th> <td>2023-06-30 01:14:58</td> </tr> <tr> <th>Duration</th> <td>0:00:00.001257</td> </tr> <tr> <th>Markers</th> <td> <div class=marker> <span class="marker-name badge">unit_test</span> <span class=marker-args> </span> </div> </td> </tr> <tr> <th>Fixtures</th> <td> <span class="badge fixturename"> django_test_environment </span> <span class="badge fixturename"> django_db_blocker </span> <span class="badge fixturename"> request </span> </td> </tr> </table> <div class=test-phases> <details class="phase setup "> <summary> <h4 class=title> <span class=phase-name>Setup</span> </h4> </summary> <div class=content> </div> </details> <details class="phase call passed" open> <summary> <h4 class=title> <span class="status  passed"></span> <span class=phase-name>Call</span> </h4> </summary> <div class=content> </div> </details> <details class="phase teardown "> <summary> <h4 class=title> <span class=phase-name>Teardown</span> </h4> </summary> <div class=content> </div> </details> </div> </div> </details> <details class="test passed"> <summary> <h3 class="title test-title"> <span class="status badge passed ">PASSED</span> <span class=test-name> <span class=funcname>TestSoapClient::test_succes_read</span> </span> <span class=duration>0:00:00.021937</span> </h3> </summary> <div class=content> <table class=metadata> <tr> <th>Started</th> <td>2023-06-30 01:14:58</td> </tr> <tr> <th>Ended</th> <td>2023-06-30 01:14:58</td> </tr> <tr> <th>Duration</th> <td>0:00:00.021937</td> </tr> <tr> <th>Markers</th> <td> <div class=marker> <span class="marker-name badge">unit_test</span> <span class=marker-args> </span> </div> </td> </tr> <tr> <th>Fixtures</th> <td> <span class="badge fixturename"> django_test_environment </span> <span class="badge fixturename"> django_db_blocker </span> <span class="badge fixturename"> request </span> </td> </tr> </table> <div class=test-phases> <details class="phase setup "> <summary> <h4 class=title> <span class=phase-name>Setup</span> </h4> </summary> <div class=content> </div> </details> <details class="phase call passed" open> <summary> <h4 class=title> <span class="status  passed"></span> <span class=phase-name>Call</span> </h4> </summary> <div class=content> </div> </details> <details class="phase teardown "> <summary> <h4 class=title> <span class=phase-name>Teardown</span> </h4> </summary> <div class=content> </div> </details> </div> </div> </details> </div> </details> </div> </section> </main> <footer> <div class=container> Generated by <a href=https://pypi.org/project/pytest-reporter-html1/ >pytest-reporter-html1</a> </div> </footer> </body> </html>